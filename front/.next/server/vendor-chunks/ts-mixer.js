"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ts-mixer";
exports.ids = ["vendor-chunks/ts-mixer"];
exports.modules = {

/***/ "(ssr)/./node_modules/ts-mixer/dist/esm/index.js":
/*!*************************************************!*\
  !*** ./node_modules/ts-mixer/dist/esm/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mixin: () => (/* binding */ Mixin),\n/* harmony export */   decorate: () => (/* binding */ decorate),\n/* harmony export */   hasMixin: () => (/* binding */ hasMixin),\n/* harmony export */   mix: () => (/* binding */ mix),\n/* harmony export */   settings: () => (/* binding */ settings)\n/* harmony export */ });\n/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */ const copyProps = (dest, src, exclude = [])=>{\n    const props = Object.getOwnPropertyDescriptors(src);\n    for (let prop of exclude)delete props[prop];\n    Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */ const protoChain = (obj, currentChain = [\n    obj\n])=>{\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null) return currentChain;\n    return protoChain(proto, [\n        ...currentChain,\n        proto\n    ]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */ const nearestCommonProto = (...objs)=>{\n    if (objs.length === 0) return undefined;\n    let commonProto = undefined;\n    const protoChains = objs.map((obj)=>protoChain(obj));\n    while(protoChains.every((protoChain)=>protoChain.length > 0)){\n        const protos = protoChains.map((protoChain)=>protoChain.pop());\n        const potentialCommonProto = protos[0];\n        if (protos.every((proto)=>proto === potentialCommonProto)) commonProto = potentialCommonProto;\n        else break;\n    }\n    return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */ const hardMixProtos = (ingredients, constructor, exclude = [])=>{\n    var _a;\n    const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n    const mixedProto = Object.create(base);\n    // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n    // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n    // when they will already be accessible via prototype access.\n    const visitedProtos = protoChain(base);\n    for (let prototype of ingredients){\n        let protos = protoChain(prototype);\n        // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n        for(let i = protos.length - 1; i >= 0; i--){\n            let newProto = protos[i];\n            if (visitedProtos.indexOf(newProto) === -1) {\n                copyProps(mixedProto, newProto, [\n                    \"constructor\",\n                    ...exclude\n                ]);\n                visitedProtos.push(newProto);\n            }\n        }\n    }\n    mixedProto.constructor = constructor;\n    return mixedProto;\n};\nconst unique = (arr)=>arr.filter((e, i)=>arr.indexOf(e) == i);\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */ const getIngredientWithProp = (prop, ingredients)=>{\n    const protoChains = ingredients.map((ingredient)=>protoChain(ingredient));\n    // since we search breadth-first, we need to keep track of our depth in the prototype chains\n    let protoDepth = 0;\n    // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n    // prototype chains has an object at this depth\n    let protosAreLeftToSearch = true;\n    while(protosAreLeftToSearch){\n        // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n        protosAreLeftToSearch = false;\n        // scan through the ingredients right to left\n        for(let i = ingredients.length - 1; i >= 0; i--){\n            const searchTarget = protoChains[i][protoDepth];\n            if (searchTarget !== undefined && searchTarget !== null) {\n                // if we find something, this is proof that this horizontal slice potentially more objects to search\n                protosAreLeftToSearch = true;\n                // eureka, we found it\n                if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n                    return protoChains[i][0];\n                }\n            }\n        }\n        protoDepth++;\n    }\n    return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */ const proxyMix = (ingredients, prototype = Object.prototype)=>new Proxy({}, {\n        getPrototypeOf () {\n            return prototype;\n        },\n        setPrototypeOf () {\n            throw Error(\"Cannot set prototype of Proxies created by ts-mixer\");\n        },\n        getOwnPropertyDescriptor (_, prop) {\n            return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n        },\n        defineProperty () {\n            throw new Error(\"Cannot define new properties on Proxies created by ts-mixer\");\n        },\n        has (_, prop) {\n            return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n        },\n        get (_, prop) {\n            return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n        },\n        set (_, prop, val) {\n            const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n            if (ingredientWithProp === undefined) throw new Error(\"Cannot set new properties on Proxies created by ts-mixer\");\n            ingredientWithProp[prop] = val;\n            return true;\n        },\n        deleteProperty () {\n            throw new Error(\"Cannot delete properties on Proxies created by ts-mixer\");\n        },\n        ownKeys () {\n            return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr)=>curr.concat(prev.filter((key)=>curr.indexOf(key) < 0)));\n        }\n    });\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */ const softMixProtos = (ingredients, constructor)=>proxyMix([\n        ...ingredients,\n        {\n            constructor\n        }\n    ]);\nconst settings = {\n    initFunction: null,\n    staticsStrategy: \"copy\",\n    prototypeStrategy: \"copy\",\n    decoratorInheritance: \"deep\"\n};\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new Map();\nconst getMixinsForClass = (clazz)=>mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents)=>mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin)=>{\n    if (instance instanceof mixin) return true;\n    const constructor = instance.constructor;\n    const visited = new Set();\n    let frontier = new Set();\n    frontier.add(constructor);\n    while(frontier.size > 0){\n        // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n        if (frontier.has(mixin)) return true;\n        frontier.forEach((item)=>visited.add(item));\n        // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n        const newFrontier = new Set();\n        frontier.forEach((item)=>{\n            var _a;\n            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map((proto)=>proto.constructor).filter((item)=>item !== null);\n            if (itemConstituents) itemConstituents.forEach((constituent)=>{\n                if (!visited.has(constituent) && !frontier.has(constituent)) newFrontier.add(constituent);\n            });\n        });\n        // we have a new frontier, now search again\n        frontier = newFrontier;\n    }\n    // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n    return false;\n};\nconst mergeObjectsOfDecorators = (o1, o2)=>{\n    var _a, _b;\n    const allKeys = unique([\n        ...Object.getOwnPropertyNames(o1),\n        ...Object.getOwnPropertyNames(o2)\n    ]);\n    const mergedObject = {};\n    for (let key of allKeys)mergedObject[key] = unique([\n        ...(_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : [],\n        ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []\n    ]);\n    return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2)=>{\n    var _a, _b, _c, _d;\n    return {\n        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})\n    };\n};\nconst mergeDecorators = (d1, d2)=>{\n    var _a, _b, _c, _d, _e, _f;\n    return {\n        class: unique([\n            ...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [],\n            ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []\n        ]),\n        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})\n    };\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = (...classes)=>{\n    var _a;\n    const allClasses = new Set();\n    const frontier = new Set([\n        ...classes\n    ]);\n    while(frontier.size > 0){\n        for (let clazz of frontier){\n            const protoChainClasses = protoChain(clazz.prototype).map((proto)=>proto.constructor);\n            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n            const potentiallyNewClasses = [\n                ...protoChainClasses,\n                ...mixinClasses\n            ];\n            const newClasses = potentiallyNewClasses.filter((c)=>!allClasses.has(c));\n            for (let newClass of newClasses)frontier.add(newClass);\n            allClasses.add(clazz);\n            frontier.delete(clazz);\n        }\n    }\n    return [\n        ...allClasses\n    ];\n};\nconst deepDecoratorSearch = (...classes)=>{\n    const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz)=>decorators.get(clazz)).filter((decorators)=>!!decorators);\n    if (decoratorsForClassChain.length == 0) return {};\n    if (decoratorsForClassChain.length == 1) return decoratorsForClassChain[0];\n    return decoratorsForClassChain.reduce((d1, d2)=>mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = (...classes)=>{\n    const classDecorators = classes.map((clazz)=>getDecoratorsForClass(clazz));\n    if (classDecorators.length === 0) return {};\n    if (classDecorators.length === 1) return classDecorators[0];\n    return classDecorators.reduce((d1, d2)=>mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = (clazz)=>{\n    let decoratorsForClass = decorators.get(clazz);\n    if (!decoratorsForClass) {\n        decoratorsForClass = {};\n        decorators.set(clazz, decoratorsForClass);\n    }\n    return decoratorsForClass;\n};\nconst decorateClass = (decorator)=>(clazz)=>{\n        const decoratorsForClass = getDecoratorsForClass(clazz);\n        let classDecorators = decoratorsForClass.class;\n        if (!classDecorators) {\n            classDecorators = [];\n            decoratorsForClass.class = classDecorators;\n        }\n        classDecorators.push(decorator);\n        return decorator(clazz);\n    };\nconst decorateMember = (decorator)=>(object, key, ...otherArgs)=>{\n        var _a, _b, _c;\n        const decoratorTargetType = typeof object === \"function\" ? \"static\" : \"instance\";\n        const decoratorType = typeof object[key] === \"function\" ? \"method\" : \"property\";\n        const clazz = decoratorTargetType === \"static\" ? object : object.constructor;\n        const decoratorsForClass = getDecoratorsForClass(clazz);\n        const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};\n        decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n        let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};\n        decoratorsForTargetType[decoratorType] = decoratorsForType;\n        let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];\n        decoratorsForType[key] = decoratorsForKey;\n        // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine\n        decoratorsForKey.push(decorator);\n        // @ts-ignore\n        return decorator(object, key, ...otherArgs);\n    };\nconst decorate = (decorator)=>(...args)=>{\n        if (args.length === 1) return decorateClass(decorator)(args[0]);\n        return decorateMember(decorator)(...args);\n    };\nfunction Mixin(...constructors) {\n    var _a, _b, _c;\n    const prototypes = constructors.map((constructor)=>constructor.prototype);\n    // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n    // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n    // similarly to constructors -- not methods, which simply override each other.\n    const initFunctionName = settings.initFunction;\n    if (initFunctionName !== null) {\n        const initFunctions = prototypes.map((proto)=>proto[initFunctionName]).filter((func)=>typeof func === \"function\");\n        const combinedInitFunction = function(...args) {\n            for (let initFunction of initFunctions)initFunction.apply(this, args);\n        };\n        const extraProto = {\n            [initFunctionName]: combinedInitFunction\n        };\n        prototypes.push(extraProto);\n    }\n    function MixedClass(...args) {\n        for (const constructor of constructors)// @ts-ignore: potentially abstract class\n        copyProps(this, new constructor(...args));\n        if (initFunctionName !== null && typeof this[initFunctionName] === \"function\") this[initFunctionName].apply(this, args);\n    }\n    MixedClass.prototype = settings.prototypeStrategy === \"copy\" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);\n    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === \"copy\" ? hardMixProtos(constructors, null, [\n        \"prototype\"\n    ]) : proxyMix(constructors, Function.prototype));\n    let DecoratedMixedClass = MixedClass;\n    if (settings.decoratorInheritance !== \"none\") {\n        const classDecorators = settings.decoratorInheritance === \"deep\" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);\n        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []){\n            const result = decorator(DecoratedMixedClass);\n            if (result) {\n                DecoratedMixedClass = result;\n            }\n        }\n        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n    }\n    registerMixins(DecoratedMixedClass, constructors);\n    return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target)=>{\n    const propDecorators = propAndMethodDecorators.property;\n    const methodDecorators = propAndMethodDecorators.method;\n    if (propDecorators) for(let key in propDecorators)for (let decorator of propDecorators[key])decorator(target, key);\n    if (methodDecorators) for(let key in methodDecorators)for (let decorator of methodDecorators[key])decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */ const mix = (...ingredients)=>(decoratedClass)=>{\n        // @ts-ignore\n        const mixedClass = Mixin(...ingredients.concat([\n            decoratedClass\n        ]));\n        Object.defineProperty(mixedClass, \"name\", {\n            value: decoratedClass.name,\n            writable: false\n        });\n        return mixedClass;\n    };\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHMtbWl4ZXIvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxNQUFNQSxZQUFZLENBQUNDLE1BQU1DLEtBQUtDLFVBQVUsRUFBRTtJQUN0QyxNQUFNQyxRQUFRQyxPQUFPQyx5QkFBeUIsQ0FBQ0o7SUFDL0MsS0FBSyxJQUFJSyxRQUFRSixRQUNiLE9BQU9DLEtBQUssQ0FBQ0csS0FBSztJQUN0QkYsT0FBT0csZ0JBQWdCLENBQUNQLE1BQU1HO0FBQ2xDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUssYUFBYSxDQUFDQyxLQUFLQyxlQUFlO0lBQUNEO0NBQUk7SUFDekMsTUFBTUUsUUFBUVAsT0FBT1EsY0FBYyxDQUFDSDtJQUNwQyxJQUFJRSxVQUFVLE1BQ1YsT0FBT0Q7SUFDWCxPQUFPRixXQUFXRyxPQUFPO1dBQUlEO1FBQWNDO0tBQU07QUFDckQ7QUFDQTs7O0NBR0MsR0FDRCxNQUFNRSxxQkFBcUIsQ0FBQyxHQUFHQztJQUMzQixJQUFJQSxLQUFLQyxNQUFNLEtBQUssR0FDaEIsT0FBT0M7SUFDWCxJQUFJQyxjQUFjRDtJQUNsQixNQUFNRSxjQUFjSixLQUFLSyxHQUFHLENBQUNWLENBQUFBLE1BQU9ELFdBQVdDO0lBQy9DLE1BQU9TLFlBQVlFLEtBQUssQ0FBQ1osQ0FBQUEsYUFBY0EsV0FBV08sTUFBTSxHQUFHLEdBQUk7UUFDM0QsTUFBTU0sU0FBU0gsWUFBWUMsR0FBRyxDQUFDWCxDQUFBQSxhQUFjQSxXQUFXYyxHQUFHO1FBQzNELE1BQU1DLHVCQUF1QkYsTUFBTSxDQUFDLEVBQUU7UUFDdEMsSUFBSUEsT0FBT0QsS0FBSyxDQUFDVCxDQUFBQSxRQUFTQSxVQUFVWSx1QkFDaENOLGNBQWNNO2FBRWQ7SUFDUjtJQUNBLE9BQU9OO0FBQ1g7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1PLGdCQUFnQixDQUFDQyxhQUFhQyxhQUFheEIsVUFBVSxFQUFFO0lBQ3pELElB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LE9BQU9VO0FBQ1g7QUFDQSxNQUFNRSwrQkFBK0IsQ0FBQ0MseUJBQXlCQztJQUMzRCxNQUFNQyxpQkFBaUJGLHdCQUF3QmxELFFBQVE7SUFDdkQsTUFBTXFELG1CQUFtQkgsd0JBQXdCakQsTUFBTTtJQUN2RCxJQUFJbUQsZ0JBQ0EsSUFBSyxJQUFJMUYsT0FBTzBGLGVBQ1osS0FBSyxJQUFJM0IsYUFBYTJCLGNBQWMsQ0FBQzFGLElBQUksQ0FDckMrRCxVQUFVMEIsUUFBUXpGO0lBQzlCLElBQUkyRixrQkFDQSxJQUFLLElBQUkzRixPQUFPMkYsaUJBQ1osS0FBSyxJQUFJNUIsYUFBYTRCLGdCQUFnQixDQUFDM0YsSUFBSSxDQUN2QytELFVBQVUwQixRQUFRekYsS0FBSzdELE9BQU8wQyx3QkFBd0IsQ0FBQzRHLFFBQVF6RjtBQUMvRTtBQUNBOztDQUVDLEdBQ0QsTUFBTTRGLE1BQU0sQ0FBQyxHQUFHcEksY0FBZ0JxSSxDQUFBQTtRQUM1QixhQUFhO1FBQ2IsTUFBTWpGLGFBQWE4RCxTQUFTbEgsWUFBWXVDLE1BQU0sQ0FBQztZQUFDOEY7U0FBZTtRQUMvRDFKLE9BQU9nRCxjQUFjLENBQUN5QixZQUFZLFFBQVE7WUFDdENrRixPQUFPRCxlQUFlRSxJQUFJO1lBQzFCQyxVQUFVO1FBQ2Q7UUFDQSxPQUFPcEY7SUFDWDtBQUVvRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhaXJvLWJvaWxlcnBsYXRlLXJlYWN0LW5leHQvLi9ub2RlX21vZHVsZXMvdHMtbWl4ZXIvZGlzdC9lc20vaW5kZXguanM/Mjk4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCB3b3JrcyBsaWtlIGBPYmplY3QuYXBwbHlgLCBidXQgY29waWVzIGdldHRlcnMgYW5kIHNldHRlcnMgcHJvcGVybHkgYXMgd2VsbC4gIEFkZGl0aW9uYWxseSBnaXZlc1xuICogdGhlIG9wdGlvbiB0byBleGNsdWRlIHByb3BlcnRpZXMgYnkgbmFtZS5cbiAqL1xuY29uc3QgY29weVByb3BzID0gKGRlc3QsIHNyYywgZXhjbHVkZSA9IFtdKSA9PiB7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzcmMpO1xuICAgIGZvciAobGV0IHByb3Agb2YgZXhjbHVkZSlcbiAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BdO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRlc3QsIHByb3BzKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bGwgY2hhaW4gb2YgcHJvdG90eXBlcyB1cCB1bnRpbCBPYmplY3QucHJvdG90eXBlIGdpdmVuIGEgc3RhcnRpbmcgb2JqZWN0LiAgVGhlIG9yZGVyIG9mIHByb3RvdHlwZXMgd2lsbFxuICogYmUgY2xvc2VzdCB0byBmYXJ0aGVzdCBpbiB0aGUgY2hhaW4uXG4gKi9cbmNvbnN0IHByb3RvQ2hhaW4gPSAob2JqLCBjdXJyZW50Q2hhaW4gPSBbb2JqXSkgPT4ge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgaWYgKHByb3RvID09PSBudWxsKVxuICAgICAgICByZXR1cm4gY3VycmVudENoYWluO1xuICAgIHJldHVybiBwcm90b0NoYWluKHByb3RvLCBbLi4uY3VycmVudENoYWluLCBwcm90b10pO1xufTtcbi8qKlxuICogSWRlbnRpZmllcyB0aGUgbmVhcmVzdCBhbmNlc3RvciBjb21tb24gdG8gYWxsIHRoZSBnaXZlbiBvYmplY3RzIGluIHRoZWlyIHByb3RvdHlwZSBjaGFpbnMuICBGb3IgbW9zdCB1bnJlbGF0ZWRcbiAqIG9iamVjdHMsIHRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBPYmplY3QucHJvdG90eXBlLlxuICovXG5jb25zdCBuZWFyZXN0Q29tbW9uUHJvdG8gPSAoLi4ub2JqcykgPT4ge1xuICAgIGlmIChvYmpzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgY29tbW9uUHJvdG8gPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvdG9DaGFpbnMgPSBvYmpzLm1hcChvYmogPT4gcHJvdG9DaGFpbihvYmopKTtcbiAgICB3aGlsZSAocHJvdG9DaGFpbnMuZXZlcnkocHJvdG9DaGFpbiA9PiBwcm90b0NoYWluLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIGNvbnN0IHByb3RvcyA9IHByb3RvQ2hhaW5zLm1hcChwcm90b0NoYWluID0+IHByb3RvQ2hhaW4ucG9wKCkpO1xuICAgICAgICBjb25zdCBwb3RlbnRpYWxDb21tb25Qcm90byA9IHByb3Rvc1swXTtcbiAgICAgICAgaWYgKHByb3Rvcy5ldmVyeShwcm90byA9PiBwcm90byA9PT0gcG90ZW50aWFsQ29tbW9uUHJvdG8pKVxuICAgICAgICAgICAgY29tbW9uUHJvdG8gPSBwb3RlbnRpYWxDb21tb25Qcm90bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjb21tb25Qcm90bztcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcHJvdG90eXBlIG9iamVjdCB0aGF0IGlzIGEgbWl4dHVyZSBvZiB0aGUgZ2l2ZW4gcHJvdG90eXBlcy4gIFRoZSBtaXhpbmcgaXMgYWNoaWV2ZWQgYnkgZmlyc3RcbiAqIGlkZW50aWZ5aW5nIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBhbmQgdXNpbmcgaXQgYXMgdGhlIHByb3RvdHlwZSBmb3IgYSBuZXcgb2JqZWN0LiAgVGhlbiBhbGwgcHJvcGVydGllcy9tZXRob2RzXG4gKiBkb3duc3RyZWFtIG9mIHRoaXMgcHJvdG90eXBlIChPTkxZIGRvd25zdHJlYW0pIGFyZSBjb3BpZWQgaW50byB0aGUgbmV3IG9iamVjdC5cbiAqXG4gKiBUaGUgcmVzdWx0aW5nIHByb3RvdHlwZSBpcyBtb3JlIHBlcmZvcm1hbnQgdGhhbiBzb2Z0TWl4UHJvdG9zKC4uLiksIGFzIHdlbGwgYXMgRVM1IGNvbXBhdGlibGUuICBIb3dldmVyLCBpdCdzIG5vdCBhc1xuICogZmxleGlibGUgYXMgdXBkYXRlcyB0byB0aGUgc291cmNlIHByb3RvdHlwZXMgYXJlbid0IGNhcHR1cmVkIGJ5IHRoZSBtaXhlZCByZXN1bHQuICBTZWUgc29mdE1peFByb3RvcyBmb3Igd2h5IHlvdSBtYXlcbiAqIHdhbnQgdG8gdXNlIHRoYXQgaW5zdGVhZC5cbiAqL1xuY29uc3QgaGFyZE1peFByb3RvcyA9IChpbmdyZWRpZW50cywgY29uc3RydWN0b3IsIGV4Y2x1ZGUgPSBbXSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBiYXNlID0gKF9hID0gbmVhcmVzdENvbW1vblByb3RvKC4uLmluZ3JlZGllbnRzKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogT2JqZWN0LnByb3RvdHlwZTtcbiAgICBjb25zdCBtaXhlZFByb3RvID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICAvLyBLZWVwcyB0cmFjayBvZiBwcm90b3R5cGVzIHdlJ3ZlIGFscmVhZHkgdmlzaXRlZCB0byBhdm9pZCBjb3B5aW5nIHRoZSBzYW1lIHByb3BlcnRpZXMgbXVsdGlwbGUgdGltZXMuICBXZSBpbml0IHRoZVxuICAgIC8vIGxpc3Qgd2l0aCB0aGUgcHJvdG8gY2hhaW4gYmVsb3cgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhbnkgb2YgdGhvc2UgbWV0aG9kcyBtaXhlZCBpblxuICAgIC8vIHdoZW4gdGhleSB3aWxsIGFscmVhZHkgYmUgYWNjZXNzaWJsZSB2aWEgcHJvdG90eXBlIGFjY2Vzcy5cbiAgICBjb25zdCB2aXNpdGVkUHJvdG9zID0gcHJvdG9DaGFpbihiYXNlKTtcbiAgICBmb3IgKGxldCBwcm90b3R5cGUgb2YgaW5ncmVkaWVudHMpIHtcbiAgICAgICAgbGV0IHByb3RvcyA9IHByb3RvQ2hhaW4ocHJvdG90eXBlKTtcbiAgICAgICAgLy8gQXBwbHkgdGhlIHByb3RvdHlwZSBjaGFpbiBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgb2xkIG1ldGhvZHMgZG9uJ3Qgb3ZlcnJpZGUgbmV3ZXIgb25lcy5cbiAgICAgICAgZm9yIChsZXQgaSA9IHByb3Rvcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3RvID0gcHJvdG9zW2ldO1xuICAgICAgICAgICAgaWYgKHZpc2l0ZWRQcm90b3MuaW5kZXhPZihuZXdQcm90bykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29weVByb3BzKG1peGVkUHJvdG8sIG5ld1Byb3RvLCBbJ2NvbnN0cnVjdG9yJywgLi4uZXhjbHVkZV0pO1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRQcm90b3MucHVzaChuZXdQcm90byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWl4ZWRQcm90by5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBtaXhlZFByb3RvO1xufTtcbmNvbnN0IHVuaXF1ZSA9IChhcnIpID0+IGFyci5maWx0ZXIoKGUsIGkpID0+IGFyci5pbmRleE9mKGUpID09IGkpO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmdyZWRpZW50IHdpdGggdGhlIGdpdmVuIHByb3AsIHNlYXJjaGluZyBpbiByZXZlcnNlIG9yZGVyIGFuZCBicmVhZHRoLWZpcnN0IGlmIHNlYXJjaGluZyBpbmdyZWRpZW50XG4gKiBwcm90b3R5cGVzIGlzIHJlcXVpcmVkLlxuICovXG5jb25zdCBnZXRJbmdyZWRpZW50V2l0aFByb3AgPSAocHJvcCwgaW5ncmVkaWVudHMpID0+IHtcbiAgICBjb25zdCBwcm90b0NoYWlucyA9IGluZ3JlZGllbnRzLm1hcChpbmdyZWRpZW50ID0+IHByb3RvQ2hhaW4oaW5ncmVkaWVudCkpO1xuICAgIC8vIHNpbmNlIHdlIHNlYXJjaCBicmVhZHRoLWZpcnN0LCB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygb3VyIGRlcHRoIGluIHRoZSBwcm90b3R5cGUgY2hhaW5zXG4gICAgbGV0IHByb3RvRGVwdGggPSAwO1xuICAgIC8vIG5vdCBhbGwgcHJvdG90eXBlIGNoYWlucyBhcmUgdGhlIHNhbWUgZGVwdGgsIHNvIHRoaXMgcmVtYWlucyB0cnVlIGFzIGxvbmcgYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBpbmdyZWRpZW50cydcbiAgICAvLyBwcm90b3R5cGUgY2hhaW5zIGhhcyBhbiBvYmplY3QgYXQgdGhpcyBkZXB0aFxuICAgIGxldCBwcm90b3NBcmVMZWZ0VG9TZWFyY2ggPSB0cnVlO1xuICAgIHdoaWxlIChwcm90b3NBcmVMZWZ0VG9TZWFyY2gpIHtcbiAgICAgICAgLy8gd2l0aCB0aGUgc3RhcnQgb2YgZWFjaCBob3Jpem9udGFsIHNsaWNlLCB3ZSBhc3N1bWUgdGhpcyBpcyB0aGUgb25lIHRoYXQncyBkZWVwZXIgdGhhbiBhbnkgb2YgdGhlIHByb3RvIGNoYWluc1xuICAgICAgICBwcm90b3NBcmVMZWZ0VG9TZWFyY2ggPSBmYWxzZTtcbiAgICAgICAgLy8gc2NhbiB0aHJvdWdoIHRoZSBpbmdyZWRpZW50cyByaWdodCB0byBsZWZ0XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmdyZWRpZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNoVGFyZ2V0ID0gcHJvdG9DaGFpbnNbaV1bcHJvdG9EZXB0aF07XG4gICAgICAgICAgICBpZiAoc2VhcmNoVGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgc2VhcmNoVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZmluZCBzb21ldGhpbmcsIHRoaXMgaXMgcHJvb2YgdGhhdCB0aGlzIGhvcml6b250YWwgc2xpY2UgcG90ZW50aWFsbHkgbW9yZSBvYmplY3RzIHRvIHNlYXJjaFxuICAgICAgICAgICAgICAgIHByb3Rvc0FyZUxlZnRUb1NlYXJjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gZXVyZWthLCB3ZSBmb3VuZCBpdFxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNlYXJjaFRhcmdldCwgcHJvcCkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm90b0NoYWluc1tpXVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG9EZXB0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8qKlxuICogXCJNaXhlc1wiIGluZ3JlZGllbnRzIGJ5IHdyYXBwaW5nIHRoZW0gaW4gYSBQcm94eS4gIFRoZSBvcHRpb25hbCBwcm90b3R5cGUgYXJndW1lbnQgYWxsb3dzIHRoZSBtaXhlZCBvYmplY3QgdG8gc2l0XG4gKiBkb3duc3RyZWFtIG9mIGFuIGV4aXN0aW5nIHByb3RvdHlwZSBjaGFpbi4gIE5vdGUgdGhhdCBcInByb3BlcnRpZXNcIiBjYW5ub3QgYmUgYWRkZWQsIGRlbGV0ZWQsIG9yIG1vZGlmaWVkLlxuICovXG5jb25zdCBwcm94eU1peCA9IChpbmdyZWRpZW50cywgcHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZSkgPT4gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICAgIHJldHVybiBwcm90b3R5cGU7XG4gICAgfSxcbiAgICBzZXRQcm90b3R5cGVPZigpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBzZXQgcHJvdG90eXBlIG9mIFByb3hpZXMgY3JlYXRlZCBieSB0cy1taXhlcicpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF8sIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2V0SW5ncmVkaWVudFdpdGhQcm9wKHByb3AsIGluZ3JlZGllbnRzKSB8fCB7fSwgcHJvcCk7XG4gICAgfSxcbiAgICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVmaW5lIG5ldyBwcm9wZXJ0aWVzIG9uIFByb3hpZXMgY3JlYXRlZCBieSB0cy1taXhlcicpO1xuICAgIH0sXG4gICAgaGFzKF8sIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGdldEluZ3JlZGllbnRXaXRoUHJvcChwcm9wLCBpbmdyZWRpZW50cykgIT09IHVuZGVmaW5lZCB8fCBwcm90b3R5cGVbcHJvcF0gIT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGdldChfLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiAoZ2V0SW5ncmVkaWVudFdpdGhQcm9wKHByb3AsIGluZ3JlZGllbnRzKSB8fCBwcm90b3R5cGUpW3Byb3BdO1xuICAgIH0sXG4gICAgc2V0KF8sIHByb3AsIHZhbCkge1xuICAgICAgICBjb25zdCBpbmdyZWRpZW50V2l0aFByb3AgPSBnZXRJbmdyZWRpZW50V2l0aFByb3AocHJvcCwgaW5ncmVkaWVudHMpO1xuICAgICAgICBpZiAoaW5ncmVkaWVudFdpdGhQcm9wID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbmV3IHByb3BlcnRpZXMgb24gUHJveGllcyBjcmVhdGVkIGJ5IHRzLW1peGVyJyk7XG4gICAgICAgIGluZ3JlZGllbnRXaXRoUHJvcFtwcm9wXSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVsZXRlIHByb3BlcnRpZXMgb24gUHJveGllcyBjcmVhdGVkIGJ5IHRzLW1peGVyJyk7XG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgICByZXR1cm4gaW5ncmVkaWVudHNcbiAgICAgICAgICAgIC5tYXAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpXG4gICAgICAgICAgICAucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBjdXJyLmNvbmNhdChwcmV2LmZpbHRlcihrZXkgPT4gY3Vyci5pbmRleE9mKGtleSkgPCAwKSkpO1xuICAgIH0sXG59KTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBwcm94eS1wcm90b3R5cGUgb2JqZWN0IHRoYXQgaXMgYSBcInNvZnRcIiBtaXh0dXJlIG9mIHRoZSBnaXZlbiBwcm90b3R5cGVzLiAgVGhlIG1peGluZyBpcyBhY2hpZXZlZCBieVxuICogcHJveHlpbmcgYWxsIHByb3BlcnR5IGFjY2VzcyB0byB0aGUgaW5ncmVkaWVudHMuICBUaGlzIGlzIG5vdCBFUzUgY29tcGF0aWJsZSBhbmQgbGVzcyBwZXJmb3JtYW50LiAgSG93ZXZlciwgYW55XG4gKiBjaGFuZ2VzIG1hZGUgdG8gdGhlIHNvdXJjZSBwcm90b3R5cGVzIHdpbGwgYmUgcmVmbGVjdGVkIGluIHRoZSBwcm94eS1wcm90b3R5cGUsIHdoaWNoIG1heSBiZSBkZXNpcmFibGUuXG4gKi9cbmNvbnN0IHNvZnRNaXhQcm90b3MgPSAoaW5ncmVkaWVudHMsIGNvbnN0cnVjdG9yKSA9PiBwcm94eU1peChbLi4uaW5ncmVkaWVudHMsIHsgY29uc3RydWN0b3IgfV0pO1xuXG5jb25zdCBzZXR0aW5ncyA9IHtcbiAgICBpbml0RnVuY3Rpb246IG51bGwsXG4gICAgc3RhdGljc1N0cmF0ZWd5OiAnY29weScsXG4gICAgcHJvdG90eXBlU3RyYXRlZ3k6ICdjb3B5JyxcbiAgICBkZWNvcmF0b3JJbmhlcml0YW5jZTogJ2RlZXAnLFxufTtcblxuLy8gS2VlcHMgdHJhY2sgb2YgY29uc3RpdHVlbnQgY2xhc3NlcyBmb3IgZXZlcnkgbWl4aW4gY2xhc3MgY3JlYXRlZCBieSB0cy1taXhlci5cbmNvbnN0IG1peGlucyA9IG5ldyBNYXAoKTtcbmNvbnN0IGdldE1peGluc0ZvckNsYXNzID0gKGNsYXp6KSA9PiBtaXhpbnMuZ2V0KGNsYXp6KTtcbmNvbnN0IHJlZ2lzdGVyTWl4aW5zID0gKG1peGVkQ2xhc3MsIGNvbnN0aXR1ZW50cykgPT4gbWl4aW5zLnNldChtaXhlZENsYXNzLCBjb25zdGl0dWVudHMpO1xuY29uc3QgaGFzTWl4aW4gPSAoaW5zdGFuY2UsIG1peGluKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgbWl4aW4pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gaW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgZnJvbnRpZXIgPSBuZXcgU2V0KCk7XG4gICAgZnJvbnRpZXIuYWRkKGNvbnN0cnVjdG9yKTtcbiAgICB3aGlsZSAoZnJvbnRpZXIuc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZyb250aWVyIGhhcyB0aGUgbWl4aW4gd2UncmUgbG9va2luZyBmb3IuICBpZiBub3QsIHdlIGNhbiBzYXkgd2UgdmlzaXRlZCBldmVyeSBpdGVtIGluIHRoZSBmcm9udGllclxuICAgICAgICBpZiAoZnJvbnRpZXIuaGFzKG1peGluKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmcm9udGllci5mb3JFYWNoKGl0ZW0gPT4gdmlzaXRlZC5hZGQoaXRlbSkpO1xuICAgICAgICAvLyBidWlsZCBhIG5ldyBmcm9udGllciBiYXNlZCBvbiB0aGUgYXNzb2NpYXRlZCBtaXhpbiBjbGFzc2VzIGFuZCBwcm90b3R5cGUgY2hhaW5zIG9mIGVhY2ggZnJvbnRpZXIgaXRlbVxuICAgICAgICBjb25zdCBuZXdGcm9udGllciA9IG5ldyBTZXQoKTtcbiAgICAgICAgZnJvbnRpZXIuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1Db25zdGl0dWVudHMgPSAoX2EgPSBtaXhpbnMuZ2V0KGl0ZW0pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm90b0NoYWluKGl0ZW0ucHJvdG90eXBlKS5tYXAocHJvdG8gPT4gcHJvdG8uY29uc3RydWN0b3IpLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IG51bGwpO1xuICAgICAgICAgICAgaWYgKGl0ZW1Db25zdGl0dWVudHMpXG4gICAgICAgICAgICAgICAgaXRlbUNvbnN0aXR1ZW50cy5mb3JFYWNoKGNvbnN0aXR1ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhjb25zdGl0dWVudCkgJiYgIWZyb250aWVyLmhhcyhjb25zdGl0dWVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGcm9udGllci5hZGQoY29uc3RpdHVlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIG5ldyBmcm9udGllciwgbm93IHNlYXJjaCBhZ2FpblxuICAgICAgICBmcm9udGllciA9IG5ld0Zyb250aWVyO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBnZXQgaGVyZSwgd2UgY291bGRuJ3QgZmluZCB0aGUgbWl4aW4gYW55d2hlcmUgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBvciBhc3NvY2lhdGVkIG1peGluIGNsYXNzZXNcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBtZXJnZU9iamVjdHNPZkRlY29yYXRvcnMgPSAobzEsIG8yKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBhbGxLZXlzID0gdW5pcXVlKFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvMSksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG8yKV0pO1xuICAgIGNvbnN0IG1lcmdlZE9iamVjdCA9IHt9O1xuICAgIGZvciAobGV0IGtleSBvZiBhbGxLZXlzKVxuICAgICAgICBtZXJnZWRPYmplY3Rba2V5XSA9IHVuaXF1ZShbLi4uKChfYSA9IG8xID09PSBudWxsIHx8IG8xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvMVtrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSksIC4uLigoX2IgPSBvMiA9PT0gbnVsbCB8fCBvMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbzJba2V5XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pXSk7XG4gICAgcmV0dXJuIG1lcmdlZE9iamVjdDtcbn07XG5jb25zdCBtZXJnZVByb3BlcnR5QW5kTWV0aG9kRGVjb3JhdG9ycyA9IChkMSwgZDIpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuICh7XG4gICAgICAgIHByb3BlcnR5OiBtZXJnZU9iamVjdHNPZkRlY29yYXRvcnMoKF9hID0gZDEgPT09IG51bGwgfHwgZDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQxLnByb3BlcnR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSwgKF9iID0gZDIgPT09IG51bGwgfHwgZDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQyLnByb3BlcnR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSksXG4gICAgICAgIG1ldGhvZDogbWVyZ2VPYmplY3RzT2ZEZWNvcmF0b3JzKChfYyA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5tZXRob2QpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LCAoX2QgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIubWV0aG9kKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7fSksXG4gICAgfSk7XG59O1xuY29uc3QgbWVyZ2VEZWNvcmF0b3JzID0gKGQxLCBkMikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIHJldHVybiAoe1xuICAgICAgICBjbGFzczogdW5pcXVlKFsuLi4oX2EgPSBkMSA9PT0gbnVsbCB8fCBkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDEuY2xhc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCAuLi4oX2IgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIuY2xhc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdXSksXG4gICAgICAgIHN0YXRpYzogbWVyZ2VQcm9wZXJ0eUFuZE1ldGhvZERlY29yYXRvcnMoKF9jID0gZDEgPT09IG51bGwgfHwgZDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQxLnN0YXRpYykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sIChfZCA9IGQyID09PSBudWxsIHx8IGQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMi5zdGF0aWMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9KSxcbiAgICAgICAgaW5zdGFuY2U6IG1lcmdlUHJvcGVydHlBbmRNZXRob2REZWNvcmF0b3JzKChfZSA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5pbnN0YW5jZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDoge30sIChfZiA9IGQyID09PSBudWxsIHx8IGQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMi5pbnN0YW5jZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDoge30pLFxuICAgIH0pO1xufTtcbmNvbnN0IGRlY29yYXRvcnMgPSBuZXcgTWFwKCk7XG5jb25zdCBmaW5kQWxsQ29uc3RpdHVlbnRDbGFzc2VzID0gKC4uLmNsYXNzZXMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBmcm9udGllciA9IG5ldyBTZXQoWy4uLmNsYXNzZXNdKTtcbiAgICB3aGlsZSAoZnJvbnRpZXIuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgY2xhenogb2YgZnJvbnRpZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvQ2hhaW5DbGFzc2VzID0gcHJvdG9DaGFpbihjbGF6ei5wcm90b3R5cGUpLm1hcChwcm90byA9PiBwcm90by5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBjb25zdCBtaXhpbkNsYXNzZXMgPSAoX2EgPSBnZXRNaXhpbnNGb3JDbGFzcyhjbGF6eikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsbHlOZXdDbGFzc2VzID0gWy4uLnByb3RvQ2hhaW5DbGFzc2VzLCAuLi5taXhpbkNsYXNzZXNdO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IHBvdGVudGlhbGx5TmV3Q2xhc3Nlcy5maWx0ZXIoYyA9PiAhYWxsQ2xhc3Nlcy5oYXMoYykpO1xuICAgICAgICAgICAgZm9yIChsZXQgbmV3Q2xhc3Mgb2YgbmV3Q2xhc3NlcylcbiAgICAgICAgICAgICAgICBmcm9udGllci5hZGQobmV3Q2xhc3MpO1xuICAgICAgICAgICAgYWxsQ2xhc3Nlcy5hZGQoY2xhenopO1xuICAgICAgICAgICAgZnJvbnRpZXIuZGVsZXRlKGNsYXp6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWy4uLmFsbENsYXNzZXNdO1xufTtcbmNvbnN0IGRlZXBEZWNvcmF0b3JTZWFyY2ggPSAoLi4uY2xhc3NlcykgPT4ge1xuICAgIGNvbnN0IGRlY29yYXRvcnNGb3JDbGFzc0NoYWluID0gZmluZEFsbENvbnN0aXR1ZW50Q2xhc3NlcyguLi5jbGFzc2VzKVxuICAgICAgICAubWFwKGNsYXp6ID0+IGRlY29yYXRvcnMuZ2V0KGNsYXp6KSlcbiAgICAgICAgLmZpbHRlcihkZWNvcmF0b3JzID0+ICEhZGVjb3JhdG9ycyk7XG4gICAgaWYgKGRlY29yYXRvcnNGb3JDbGFzc0NoYWluLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4ge307XG4gICAgaWYgKGRlY29yYXRvcnNGb3JDbGFzc0NoYWluLmxlbmd0aCA9PSAxKVxuICAgICAgICByZXR1cm4gZGVjb3JhdG9yc0ZvckNsYXNzQ2hhaW5bMF07XG4gICAgcmV0dXJuIGRlY29yYXRvcnNGb3JDbGFzc0NoYWluLnJlZHVjZSgoZDEsIGQyKSA9PiBtZXJnZURlY29yYXRvcnMoZDEsIGQyKSk7XG59O1xuY29uc3QgZGlyZWN0RGVjb3JhdG9yU2VhcmNoID0gKC4uLmNsYXNzZXMpID0+IHtcbiAgICBjb25zdCBjbGFzc0RlY29yYXRvcnMgPSBjbGFzc2VzLm1hcChjbGF6eiA9PiBnZXREZWNvcmF0b3JzRm9yQ2xhc3MoY2xhenopKTtcbiAgICBpZiAoY2xhc3NEZWNvcmF0b3JzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGlmIChjbGFzc0RlY29yYXRvcnMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gY2xhc3NEZWNvcmF0b3JzWzBdO1xuICAgIHJldHVybiBjbGFzc0RlY29yYXRvcnMucmVkdWNlKChkMSwgZDIpID0+IG1lcmdlRGVjb3JhdG9ycyhkMSwgZDIpKTtcbn07XG5jb25zdCBnZXREZWNvcmF0b3JzRm9yQ2xhc3MgPSAoY2xhenopID0+IHtcbiAgICBsZXQgZGVjb3JhdG9yc0ZvckNsYXNzID0gZGVjb3JhdG9ycy5nZXQoY2xhenopO1xuICAgIGlmICghZGVjb3JhdG9yc0ZvckNsYXNzKSB7XG4gICAgICAgIGRlY29yYXRvcnNGb3JDbGFzcyA9IHt9O1xuICAgICAgICBkZWNvcmF0b3JzLnNldChjbGF6eiwgZGVjb3JhdG9yc0ZvckNsYXNzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRvcnNGb3JDbGFzcztcbn07XG5jb25zdCBkZWNvcmF0ZUNsYXNzID0gKGRlY29yYXRvcikgPT4gKChjbGF6eikgPT4ge1xuICAgIGNvbnN0IGRlY29yYXRvcnNGb3JDbGFzcyA9IGdldERlY29yYXRvcnNGb3JDbGFzcyhjbGF6eik7XG4gICAgbGV0IGNsYXNzRGVjb3JhdG9ycyA9IGRlY29yYXRvcnNGb3JDbGFzcy5jbGFzcztcbiAgICBpZiAoIWNsYXNzRGVjb3JhdG9ycykge1xuICAgICAgICBjbGFzc0RlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgZGVjb3JhdG9yc0ZvckNsYXNzLmNsYXNzID0gY2xhc3NEZWNvcmF0b3JzO1xuICAgIH1cbiAgICBjbGFzc0RlY29yYXRvcnMucHVzaChkZWNvcmF0b3IpO1xuICAgIHJldHVybiBkZWNvcmF0b3IoY2xhenopO1xufSk7XG5jb25zdCBkZWNvcmF0ZU1lbWJlciA9IChkZWNvcmF0b3IpID0+ICgob2JqZWN0LCBrZXksIC4uLm90aGVyQXJncykgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGRlY29yYXRvclRhcmdldFR5cGUgPSB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nID8gJ3N0YXRpYycgOiAnaW5zdGFuY2UnO1xuICAgIGNvbnN0IGRlY29yYXRvclR5cGUgPSB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicgPyAnbWV0aG9kJyA6ICdwcm9wZXJ0eSc7XG4gICAgY29uc3QgY2xhenogPSBkZWNvcmF0b3JUYXJnZXRUeXBlID09PSAnc3RhdGljJyA/IG9iamVjdCA6IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yQ2xhc3MgPSBnZXREZWNvcmF0b3JzRm9yQ2xhc3MoY2xhenopO1xuICAgIGNvbnN0IGRlY29yYXRvcnNGb3JUYXJnZXRUeXBlID0gKF9hID0gZGVjb3JhdG9yc0ZvckNsYXNzID09PSBudWxsIHx8IGRlY29yYXRvcnNGb3JDbGFzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb3JhdG9yc0ZvckNsYXNzW2RlY29yYXRvclRhcmdldFR5cGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICBkZWNvcmF0b3JzRm9yQ2xhc3NbZGVjb3JhdG9yVGFyZ2V0VHlwZV0gPSBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZTtcbiAgICBsZXQgZGVjb3JhdG9yc0ZvclR5cGUgPSAoX2IgPSBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZSA9PT0gbnVsbCB8fCBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb3JhdG9yc0ZvclRhcmdldFR5cGVbZGVjb3JhdG9yVHlwZV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgIGRlY29yYXRvcnNGb3JUYXJnZXRUeXBlW2RlY29yYXRvclR5cGVdID0gZGVjb3JhdG9yc0ZvclR5cGU7XG4gICAgbGV0IGRlY29yYXRvcnNGb3JLZXkgPSAoX2MgPSBkZWNvcmF0b3JzRm9yVHlwZSA9PT0gbnVsbCB8fCBkZWNvcmF0b3JzRm9yVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjb3JhdG9yc0ZvclR5cGVba2V5XSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW107XG4gICAgZGVjb3JhdG9yc0ZvclR5cGVba2V5XSA9IGRlY29yYXRvcnNGb3JLZXk7XG4gICAgLy8gQHRzLWlnbm9yZTogYXJyYXkgaXMgdHlwZSBgQVtdIHwgQltdYCBhbmQgaXRlbSBpcyB0eXBlIGBBIHwgQmAsIHNvIHRlY2huaWNhbGx5IGEgdHlwZSBlcnJvciwgYnV0IGl0J3MgZmluZVxuICAgIGRlY29yYXRvcnNGb3JLZXkucHVzaChkZWNvcmF0b3IpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZGVjb3JhdG9yKG9iamVjdCwga2V5LCAuLi5vdGhlckFyZ3MpO1xufSk7XG5jb25zdCBkZWNvcmF0ZSA9IChkZWNvcmF0b3IpID0+ICgoLi4uYXJncykgPT4ge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGRlY29yYXRlQ2xhc3MoZGVjb3JhdG9yKShhcmdzWzBdKTtcbiAgICByZXR1cm4gZGVjb3JhdGVNZW1iZXIoZGVjb3JhdG9yKSguLi5hcmdzKTtcbn0pO1xuXG5mdW5jdGlvbiBNaXhpbiguLi5jb25zdHJ1Y3RvcnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBwcm90b3R5cGVzID0gY29uc3RydWN0b3JzLm1hcChjb25zdHJ1Y3RvciA9PiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgIC8vIEhlcmUgd2UgZ2F0aGVyIHVwIHRoZSBpbml0IGZ1bmN0aW9ucyBvZiB0aGUgaW5ncmVkaWVudCBwcm90b3R5cGVzLCBjb21iaW5lIHRoZW0gaW50byBvbmUgaW5pdCBmdW5jdGlvbiwgYW5kXG4gICAgLy8gYXR0YWNoIGl0IHRvIHRoZSBtaXhlZCBjbGFzcyBwcm90b3R5cGUuICBUaGUgcmVhc29uIHdlIGRvIHRoaXMgaXMgYmVjYXVzZSB3ZSB3YW50IHRoZSBpbml0IGZ1bmN0aW9ucyB0byBtaXhcbiAgICAvLyBzaW1pbGFybHkgdG8gY29uc3RydWN0b3JzIC0tIG5vdCBtZXRob2RzLCB3aGljaCBzaW1wbHkgb3ZlcnJpZGUgZWFjaCBvdGhlci5cbiAgICBjb25zdCBpbml0RnVuY3Rpb25OYW1lID0gc2V0dGluZ3MuaW5pdEZ1bmN0aW9uO1xuICAgIGlmIChpbml0RnVuY3Rpb25OYW1lICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGluaXRGdW5jdGlvbnMgPSBwcm90b3R5cGVzXG4gICAgICAgICAgICAubWFwKHByb3RvID0+IHByb3RvW2luaXRGdW5jdGlvbk5hbWVdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jID0+IHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nKTtcbiAgICAgICAgY29uc3QgY29tYmluZWRJbml0RnVuY3Rpb24gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5pdEZ1bmN0aW9uIG9mIGluaXRGdW5jdGlvbnMpXG4gICAgICAgICAgICAgICAgaW5pdEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBleHRyYVByb3RvID0geyBbaW5pdEZ1bmN0aW9uTmFtZV06IGNvbWJpbmVkSW5pdEZ1bmN0aW9uIH07XG4gICAgICAgIHByb3RvdHlwZXMucHVzaChleHRyYVByb3RvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTWl4ZWRDbGFzcyguLi5hcmdzKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29uc3RydWN0b3Igb2YgY29uc3RydWN0b3JzKVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogcG90ZW50aWFsbHkgYWJzdHJhY3QgY2xhc3NcbiAgICAgICAgICAgIGNvcHlQcm9wcyh0aGlzLCBuZXcgY29uc3RydWN0b3IoLi4uYXJncykpO1xuICAgICAgICBpZiAoaW5pdEZ1bmN0aW9uTmFtZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpc1tpbml0RnVuY3Rpb25OYW1lXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRoaXNbaW5pdEZ1bmN0aW9uTmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIE1peGVkQ2xhc3MucHJvdG90eXBlID0gc2V0dGluZ3MucHJvdG90eXBlU3RyYXRlZ3kgPT09ICdjb3B5J1xuICAgICAgICA/IGhhcmRNaXhQcm90b3MocHJvdG90eXBlcywgTWl4ZWRDbGFzcylcbiAgICAgICAgOiBzb2Z0TWl4UHJvdG9zKHByb3RvdHlwZXMsIE1peGVkQ2xhc3MpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihNaXhlZENsYXNzLCBzZXR0aW5ncy5zdGF0aWNzU3RyYXRlZ3kgPT09ICdjb3B5J1xuICAgICAgICA/IGhhcmRNaXhQcm90b3MoY29uc3RydWN0b3JzLCBudWxsLCBbJ3Byb3RvdHlwZSddKVxuICAgICAgICA6IHByb3h5TWl4KGNvbnN0cnVjdG9ycywgRnVuY3Rpb24ucHJvdG90eXBlKSk7XG4gICAgbGV0IERlY29yYXRlZE1peGVkQ2xhc3MgPSBNaXhlZENsYXNzO1xuICAgIGlmIChzZXR0aW5ncy5kZWNvcmF0b3JJbmhlcml0YW5jZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzRGVjb3JhdG9ycyA9IHNldHRpbmdzLmRlY29yYXRvckluaGVyaXRhbmNlID09PSAnZGVlcCdcbiAgICAgICAgICAgID8gZGVlcERlY29yYXRvclNlYXJjaCguLi5jb25zdHJ1Y3RvcnMpXG4gICAgICAgICAgICA6IGRpcmVjdERlY29yYXRvclNlYXJjaCguLi5jb25zdHJ1Y3RvcnMpO1xuICAgICAgICBmb3IgKGxldCBkZWNvcmF0b3Igb2YgKF9hID0gY2xhc3NEZWNvcmF0b3JzID09PSBudWxsIHx8IGNsYXNzRGVjb3JhdG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xhc3NEZWNvcmF0b3JzLmNsYXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb3JhdG9yKERlY29yYXRlZE1peGVkQ2xhc3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIERlY29yYXRlZE1peGVkQ2xhc3MgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlQcm9wQW5kTWV0aG9kRGVjb3JhdG9ycygoX2IgPSBjbGFzc0RlY29yYXRvcnMgPT09IG51bGwgfHwgY2xhc3NEZWNvcmF0b3JzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGFzc0RlY29yYXRvcnMuc3RhdGljKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSwgRGVjb3JhdGVkTWl4ZWRDbGFzcyk7XG4gICAgICAgIGFwcGx5UHJvcEFuZE1ldGhvZERlY29yYXRvcnMoKF9jID0gY2xhc3NEZWNvcmF0b3JzID09PSBudWxsIHx8IGNsYXNzRGVjb3JhdG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xhc3NEZWNvcmF0b3JzLmluc3RhbmNlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSwgRGVjb3JhdGVkTWl4ZWRDbGFzcy5wcm90b3R5cGUpO1xuICAgIH1cbiAgICByZWdpc3Rlck1peGlucyhEZWNvcmF0ZWRNaXhlZENsYXNzLCBjb25zdHJ1Y3RvcnMpO1xuICAgIHJldHVybiBEZWNvcmF0ZWRNaXhlZENsYXNzO1xufVxuY29uc3QgYXBwbHlQcm9wQW5kTWV0aG9kRGVjb3JhdG9ycyA9IChwcm9wQW5kTWV0aG9kRGVjb3JhdG9ycywgdGFyZ2V0KSA9PiB7XG4gICAgY29uc3QgcHJvcERlY29yYXRvcnMgPSBwcm9wQW5kTWV0aG9kRGVjb3JhdG9ycy5wcm9wZXJ0eTtcbiAgICBjb25zdCBtZXRob2REZWNvcmF0b3JzID0gcHJvcEFuZE1ldGhvZERlY29yYXRvcnMubWV0aG9kO1xuICAgIGlmIChwcm9wRGVjb3JhdG9ycylcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHByb3BEZWNvcmF0b3JzKVxuICAgICAgICAgICAgZm9yIChsZXQgZGVjb3JhdG9yIG9mIHByb3BEZWNvcmF0b3JzW2tleV0pXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5KTtcbiAgICBpZiAobWV0aG9kRGVjb3JhdG9ycylcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG1ldGhvZERlY29yYXRvcnMpXG4gICAgICAgICAgICBmb3IgKGxldCBkZWNvcmF0b3Igb2YgbWV0aG9kRGVjb3JhdG9yc1trZXldKVxuICAgICAgICAgICAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkpO1xufTtcbi8qKlxuICogQSBkZWNvcmF0b3IgdmVyc2lvbiBvZiB0aGUgYE1peGluYCBmdW5jdGlvbi4gIFlvdSdsbCB3YW50IHRvIHVzZSB0aGlzIGluc3RlYWQgb2YgYE1peGluYCBmb3IgbWl4aW5nIGdlbmVyaWMgY2xhc3Nlcy5cbiAqL1xuY29uc3QgbWl4ID0gKC4uLmluZ3JlZGllbnRzKSA9PiBkZWNvcmF0ZWRDbGFzcyA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG1peGVkQ2xhc3MgPSBNaXhpbiguLi5pbmdyZWRpZW50cy5jb25jYXQoW2RlY29yYXRlZENsYXNzXSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtaXhlZENsYXNzLCAnbmFtZScsIHtcbiAgICAgICAgdmFsdWU6IGRlY29yYXRlZENsYXNzLm5hbWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgICByZXR1cm4gbWl4ZWRDbGFzcztcbn07XG5cbmV4cG9ydCB7IE1peGluLCBkZWNvcmF0ZSwgaGFzTWl4aW4sIG1peCwgc2V0dGluZ3MgfTtcbiJdLCJuYW1lcyI6WyJjb3B5UHJvcHMiLCJkZXN0Iiwic3JjIiwiZXhjbHVkZSIsInByb3BzIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsInByb3AiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG9DaGFpbiIsIm9iaiIsImN1cnJlbnRDaGFpbiIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJuZWFyZXN0Q29tbW9uUHJvdG8iLCJvYmpzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiY29tbW9uUHJvdG8iLCJwcm90b0NoYWlucyIsIm1hcCIsImV2ZXJ5IiwicHJvdG9zIiwicG9wIiwicG90ZW50aWFsQ29tbW9uUHJvdG8iLCJoYXJkTWl4UHJvdG9zIiwiaW5ncmVkaWVudHMiLCJjb25zdHJ1Y3RvciIsIl9hIiwiYmFzZSIsInByb3RvdHlwZSIsIm1peGVkUHJvdG8iLCJjcmVhdGUiLCJ2aXNpdGVkUHJvdG9zIiwiaSIsIm5ld1Byb3RvIiwiaW5kZXhPZiIsInB1c2giLCJ1bmlxdWUiLCJhcnIiLCJmaWx0ZXIiLCJlIiwiZ2V0SW5ncmVkaWVudFdpdGhQcm9wIiwiaW5ncmVkaWVudCIsInByb3RvRGVwdGgiLCJwcm90b3NBcmVMZWZ0VG9TZWFyY2giLCJzZWFyY2hUYXJnZXQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwcm94eU1peCIsIlByb3h5Iiwic2V0UHJvdG90eXBlT2YiLCJFcnJvciIsIl8iLCJkZWZpbmVQcm9wZXJ0eSIsImhhcyIsImdldCIsInNldCIsInZhbCIsImluZ3JlZGllbnRXaXRoUHJvcCIsImRlbGV0ZVByb3BlcnR5Iiwib3duS2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyciIsImNvbmNhdCIsImtleSIsInNvZnRNaXhQcm90b3MiLCJzZXR0aW5ncyIsImluaXRGdW5jdGlvbiIsInN0YXRpY3NTdHJhdGVneSIsInByb3RvdHlwZVN0cmF0ZWd5IiwiZGVjb3JhdG9ySW5oZXJpdGFuY2UiLCJtaXhpbnMiLCJNYXAiLCJnZXRNaXhpbnNGb3JDbGFzcyIsImNsYXp6IiwicmVnaXN0ZXJNaXhpbnMiLCJtaXhlZENsYXNzIiwiY29uc3RpdHVlbnRzIiwiaGFzTWl4aW4iLCJpbnN0YW5jZSIsIm1peGluIiwidmlzaXRlZCIsIlNldCIsImZyb250aWVyIiwiYWRkIiwic2l6ZSIsImZvckVhY2giLCJpdGVtIiwibmV3RnJvbnRpZXIiLCJpdGVtQ29uc3RpdHVlbnRzIiwiY29uc3RpdHVlbnQiLCJtZXJnZU9iamVjdHNPZkRlY29yYXRvcnMiLCJvMSIsIm8yIiwiX2IiLCJhbGxLZXlzIiwibWVyZ2VkT2JqZWN0IiwibWVyZ2VQcm9wZXJ0eUFuZE1ldGhvZERlY29yYXRvcnMiLCJkMSIsImQyIiwiX2MiLCJfZCIsInByb3BlcnR5IiwibWV0aG9kIiwibWVyZ2VEZWNvcmF0b3JzIiwiX2UiLCJfZiIsImNsYXNzIiwic3RhdGljIiwiZGVjb3JhdG9ycyIsImZpbmRBbGxDb25zdGl0dWVudENsYXNzZXMiLCJjbGFzc2VzIiwiYWxsQ2xhc3NlcyIsInByb3RvQ2hhaW5DbGFzc2VzIiwibWl4aW5DbGFzc2VzIiwicG90ZW50aWFsbHlOZXdDbGFzc2VzIiwibmV3Q2xhc3NlcyIsImMiLCJuZXdDbGFzcyIsImRlbGV0ZSIsImRlZXBEZWNvcmF0b3JTZWFyY2giLCJkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbiIsImRpcmVjdERlY29yYXRvclNlYXJjaCIsImNsYXNzRGVjb3JhdG9ycyIsImdldERlY29yYXRvcnNGb3JDbGFzcyIsImRlY29yYXRvcnNGb3JDbGFzcyIsImRlY29yYXRlQ2xhc3MiLCJkZWNvcmF0b3IiLCJkZWNvcmF0ZU1lbWJlciIsIm9iamVjdCIsIm90aGVyQXJncyIsImRlY29yYXRvclRhcmdldFR5cGUiLCJkZWNvcmF0b3JUeXBlIiwiZGVjb3JhdG9yc0ZvclRhcmdldFR5cGUiLCJkZWNvcmF0b3JzRm9yVHlwZSIsImRlY29yYXRvcnNGb3JLZXkiLCJkZWNvcmF0ZSIsImFyZ3MiLCJNaXhpbiIsImNvbnN0cnVjdG9ycyIsInByb3RvdHlwZXMiLCJpbml0RnVuY3Rpb25OYW1lIiwiaW5pdEZ1bmN0aW9ucyIsImZ1bmMiLCJjb21iaW5lZEluaXRGdW5jdGlvbiIsImFwcGx5IiwiZXh0cmFQcm90byIsIk1peGVkQ2xhc3MiLCJGdW5jdGlvbiIsIkRlY29yYXRlZE1peGVkQ2xhc3MiLCJyZXN1bHQiLCJhcHBseVByb3BBbmRNZXRob2REZWNvcmF0b3JzIiwicHJvcEFuZE1ldGhvZERlY29yYXRvcnMiLCJ0YXJnZXQiLCJwcm9wRGVjb3JhdG9ycyIsIm1ldGhvZERlY29yYXRvcnMiLCJtaXgiLCJkZWNvcmF0ZWRDbGFzcyIsInZhbHVlIiwibmFtZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ts-mixer/dist/esm/index.js\n");

/***/ })

};
;