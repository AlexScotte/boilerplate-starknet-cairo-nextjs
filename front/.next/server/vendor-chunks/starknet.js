"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/starknet";
exports.ids = ["vendor-chunks/starknet"];
exports.modules = {

/***/ "(ssr)/./node_modules/starknet/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/starknet/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   BlockStatus: () => (/* binding */ BlockStatus),\n/* harmony export */   BlockTag: () => (/* binding */ BlockTag),\n/* harmony export */   CairoCustomEnum: () => (/* binding */ CairoCustomEnum),\n/* harmony export */   CairoOption: () => (/* binding */ CairoOption),\n/* harmony export */   CairoOptionVariant: () => (/* binding */ CairoOptionVariant),\n/* harmony export */   CairoResult: () => (/* binding */ CairoResult),\n/* harmony export */   CairoResultVariant: () => (/* binding */ CairoResultVariant),\n/* harmony export */   CairoUint256: () => (/* binding */ CairoUint256),\n/* harmony export */   CairoUint512: () => (/* binding */ CairoUint512),\n/* harmony export */   CallData: () => (/* binding */ CallData),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory),\n/* harmony export */   ContractInterface: () => (/* binding */ ContractInterface),\n/* harmony export */   CustomError: () => (/* binding */ CustomError),\n/* harmony export */   EntryPointType: () => (/* binding */ EntryPointType),\n/* harmony export */   EthSigner: () => (/* binding */ EthSigner),\n/* harmony export */   GatewayError: () => (/* binding */ GatewayError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LibraryError: () => (/* binding */ LibraryError),\n/* harmony export */   Literal: () => (/* binding */ Literal),\n/* harmony export */   Provider: () => (/* binding */ RpcProvider2),\n/* harmony export */   ProviderInterface: () => (/* binding */ ProviderInterface),\n/* harmony export */   RPC: () => (/* binding */ api_exports),\n/* harmony export */   RPC06: () => (/* binding */ rpc_0_6_exports),\n/* harmony export */   RPC07: () => (/* binding */ rpc_0_7_exports),\n/* harmony export */   ReceiptTx: () => (/* binding */ ReceiptTx),\n/* harmony export */   RpcChannel: () => (/* binding */ RpcChannel2),\n/* harmony export */   RpcProvider: () => (/* binding */ RpcProvider2),\n/* harmony export */   SIMULATION_FLAG: () => (/* binding */ SIMULATION_FLAG),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   SignerInterface: () => (/* binding */ SignerInterface),\n/* harmony export */   TransactionExecutionStatus: () => (/* binding */ TransactionExecutionStatus),\n/* harmony export */   TransactionFinalityStatus: () => (/* binding */ TransactionFinalityStatus),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionType: () => (/* binding */ TransactionType),\n/* harmony export */   TypedDataRevision: () => (/* reexport safe */ starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision),\n/* harmony export */   UINT_128_MAX: () => (/* binding */ UINT_128_MAX),\n/* harmony export */   UINT_128_MIN: () => (/* binding */ UINT_128_MIN),\n/* harmony export */   UINT_256_HIGH_MAX: () => (/* binding */ UINT_256_HIGH_MAX),\n/* harmony export */   UINT_256_HIGH_MIN: () => (/* binding */ UINT_256_HIGH_MIN),\n/* harmony export */   UINT_256_LOW_MAX: () => (/* binding */ UINT_256_LOW_MAX),\n/* harmony export */   UINT_256_LOW_MIN: () => (/* binding */ UINT_256_LOW_MIN),\n/* harmony export */   UINT_256_MAX: () => (/* binding */ UINT_256_MAX),\n/* harmony export */   UINT_256_MIN: () => (/* binding */ UINT_256_MIN),\n/* harmony export */   UINT_512_MAX: () => (/* binding */ UINT_512_MAX),\n/* harmony export */   UINT_512_MIN: () => (/* binding */ UINT_512_MIN),\n/* harmony export */   Uint: () => (/* binding */ Uint),\n/* harmony export */   ValidateType: () => (/* binding */ ValidateType),\n/* harmony export */   WalletAccount: () => (/* binding */ WalletAccount),\n/* harmony export */   addAddressPadding: () => (/* binding */ addAddressPadding),\n/* harmony export */   buildUrl: () => (/* binding */ buildUrl),\n/* harmony export */   byteArray: () => (/* binding */ byteArray_exports),\n/* harmony export */   cairo: () => (/* binding */ cairo_exports),\n/* harmony export */   constants: () => (/* binding */ constants_exports),\n/* harmony export */   contractClassResponseToLegacyCompiledContract: () => (/* binding */ contractClassResponseToLegacyCompiledContract),\n/* harmony export */   defaultProvider: () => (/* binding */ defaultProvider),\n/* harmony export */   ec: () => (/* binding */ ec_exports),\n/* harmony export */   encode: () => (/* binding */ encode_exports),\n/* harmony export */   eth: () => (/* binding */ eth_exports),\n/* harmony export */   events: () => (/* binding */ events_exports),\n/* harmony export */   extractContractHashes: () => (/* binding */ extractContractHashes),\n/* harmony export */   fixProto: () => (/* binding */ fixProto),\n/* harmony export */   fixStack: () => (/* binding */ fixStack),\n/* harmony export */   getCalldata: () => (/* binding */ getCalldata),\n/* harmony export */   getChecksumAddress: () => (/* binding */ getChecksumAddress),\n/* harmony export */   hash: () => (/* binding */ hash_exports),\n/* harmony export */   isSierra: () => (/* binding */ isSierra),\n/* harmony export */   isUrl: () => (/* binding */ isUrl),\n/* harmony export */   json: () => (/* binding */ json_exports),\n/* harmony export */   merkle: () => (/* binding */ merkle_exports),\n/* harmony export */   num: () => (/* binding */ num_exports),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   parseCalldataField: () => (/* binding */ parseCalldataField),\n/* harmony export */   parseUDCEvent: () => (/* binding */ parseUDCEvent),\n/* harmony export */   provider: () => (/* binding */ provider_exports),\n/* harmony export */   selector: () => (/* binding */ selector_exports),\n/* harmony export */   shortString: () => (/* binding */ shortString_exports),\n/* harmony export */   splitArgsAndOptions: () => (/* binding */ splitArgsAndOptions),\n/* harmony export */   stark: () => (/* binding */ stark_exports),\n/* harmony export */   starknetId: () => (/* binding */ starknetId_exports),\n/* harmony export */   transaction: () => (/* binding */ transaction_exports),\n/* harmony export */   typedData: () => (/* binding */ typedData_exports),\n/* harmony export */   types: () => (/* binding */ types_exports),\n/* harmony export */   uint256: () => (/* binding */ uint256_exports),\n/* harmony export */   v2hash: () => (/* binding */ v2_exports),\n/* harmony export */   v3hash: () => (/* binding */ v3_exports),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress),\n/* harmony export */   validateChecksumAddress: () => (/* binding */ validateChecksumAddress),\n/* harmony export */   wallet: () => (/* binding */ connect_exports)\n/* harmony export */ });\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet-types-07 */ \"(ssr)/./node_modules/starknet-types-07/dist/esm/index.js\");\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! starknet-types-07 */ \"(ssr)/./node_modules/starknet-types-07/dist/esm/api/nonspec.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! starknet-types-07 */ \"(ssr)/./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _scure_starknet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/@scure/starknet/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var lossless_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lossless-json */ \"(ssr)/./node_modules/lossless-json/lib/esm/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var fetch_cookie__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! fetch-cookie */ \"(ssr)/./node_modules/fetch-cookie/esm/index.js\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! isomorphic-fetch */ \"(ssr)/./node_modules/isomorphic-fetch/fetch-npm-node.js\");\n/* harmony import */ var ts_mixer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ts-mixer */ \"(ssr)/./node_modules/ts-mixer/dist/esm/index.js\");\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! url-join */ \"(ssr)/./node_modules/url-join/lib/url-join.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n  ADDR_BOUND: () => ADDR_BOUND,\n  API_VERSION: () => API_VERSION,\n  BaseUrl: () => BaseUrl,\n  IS_BROWSER: () => IS_BROWSER,\n  MASK_250: () => MASK_250,\n  MAX_STORAGE_ITEM_SIZE: () => MAX_STORAGE_ITEM_SIZE,\n  NetworkName: () => NetworkName,\n  PRIME: () => PRIME,\n  RANGE_FELT: () => RANGE_FELT,\n  RANGE_I128: () => RANGE_I128,\n  RANGE_U128: () => RANGE_U128,\n  RPC_DEFAULT_VERSION: () => RPC_DEFAULT_VERSION,\n  RPC_NODES: () => RPC_NODES,\n  StarknetChainId: () => StarknetChainId,\n  TEXT_TO_FELT_MAX_LEN: () => TEXT_TO_FELT_MAX_LEN,\n  TRANSACTION_VERSION: () => api_exports.ETransactionVersion,\n  TransactionHashPrefix: () => TransactionHashPrefix,\n  UDC: () => UDC,\n  ZERO: () => ZERO,\n  feeMarginPercentage: () => feeMarginPercentage\n});\n\n// src/types/api/index.ts\nvar api_exports = {};\n__export(api_exports, {\n  JRPC: () => jsonrpc_exports,\n  RPCSPEC06: () => rpcspec_0_6_exports,\n  RPCSPEC07: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_0__\n});\n\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n\n// src/types/api/rpcspec_0_6/index.ts\nvar rpcspec_0_6_exports = {};\n__export(rpcspec_0_6_exports, {\n  EBlockTag: () => EBlockTag,\n  EDAMode: () => EDAMode,\n  EDataAvailabilityMode: () => EDataAvailabilityMode,\n  ESimulationFlag: () => ESimulationFlag,\n  ETransactionExecutionStatus: () => ETransactionExecutionStatus,\n  ETransactionFinalityStatus: () => ETransactionFinalityStatus,\n  ETransactionStatus: () => ETransactionStatus,\n  ETransactionType: () => ETransactionType,\n  ETransactionVersion: () => ETransactionVersion,\n  ETransactionVersion2: () => ETransactionVersion2,\n  ETransactionVersion3: () => ETransactionVersion3,\n  Errors: () => errors_exports,\n  SPEC: () => components_exports\n});\n\n// src/types/api/rpcspec_0_6/errors.ts\nvar errors_exports = {};\n\n// src/types/api/rpcspec_0_6/components.ts\nvar components_exports = {};\n\n// src/types/api/rpcspec_0_6/nonspec.ts\nvar ETransactionType = /* @__PURE__ */ ((ETransactionType2) => {\n  ETransactionType2[\"DECLARE\"] = \"DECLARE\";\n  ETransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n  ETransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n  ETransactionType2[\"INVOKE\"] = \"INVOKE\";\n  ETransactionType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n  return ETransactionType2;\n})(ETransactionType || {});\nvar ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2) => {\n  ESimulationFlag2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n  ESimulationFlag2[\"SKIP_FEE_CHARGE\"] = \"SKIP_FEE_CHARGE\";\n  return ESimulationFlag2;\n})(ESimulationFlag || {});\nvar ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2) => {\n  ETransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  ETransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n  ETransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  ETransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return ETransactionStatus2;\n})(ETransactionStatus || {});\nvar ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2) => {\n  ETransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  ETransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return ETransactionFinalityStatus2;\n})(ETransactionFinalityStatus || {});\nvar ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2) => {\n  ETransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  ETransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n  return ETransactionExecutionStatus2;\n})(ETransactionExecutionStatus || {});\nvar EBlockTag = /* @__PURE__ */ ((EBlockTag2) => {\n  EBlockTag2[\"LATEST\"] = \"latest\";\n  EBlockTag2[\"PENDING\"] = \"pending\";\n  return EBlockTag2;\n})(EBlockTag || {});\nvar EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode3) => {\n  EDataAvailabilityMode3[\"L1\"] = \"L1\";\n  EDataAvailabilityMode3[\"L2\"] = \"L2\";\n  return EDataAvailabilityMode3;\n})(EDataAvailabilityMode || {});\nvar EDAMode = /* @__PURE__ */ ((EDAMode4) => {\n  EDAMode4[EDAMode4[\"L1\"] = 0] = \"L1\";\n  EDAMode4[EDAMode4[\"L2\"] = 1] = \"L2\";\n  return EDAMode4;\n})(EDAMode || {});\nvar ETransactionVersion = /* @__PURE__ */ ((ETransactionVersion10) => {\n  ETransactionVersion10[\"V0\"] = \"0x0\";\n  ETransactionVersion10[\"V1\"] = \"0x1\";\n  ETransactionVersion10[\"V2\"] = \"0x2\";\n  ETransactionVersion10[\"V3\"] = \"0x3\";\n  ETransactionVersion10[\"F0\"] = \"0x100000000000000000000000000000000\";\n  ETransactionVersion10[\"F1\"] = \"0x100000000000000000000000000000001\";\n  ETransactionVersion10[\"F2\"] = \"0x100000000000000000000000000000002\";\n  ETransactionVersion10[\"F3\"] = \"0x100000000000000000000000000000003\";\n  return ETransactionVersion10;\n})(ETransactionVersion || {});\nvar ETransactionVersion2 = /* @__PURE__ */ ((ETransactionVersion25) => {\n  ETransactionVersion25[\"V0\"] = \"0x0\";\n  ETransactionVersion25[\"V1\"] = \"0x1\";\n  ETransactionVersion25[\"V2\"] = \"0x2\";\n  ETransactionVersion25[\"F0\"] = \"0x100000000000000000000000000000000\";\n  ETransactionVersion25[\"F1\"] = \"0x100000000000000000000000000000001\";\n  ETransactionVersion25[\"F2\"] = \"0x100000000000000000000000000000002\";\n  return ETransactionVersion25;\n})(ETransactionVersion2 || {});\nvar ETransactionVersion3 = /* @__PURE__ */ ((ETransactionVersion36) => {\n  ETransactionVersion36[\"V3\"] = \"0x3\";\n  ETransactionVersion36[\"F3\"] = \"0x100000000000000000000000000000003\";\n  return ETransactionVersion36;\n})(ETransactionVersion3 || {});\n\n// src/types/api/index.ts\n__reExport(api_exports, starknet_types_07__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n  IS_BROWSER: () => IS_BROWSER,\n  addHexPrefix: () => addHexPrefix,\n  arrayBufferToString: () => arrayBufferToString,\n  atobUniversal: () => atobUniversal,\n  btoaUniversal: () => btoaUniversal,\n  buf2hex: () => buf2hex,\n  calcByteLength: () => calcByteLength,\n  padLeft: () => padLeft,\n  pascalToSnake: () => pascalToSnake,\n  removeHexPrefix: () => removeHexPrefix,\n  sanitizeBytes: () => sanitizeBytes,\n  sanitizeHex: () => sanitizeHex,\n  stringToArrayBuffer: () => stringToArrayBuffer,\n  utf8ToArray: () => utf8ToArray\n});\n\nvar IS_BROWSER = typeof window !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n  return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n  return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n  return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n  return _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n  return _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n  return buffer.reduce((r, x) => r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n  return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n  return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n  const diff = length - str.length;\n  let result = str;\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n  return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n  return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n  const { length } = str;\n  const remainder = length % byteSize;\n  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n  return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n  hex = removeHexPrefix(hex);\n  hex = sanitizeBytes(hex, 2);\n  if (hex) {\n    hex = addHexPrefix(hex);\n  }\n  return hex;\n}\nvar pascalToSnake = (text) => /[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\n\n// src/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar API_VERSION = ZERO;\nvar PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;\nvar MAX_STORAGE_ITEM_SIZE = 256n;\nvar ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\nvar range = (min, max) => ({ min, max });\nvar RANGE_FELT = range(ZERO, PRIME - 1n);\nvar RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);\nvar RANGE_U128 = range(ZERO, 2n ** 128n - 1n);\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2) => {\n  BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n  BaseUrl2[\"SN_GOERLI\"] = \"https://alpha4.starknet.io\";\n  BaseUrl2[\"SN_SEPOLIA\"] = \"https://alpha-sepolia.starknet.io\";\n  return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2) => {\n  NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n  NetworkName2[\"SN_GOERLI\"] = \"SN_GOERLI\";\n  NetworkName2[\"SN_SEPOLIA\"] = \"SN_SEPOLIA\";\n  return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId6) => {\n  StarknetChainId6[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n  StarknetChainId6[\"SN_GOERLI\"] = \"0x534e5f474f45524c49\";\n  StarknetChainId6[\"SN_SEPOLIA\"] = \"0x534e5f5345504f4c4941\";\n  return StarknetChainId6;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2) => {\n  TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n  TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n  TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n  TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n  TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n  return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar feeMarginPercentage = /* @__PURE__ */ ((feeMarginPercentage2) => {\n  feeMarginPercentage2[feeMarginPercentage2[\"L1_BOUND_MAX_AMOUNT\"] = 50] = \"L1_BOUND_MAX_AMOUNT\";\n  feeMarginPercentage2[feeMarginPercentage2[\"L1_BOUND_MAX_PRICE_PER_UNIT\"] = 50] = \"L1_BOUND_MAX_PRICE_PER_UNIT\";\n  feeMarginPercentage2[feeMarginPercentage2[\"MAX_FEE\"] = 50] = \"MAX_FEE\";\n  return feeMarginPercentage2;\n})(feeMarginPercentage || {});\nvar UDC = {\n  ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n  ENTRYPOINT: \"deployContract\"\n};\nvar RPC_DEFAULT_VERSION = \"v0_7\";\nvar RPC_NODES = {\n  SN_GOERLI: [\n    `https://starknet-testnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/goerli-juno/${RPC_DEFAULT_VERSION}`\n  ],\n  SN_MAIN: [\n    `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`\n  ],\n  SN_SEPOLIA: [\n    `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`\n  ]\n};\n\n// src/provider/errors.ts\nfunction fixStack(target, fn = target.constructor) {\n  const { captureStackTrace } = Error;\n  captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n  const { setPrototypeOf } = Object;\n  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n  name;\n  constructor(message) {\n    super(message);\n    Object.defineProperty(this, \"name\", {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true\n    });\n    fixProto(this, new.target.prototype);\n    fixStack(this);\n  }\n};\nvar LibraryError = class extends CustomError {\n};\nvar GatewayError = class extends LibraryError {\n  constructor(message, errorCode) {\n    super(message);\n    this.errorCode = errorCode;\n  }\n};\nvar HttpError = class extends LibraryError {\n  constructor(message, errorCode) {\n    super(message);\n    this.errorCode = errorCode;\n  }\n};\n\n// src/channel/rpc_0_6.ts\nvar rpc_0_6_exports = {};\n__export(rpc_0_6_exports, {\n  RpcChannel: () => RpcChannel\n});\n\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n  BlockStatus: () => BlockStatus,\n  BlockTag: () => BlockTag,\n  EntryPointType: () => EntryPointType,\n  Literal: () => Literal,\n  RPC: () => api_exports,\n  SIMULATION_FLAG: () => SIMULATION_FLAG,\n  TransactionExecutionStatus: () => TransactionExecutionStatus,\n  TransactionFinalityStatus: () => TransactionFinalityStatus,\n  TransactionStatus: () => TransactionStatus,\n  TransactionType: () => TransactionType,\n  TypedDataRevision: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision,\n  Uint: () => Uint,\n  ValidateType: () => ValidateType\n});\n\n// src/types/account.ts\nvar SIMULATION_FLAG = /* @__PURE__ */ ((SIMULATION_FLAG2) => {\n  SIMULATION_FLAG2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n  SIMULATION_FLAG2[\"SKIP_EXECUTE\"] = \"SKIP_EXECUTE\";\n  return SIMULATION_FLAG2;\n})(SIMULATION_FLAG || {});\n\n// src/types/calldata.ts\nvar ValidateType = /* @__PURE__ */ ((ValidateType2) => {\n  ValidateType2[\"DEPLOY\"] = \"DEPLOY\";\n  ValidateType2[\"CALL\"] = \"CALL\";\n  ValidateType2[\"INVOKE\"] = \"INVOKE\";\n  return ValidateType2;\n})(ValidateType || {});\nvar Uint = /* @__PURE__ */ ((Uint2) => {\n  Uint2[\"u8\"] = \"core::integer::u8\";\n  Uint2[\"u16\"] = \"core::integer::u16\";\n  Uint2[\"u32\"] = \"core::integer::u32\";\n  Uint2[\"u64\"] = \"core::integer::u64\";\n  Uint2[\"u128\"] = \"core::integer::u128\";\n  Uint2[\"u256\"] = \"core::integer::u256\";\n  Uint2[\"u512\"] = \"core::integer::u512\";\n  return Uint2;\n})(Uint || {});\nvar Literal = /* @__PURE__ */ ((Literal2) => {\n  Literal2[\"ClassHash\"] = \"core::starknet::class_hash::ClassHash\";\n  Literal2[\"ContractAddress\"] = \"core::starknet::contract_address::ContractAddress\";\n  Literal2[\"Secp256k1Point\"] = \"core::starknet::secp256k1::Secp256k1Point\";\n  return Literal2;\n})(Literal || {});\n\n// src/types/lib/contract/index.ts\nvar EntryPointType = /* @__PURE__ */ ((EntryPointType2) => {\n  EntryPointType2[\"EXTERNAL\"] = \"EXTERNAL\";\n  EntryPointType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n  EntryPointType2[\"CONSTRUCTOR\"] = \"CONSTRUCTOR\";\n  return EntryPointType2;\n})(EntryPointType || {});\n\n// src/types/lib/index.ts\nvar TransactionType = /* @__PURE__ */ ((TransactionType2) => {\n  TransactionType2[\"DECLARE\"] = \"DECLARE\";\n  TransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n  TransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n  TransactionType2[\"INVOKE\"] = \"INVOKE_FUNCTION\";\n  return TransactionType2;\n})(TransactionType || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {\n  TransactionStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n  TransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  TransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  TransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  TransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n  TransactionStatus2[\"REVERTED\"] = \"REVERTED\";\n  return TransactionStatus2;\n})(TransactionStatus || {});\nvar TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2) => {\n  TransactionFinalityStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n  TransactionFinalityStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  TransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  TransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return TransactionFinalityStatus2;\n})(TransactionFinalityStatus || {});\nvar TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2) => {\n  TransactionExecutionStatus2[\"REJECTED\"] = \"REJECTED\";\n  TransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n  TransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  return TransactionExecutionStatus2;\n})(TransactionExecutionStatus || {});\nvar BlockStatus = /* @__PURE__ */ ((BlockStatus2) => {\n  BlockStatus2[\"PENDING\"] = \"PENDING\";\n  BlockStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  BlockStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  BlockStatus2[\"REJECTED\"] = \"REJECTED\";\n  return BlockStatus2;\n})(BlockStatus || {});\nvar BlockTag = /* @__PURE__ */ ((BlockTag2) => {\n  BlockTag2[\"pending\"] = \"pending\";\n  BlockTag2[\"latest\"] = \"latest\";\n  return BlockTag2;\n})(BlockTag || {});\n\n// src/types/typedData.ts\n\n\n// src/utils/assert.ts\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failure\");\n  }\n}\n\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n  addPercent: () => addPercent,\n  assertInRange: () => assertInRange,\n  bigNumberishArrayToDecimalStringArray: () => bigNumberishArrayToDecimalStringArray,\n  bigNumberishArrayToHexadecimalStringArray: () => bigNumberishArrayToHexadecimalStringArray,\n  cleanHex: () => cleanHex,\n  getDecimalString: () => getDecimalString,\n  getHexString: () => getHexString,\n  getHexStringArray: () => getHexStringArray,\n  hexToBytes: () => hexToBytes,\n  hexToDecimalString: () => hexToDecimalString,\n  isBigInt: () => isBigInt,\n  isBoolean: () => isBoolean,\n  isHex: () => isHex,\n  isNumber: () => isNumber,\n  isStringWholeNumber: () => isStringWholeNumber,\n  toBigInt: () => toBigInt,\n  toCairoBool: () => toCairoBool,\n  toHex: () => toHex,\n  toHexString: () => toHexString,\n  toStorageKey: () => toStorageKey\n});\n\nfunction isHex(hex) {\n  return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n  return BigInt(value);\n}\nfunction isBigInt(value) {\n  return typeof value === \"bigint\";\n}\nfunction toHex(number2) {\n  return addHexPrefix(toBigInt(number2).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n  const res = addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n  return res;\n}\nfunction hexToDecimalString(hex) {\n  return BigInt(addHexPrefix(hex)).toString(10);\n}\nvar cleanHex = (hex) => hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n  const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n  const inputBigInt = BigInt(input);\n  const lowerBoundBigInt = BigInt(lowerBound);\n  const upperBoundBigInt = BigInt(upperBound);\n  assert(\n    inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,\n    `Message not signable, ${messageSuffix}.`\n  );\n}\nfunction bigNumberishArrayToDecimalStringArray(rawCalldata) {\n  return rawCalldata.map((x) => toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(rawCalldata) {\n  return rawCalldata.map((x) => toHex(x));\n}\nvar isStringWholeNumber = (value) => /^\\d+$/.test(value);\nfunction getDecimalString(value) {\n  if (isHex(value)) {\n    return hexToDecimalString(value);\n  }\n  if (isStringWholeNumber(value)) {\n    return value;\n  }\n  throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexString(value) {\n  if (isHex(value)) {\n    return value;\n  }\n  if (isStringWholeNumber(value)) {\n    return toHexString(value);\n  }\n  throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexStringArray(value) {\n  return value.map((el) => getHexString(el));\n}\nvar toCairoBool = (value) => (+value).toString();\nfunction hexToBytes(value) {\n  if (!isHex(value))\n    throw new Error(`${value} need to be a hex-string`);\n  let adaptedValue = removeHexPrefix(value);\n  if (adaptedValue.length % 2 !== 0) {\n    adaptedValue = `0${adaptedValue}`;\n  }\n  return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(adaptedValue);\n}\nfunction addPercent(number2, percent) {\n  const bigIntNum = BigInt(number2);\n  return bigIntNum + bigIntNum * BigInt(percent) / 100n;\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\n\n// src/utils/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n  getSelector: () => getSelector,\n  getSelectorFromName: () => getSelectorFromName,\n  keccakBn: () => keccakBn,\n  starknetKeccak: () => starknetKeccak\n});\n\nfunction keccakBn(value) {\n  const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n  const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n  return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n  return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n  const hash = BigInt(keccakHex(str));\n  return hash & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n  return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n  if (isHex(value)) {\n    return value;\n  }\n  if (isStringWholeNumber(value)) {\n    return toHexString(value);\n  }\n  return getSelectorFromName(value);\n}\n\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n  decodeShortString: () => decodeShortString,\n  encodeShortString: () => encodeShortString,\n  isASCII: () => isASCII,\n  isDecimalString: () => isDecimalString,\n  isLongText: () => isLongText,\n  isShortString: () => isShortString,\n  isShortText: () => isShortText,\n  isString: () => isString,\n  isText: () => isText,\n  splitLongString: () => splitLongString\n});\nfunction isASCII(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n  return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n  return /^[0-9]*$/i.test(str);\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isText(val) {\n  return isString(val) && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val) => isText(val) && isShortString(val);\nvar isLongText = (val) => isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n  const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n  return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n  if (!isASCII(str))\n    throw new Error(`${str} is not an ASCII string`);\n  if (!isShortString(str))\n    throw new Error(`${str} is too long`);\n  return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n  if (!isASCII(str))\n    throw new Error(`${str} is not an ASCII string`);\n  if (isHex(str)) {\n    return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));\n  }\n  if (isDecimalString(str)) {\n    return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n  }\n  throw new Error(`${str} is not Hex or decimal`);\n}\n\n// src/utils/calldata/byteArray.ts\nvar byteArray_exports = {};\n__export(byteArray_exports, {\n  byteArrayFromString: () => byteArrayFromString,\n  stringFromByteArray: () => stringFromByteArray\n});\nfunction stringFromByteArray(myByteArray) {\n  const pending_word = BigInt(myByteArray.pending_word) === 0n ? \"\" : decodeShortString(toHex(myByteArray.pending_word));\n  return myByteArray.data.reduce((cumuledString, encodedString) => {\n    const add = BigInt(encodedString) === 0n ? \"\" : decodeShortString(toHex(encodedString));\n    return cumuledString + add;\n  }, \"\") + pending_word;\n}\nfunction byteArrayFromString(targetString) {\n  const shortStrings = splitLongString(targetString);\n  const remainder = shortStrings[shortStrings.length - 1];\n  const shortStringsEncoded = shortStrings.map(encodeShortString);\n  const [pendingWord, pendingWordLength] = remainder === void 0 || remainder.length === 31 ? [\"0x00\", 0] : [shortStringsEncoded.pop(), remainder.length];\n  return {\n    data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,\n    pending_word: pendingWord,\n    pending_word_len: pendingWordLength\n  };\n}\n\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n  felt: () => felt,\n  getAbiContractVersion: () => getAbiContractVersion,\n  getArrayType: () => getArrayType,\n  isCairo1Abi: () => isCairo1Abi,\n  isCairo1Type: () => isCairo1Type,\n  isLen: () => isLen,\n  isTypeArray: () => isTypeArray,\n  isTypeBool: () => isTypeBool,\n  isTypeByteArray: () => isTypeByteArray,\n  isTypeBytes31: () => isTypeBytes31,\n  isTypeContractAddress: () => isTypeContractAddress,\n  isTypeEnum: () => isTypeEnum,\n  isTypeEthAddress: () => isTypeEthAddress,\n  isTypeFelt: () => isTypeFelt,\n  isTypeLiteral: () => isTypeLiteral,\n  isTypeNamedTuple: () => isTypeNamedTuple,\n  isTypeOption: () => isTypeOption,\n  isTypeResult: () => isTypeResult,\n  isTypeSecp256k1Point: () => isTypeSecp256k1Point,\n  isTypeStruct: () => isTypeStruct,\n  isTypeTuple: () => isTypeTuple,\n  isTypeUint: () => isTypeUint,\n  isTypeUint256: () => isTypeUint256,\n  tuple: () => tuple,\n  uint256: () => uint256,\n  uint512: () => uint512\n});\n\n// src/utils/cairoDataTypes/felt.ts\nfunction CairoFelt(it) {\n  if (isBigInt(it) || Number.isInteger(it)) {\n    return it.toString();\n  }\n  if (isString(it)) {\n    if (isHex(it)) {\n      return BigInt(it).toString();\n    }\n    if (isText(it)) {\n      if (!isShortString(it)) {\n        throw new Error(\n          `${it} is a long string > 31 chars. Please split it into an array of short strings.`\n        );\n      }\n      return BigInt(encodeShortString(it)).toString();\n    }\n    if (isStringWholeNumber(it)) {\n      return it;\n    }\n  }\n  if (isBoolean(it)) {\n    return `${+it}`;\n  }\n  throw new Error(`${it} can't be computed by felt()`);\n}\n\n// src/utils/cairoDataTypes/uint256.ts\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nvar UINT_256_MIN = 0n;\nvar UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_LOW_MIN = 0n;\nvar UINT_256_HIGH_MIN = 0n;\nvar CairoUint256 = class _CairoUint256 {\n  low;\n  high;\n  static abiSelector = \"core::integer::u256\";\n  constructor(...arr) {\n    if (typeof arr[0] === \"object\" && arr.length === 1 && \"low\" in arr[0] && \"high\" in arr[0]) {\n      const props = _CairoUint256.validateProps(arr[0].low, arr[0].high);\n      this.low = props.low;\n      this.high = props.high;\n    } else if (arr.length === 1) {\n      const bigInt = _CairoUint256.validate(arr[0]);\n      this.low = bigInt & UINT_128_MAX;\n      this.high = bigInt >> 128n;\n    } else if (arr.length === 2) {\n      const props = _CairoUint256.validateProps(arr[0], arr[1]);\n      this.low = props.low;\n      this.high = props.high;\n    } else {\n      throw Error(\"Incorrect constructor parameters\");\n    }\n  }\n  /**\n   * Validate if BigNumberish can be represented as Unit256\n   */\n  static validate(bigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_256_MIN)\n      throw Error(\"bigNumberish is smaller than UINT_256_MIN\");\n    if (bigInt > UINT_256_MAX)\n      throw new Error(\"bigNumberish is bigger than UINT_256_MAX\");\n    return bigInt;\n  }\n  /**\n   * Validate if low and high can be represented as Unit256\n   */\n  static validateProps(low, high) {\n    const bigIntLow = BigInt(low);\n    const bigIntHigh = BigInt(high);\n    if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {\n      throw new Error(\"low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX\");\n    }\n    if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {\n      throw new Error(\"high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX\");\n    }\n    return { low: bigIntLow, high: bigIntHigh };\n  }\n  /**\n   * Check if BigNumberish can be represented as Unit256\n   */\n  static is(bigNumberish) {\n    try {\n      _CairoUint256.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType) {\n    return abiType === _CairoUint256.abiSelector;\n  }\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.high << 128n) + this.low;\n  }\n  /**\n   * Return Uint256 structure with HexString props\n   * {low: HexString, high: HexString}\n   */\n  toUint256HexString() {\n    return {\n      low: addHexPrefix(this.low.toString(16)),\n      high: addHexPrefix(this.high.toString(16))\n    };\n  }\n  /**\n   * Return Uint256 structure with DecimalString props\n   * {low: DecString, high: DecString}\n   */\n  toUint256DecimalString() {\n    return {\n      low: this.low.toString(10),\n      high: this.high.toString(10)\n    };\n  }\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [CairoFelt(this.low), CairoFelt(this.high)];\n  }\n};\n\n// src/utils/cairoDataTypes/uint512.ts\nvar UINT_512_MAX = (1n << 512n) - 1n;\nvar UINT_512_MIN = 0n;\nvar UINT_128_MIN = 0n;\nvar CairoUint512 = class _CairoUint512 {\n  limb0;\n  limb1;\n  limb2;\n  limb3;\n  static abiSelector = \"core::integer::u512\";\n  constructor(...arr) {\n    if (typeof arr[0] === \"object\" && arr.length === 1 && \"limb0\" in arr[0] && \"limb1\" in arr[0] && \"limb2\" in arr[0] && \"limb3\" in arr[0]) {\n      const props = _CairoUint512.validateProps(\n        arr[0].limb0,\n        arr[0].limb1,\n        arr[0].limb2,\n        arr[0].limb3\n      );\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else if (arr.length === 1) {\n      const bigInt = _CairoUint512.validate(arr[0]);\n      this.limb0 = bigInt & UINT_128_MAX;\n      this.limb1 = (bigInt & UINT_128_MAX << 128n) >> 128n;\n      this.limb2 = (bigInt & UINT_128_MAX << 256n) >> 256n;\n      this.limb3 = bigInt >> 384n;\n    } else if (arr.length === 4) {\n      const props = _CairoUint512.validateProps(arr[0], arr[1], arr[2], arr[3]);\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else {\n      throw Error(\"Incorrect Uint512 constructor parameters\");\n    }\n  }\n  /**\n   * Validate if BigNumberish can be represented as Uint512\n   */\n  static validate(bigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_512_MIN)\n      throw Error(\"bigNumberish is smaller than UINT_512_MIN.\");\n    if (bigInt > UINT_512_MAX)\n      throw Error(\"bigNumberish is bigger than UINT_512_MAX.\");\n    return bigInt;\n  }\n  /**\n   * Validate if limbs can be represented as Uint512\n   */\n  static validateProps(limb0, limb1, limb2, limb3) {\n    const l0 = BigInt(limb0);\n    const l1 = BigInt(limb1);\n    const l2 = BigInt(limb2);\n    const l3 = BigInt(limb3);\n    [l0, l1, l2, l3].forEach((value, index) => {\n      if (value < UINT_128_MIN || value > UINT_128_MAX) {\n        throw Error(`limb${index} is not in the range of a u128 number`);\n      }\n    });\n    return { limb0: l0, limb1: l1, limb2: l2, limb3: l3 };\n  }\n  /**\n   * Check if BigNumberish can be represented as Uint512\n   */\n  static is(bigNumberish) {\n    try {\n      _CairoUint512.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType) {\n    return abiType === _CairoUint512.abiSelector;\n  }\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;\n  }\n  /**\n   * Return Uint512 structure with HexString props\n   * limbx: HexString\n   */\n  toUint512HexString() {\n    return {\n      limb0: addHexPrefix(this.limb0.toString(16)),\n      limb1: addHexPrefix(this.limb1.toString(16)),\n      limb2: addHexPrefix(this.limb2.toString(16)),\n      limb3: addHexPrefix(this.limb3.toString(16))\n    };\n  }\n  /**\n   * Return Uint512 structure with DecimalString props\n   * limbx DecString\n   */\n  toUint512DecimalString() {\n    return {\n      limb0: this.limb0.toString(10),\n      limb1: this.limb1.toString(10),\n      limb2: this.limb2.toString(10),\n      limb3: this.limb3.toString(10)\n    };\n  }\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [\n      CairoFelt(this.limb0),\n      CairoFelt(this.limb1),\n      CairoFelt(this.limb2),\n      CairoFelt(this.limb3)\n    ];\n  }\n};\n\n// src/utils/calldata/cairo.ts\nvar isLen = (name) => /_len$/.test(name);\nvar isTypeFelt = (type) => type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type) => /\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type) => /^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type) => /\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs) => type in structs;\nvar isTypeEnum = (type, enums) => type in enums;\nvar isTypeOption = (type) => type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type) => type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type) => Object.values(Uint).includes(type);\nvar isTypeUint256 = (type) => CairoUint256.isAbiType(type);\nvar isTypeLiteral = (type) => Object.values(Literal).includes(type);\nvar isTypeBool = (type) => type === \"core::bool\";\nvar isTypeContractAddress = (type) => type === \"core::starknet::contract_address::ContractAddress\";\nvar isTypeEthAddress = (type) => type === \"core::starknet::eth_address::EthAddress\";\nvar isTypeBytes31 = (type) => type === \"core::bytes_31::bytes31\";\nvar isTypeByteArray = (type) => type === \"core::byte_array::ByteArray\";\nvar isTypeSecp256k1Point = (type) => type === \"core::starknet::secp256k1::Secp256k1Point\";\nvar isCairo1Type = (type) => type.includes(\"::\");\nvar getArrayType = (type) => {\n  if (isCairo1Type(type)) {\n    return type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\"));\n  }\n  return type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n  const { cairo } = getAbiContractVersion(abi);\n  if (cairo === void 0) {\n    throw Error(\"Unable to determine Cairo version\");\n  }\n  return cairo === \"1\";\n}\nfunction getAbiContractVersion(abi) {\n  if (abi.find((it) => it.type === \"interface\")) {\n    return { cairo: \"1\", compiler: \"2\" };\n  }\n  const testFunction = abi.find(\n    (it) => it.type === \"function\" && (it.inputs.length || it.outputs.length)\n  );\n  if (!testFunction) {\n    return { cairo: void 0, compiler: void 0 };\n  }\n  const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n  if (isCairo1Type(io[0].type)) {\n    return { cairo: \"1\", compiler: \"1\" };\n  }\n  return { cairo: \"0\", compiler: \"0\" };\n}\nvar uint256 = (it) => {\n  return new CairoUint256(it).toUint256DecimalString();\n};\nvar uint512 = (it) => {\n  return new CairoUint512(it).toUint512DecimalString();\n};\nvar tuple = (...args) => ({ ...args });\nfunction felt(it) {\n  return CairoFelt(it);\n}\n\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n  /**\n   * direct readonly access to variants of the Cairo Custom Enum.\n   * @returns a value of type any\n   * @example\n   * ```typescript\n   * const successValue = myCairoEnum.variant.Success;\n   */\n  variant;\n  /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */\n  constructor(enumContent) {\n    const variantsList = Object.values(enumContent);\n    if (variantsList.length === 0) {\n      throw new Error(\"This Enum must have at least 1 variant\");\n    }\n    const nbActiveVariants = variantsList.filter(\n      (content) => typeof content !== \"undefined\"\n    ).length;\n    if (nbActiveVariants !== 1) {\n      throw new Error(\"This Enum must have exactly one active variant\");\n    }\n    this.variant = enumContent;\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */\n  unwrap() {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== \"undefined\");\n    if (typeof activeVariant === \"undefined\") {\n      return void 0;\n    }\n    return activeVariant[1];\n  }\n  /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */\n  activeVariant() {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== \"undefined\");\n    if (typeof activeVariant === \"undefined\") {\n      return \"\";\n    }\n    return activeVariant[0];\n  }\n};\n\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2) => {\n  CairoOptionVariant2[CairoOptionVariant2[\"Some\"] = 0] = \"Some\";\n  CairoOptionVariant2[CairoOptionVariant2[\"None\"] = 1] = \"None\";\n  return CairoOptionVariant2;\n})(CairoOptionVariant || {});\nvar CairoOption = class {\n  Some;\n  None;\n  constructor(variant, someContent) {\n    if (!(variant in CairoOptionVariant)) {\n      throw new Error(\"Wrong variant : should be CairoOptionVariant.Some or .None.\");\n    }\n    if (variant === 0 /* Some */) {\n      if (typeof someContent === \"undefined\") {\n        throw new Error(\n          'The creation of a Cairo Option with \"Some\" variant needs a content as input.'\n        );\n      }\n      this.Some = someContent;\n      this.None = void 0;\n    } else {\n      this.Some = void 0;\n      this.None = true;\n    }\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */\n  unwrap() {\n    if (this.None) {\n      return void 0;\n    }\n    return this.Some;\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */\n  isSome() {\n    return !(typeof this.Some === \"undefined\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */\n  isNone() {\n    return this.None === true;\n  }\n};\n\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2) => {\n  CairoResultVariant2[CairoResultVariant2[\"Ok\"] = 0] = \"Ok\";\n  CairoResultVariant2[CairoResultVariant2[\"Err\"] = 1] = \"Err\";\n  return CairoResultVariant2;\n})(CairoResultVariant || {});\nvar CairoResult = class {\n  Ok;\n  Err;\n  constructor(variant, resultContent) {\n    if (!(variant in CairoResultVariant)) {\n      throw new Error(\"Wrong variant : should be CairoResultVariant.Ok or .Err.\");\n    }\n    if (variant === 0 /* Ok */) {\n      this.Ok = resultContent;\n      this.Err = void 0;\n    } else {\n      this.Ok = void 0;\n      this.Err = resultContent;\n    }\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */\n  unwrap() {\n    if (typeof this.Ok !== \"undefined\") {\n      return this.Ok;\n    }\n    if (typeof this.Err !== \"undefined\") {\n      return this.Err;\n    }\n    throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */\n  isOk() {\n    return !(typeof this.Ok === \"undefined\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */\n  isErr() {\n    return !(typeof this.Err === \"undefined\");\n  }\n};\n\n// src/utils/calldata/formatter.ts\nvar guard = {\n  isBN: (data, type, key) => {\n    if (!isBigInt(data[key]))\n      throw new Error(\n        `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`\n      );\n  },\n  unknown: (data, type, key) => {\n    throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n  }\n};\nfunction formatter(data, type, sameType) {\n  return Object.entries(data).reduce((acc, [key, value]) => {\n    const elType = sameType ?? type[key];\n    if (!(key in type) && !sameType) {\n      acc[key] = value;\n      return acc;\n    }\n    if (elType === \"string\") {\n      if (Array.isArray(data[key])) {\n        const arrayStr = formatter(\n          data[key],\n          data[key].map((_) => elType)\n        );\n        acc[key] = Object.values(arrayStr).join(\"\");\n        return acc;\n      }\n      guard.isBN(data, type, key);\n      acc[key] = decodeShortString(value);\n      return acc;\n    }\n    if (elType === \"number\") {\n      guard.isBN(data, type, key);\n      acc[key] = Number(value);\n      return acc;\n    }\n    if (typeof elType === \"function\") {\n      acc[key] = elType(value);\n      return acc;\n    }\n    if (Array.isArray(elType)) {\n      const arrayObj = formatter(data[key], elType, elType[0]);\n      acc[key] = Object.values(arrayObj);\n      return acc;\n    }\n    if (typeof elType === \"object\") {\n      acc[key] = formatter(data[key], elType);\n      return acc;\n    }\n    guard.unknown(data, type, key);\n    return acc;\n  }, {});\n}\n\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n  abi;\n  constructor(abi) {\n    this.abi = abi;\n  }\n  /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  methodInputsLength(abiMethod) {\n    return abiMethod.inputs.reduce((acc, input) => !isLen(input.name) ? acc + 1 : acc, 0);\n  }\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  getMethod(name) {\n    return this.abi.find((it) => it.name === name);\n  }\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  getLegacyFormat() {\n    return this.abi;\n  }\n};\n\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n  abi;\n  constructor(abi) {\n    this.abi = abi;\n  }\n  /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  methodInputsLength(abiMethod) {\n    return abiMethod.inputs.length;\n  }\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  getMethod(name) {\n    const intf = this.abi.find((it) => it.type === \"interface\");\n    return intf.items.find((it) => it.name === name);\n  }\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  getLegacyFormat() {\n    return this.abi.flatMap((e) => {\n      if (e.type === \"interface\") {\n        return e.items;\n      }\n      return e;\n    });\n  }\n};\n\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n  const version = getAbiVersion(abi);\n  if (version === 0 || version === 1) {\n    return new AbiParser1(abi);\n  }\n  if (version === 2) {\n    return new AbiParser2(abi);\n  }\n  throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n  if (abi.find((it) => it.type === \"interface\"))\n    return 2;\n  if (isCairo1Abi(abi))\n    return 1;\n  return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n  return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n  const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n  const type = namedTuple.substring(name.length + \":\".length);\n  return { name, type };\n}\nfunction parseSubTuple(s) {\n  if (!s.includes(\"(\"))\n    return { subTuple: [], result: s };\n  const subTuple = [];\n  let result = \"\";\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === \"(\") {\n      let counter = 1;\n      const lBracket = i;\n      i++;\n      while (counter) {\n        if (s[i] === \")\")\n          counter--;\n        if (s[i] === \"(\")\n          counter++;\n        i++;\n      }\n      subTuple.push(s.substring(lBracket, i));\n      result += \" \";\n      i--;\n    } else {\n      result += s[i];\n    }\n    i++;\n  }\n  return {\n    subTuple,\n    result\n  };\n}\nfunction extractCairo0Tuple(type) {\n  const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n  const { subTuple, result } = parseSubTuple(cleanType);\n  let recomposed = result.split(\",\").map((it) => {\n    return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n  });\n  if (isTypeNamedTuple(type)) {\n    recomposed = recomposed.reduce((acc, it) => {\n      return acc.concat(parseNamedTuple(it));\n    }, []);\n  }\n  return recomposed;\n}\nfunction getClosureOffset(input, open, close) {\n  for (let i = 0, counter = 0; i < input.length; i++) {\n    if (input[i] === open) {\n      counter++;\n    } else if (input[i] === close && --counter === 0) {\n      return i;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\nfunction extractCairo1Tuple(type) {\n  const input = type.slice(1, -1);\n  const result = [];\n  let currentIndex = 0;\n  let limitIndex;\n  while (currentIndex < input.length) {\n    switch (true) {\n      case input[currentIndex] === \"(\": {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), \"(\", \")\") + 1;\n        break;\n      }\n      case (input.startsWith(\"core::result::Result::<\", currentIndex) || input.startsWith(\"core::array::Array::<\", currentIndex) || input.startsWith(\"core::option::Option::<\", currentIndex)): {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), \"<\", \">\") + 1;\n        break;\n      }\n      default: {\n        const commaIndex = input.indexOf(\",\", currentIndex);\n        limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;\n      }\n    }\n    result.push(input.slice(currentIndex, limitIndex));\n    currentIndex = limitIndex + 2;\n  }\n  return result;\n}\nfunction extractTupleMemberTypes(type) {\n  if (isCairo1Type(type)) {\n    return extractCairo1Tuple(type);\n  }\n  return extractCairo0Tuple(type);\n}\n\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`\n  );\n}\nfunction errorU512(key) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`\n  );\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n  const orderInput = (unorderedItem, abiType) => {\n    if (isTypeArray(abiType)) {\n      return orderArray(unorderedItem, abiType);\n    }\n    if (isTypeEnum(abiType, enums)) {\n      const abiObj = enums[abiType];\n      return orderEnum(unorderedItem, abiObj);\n    }\n    if (isTypeTuple(abiType)) {\n      return orderTuple(unorderedItem, abiType);\n    }\n    if (isTypeEthAddress(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeByteArray(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeSecp256k1Point(abiType)) {\n      return unorderedItem;\n    }\n    if (CairoUint256.isAbiType(abiType)) {\n      const u256 = unorderedItem;\n      if (typeof u256 !== \"object\") {\n        return u256;\n      }\n      if (!(\"low\" in u256 && \"high\" in u256)) {\n        throw errorU256(abiType);\n      }\n      return { low: u256.low, high: u256.high };\n    }\n    if (CairoUint512.isAbiType(abiType)) {\n      const u512 = unorderedItem;\n      if (typeof u512 !== \"object\") {\n        return u512;\n      }\n      if (![\"limb0\", \"limb1\", \"limb2\", \"limb3\"].every((key) => key in u512)) {\n        throw errorU512(abiType);\n      }\n      return { limb0: u512.limb0, limb1: u512.limb1, limb2: u512.limb2, limb3: u512.limb3 };\n    }\n    if (isTypeStruct(abiType, structs)) {\n      const abiOfStruct = structs[abiType].members;\n      return orderStruct(unorderedItem, abiOfStruct);\n    }\n    return unorderedItem;\n  };\n  const orderStruct = (unorderedObject2, abiObject) => {\n    const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {\n      const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {\n        enumerable: true,\n        value: value ?? unorderedObject2[abiParam.name]\n      });\n      if (unorderedObject2[abiParam.name] === \"undefined\") {\n        if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n          throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n        }\n      }\n      setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  };\n  function orderArray(myArray, abiParam) {\n    const typeInArray = getArrayType(abiParam);\n    if (isString(myArray)) {\n      return myArray;\n    }\n    return myArray.map((myElem) => orderInput(myElem, typeInArray));\n  }\n  function orderTuple(unorderedObject2, abiParam) {\n    const typeList = extractTupleMemberTypes(abiParam);\n    const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index) => {\n      const myObjKeys = Object.keys(unorderedObject2);\n      const setProperty = (value) => Object.defineProperty(orderedObject, index.toString(), {\n        enumerable: true,\n        value: value ?? unorderedObject2[myObjKeys[index]]\n      });\n      const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n      setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  }\n  const orderEnum = (unorderedObject2, abiObject) => {\n    if (isTypeResult(abiObject.name)) {\n      const unorderedResult = unorderedObject2;\n      const resultOkType = abiObject.name.substring(\n        abiObject.name.indexOf(\"<\") + 1,\n        abiObject.name.lastIndexOf(\",\")\n      );\n      const resultErrType = abiObject.name.substring(\n        abiObject.name.indexOf(\",\") + 1,\n        abiObject.name.lastIndexOf(\">\")\n      );\n      if (unorderedResult.isOk()) {\n        return new CairoResult(\n          0 /* Ok */,\n          orderInput(unorderedObject2.unwrap(), resultOkType)\n        );\n      }\n      return new CairoResult(\n        1 /* Err */,\n        orderInput(unorderedObject2.unwrap(), resultErrType)\n      );\n    }\n    if (isTypeOption(abiObject.name)) {\n      const unorderedOption = unorderedObject2;\n      const resultSomeType = abiObject.name.substring(\n        abiObject.name.indexOf(\"<\") + 1,\n        abiObject.name.lastIndexOf(\">\")\n      );\n      if (unorderedOption.isSome()) {\n        return new CairoOption(\n          0 /* Some */,\n          orderInput(unorderedOption.unwrap(), resultSomeType)\n        );\n      }\n      return new CairoOption(1 /* None */, {});\n    }\n    const unorderedCustomEnum = unorderedObject2;\n    const variants = Object.entries(unorderedCustomEnum.variant);\n    const newEntries = variants.map((variant) => {\n      if (typeof variant[1] === \"undefined\") {\n        return variant;\n      }\n      const variantType = abiObject.type.substring(\n        abiObject.type.lastIndexOf(\"<\") + 1,\n        abiObject.type.lastIndexOf(\">\")\n      );\n      if (variantType === \"()\") {\n        return variant;\n      }\n      return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];\n    });\n    return new CairoCustomEnum(Object.fromEntries(newEntries));\n  };\n  const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {\n    const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {\n      enumerable: true,\n      value\n    });\n    if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n      return orderedObject;\n    }\n    setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n    return orderedObject;\n  }, {});\n  return finalOrderedObject;\n}\n\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n  switch (true) {\n    case CairoUint256.isAbiType(type):\n      return new CairoUint256(val).toApiRequest();\n    case CairoUint512.isAbiType(type):\n      return new CairoUint512(val).toApiRequest();\n    case isTypeBytes31(type):\n      return encodeShortString(val.toString());\n    case isTypeSecp256k1Point(type): {\n      const pubKeyETH = removeHexPrefix(toHex(val)).padStart(128, \"0\");\n      const pubKeyETHy = uint256(addHexPrefix(pubKeyETH.slice(-64)));\n      const pubKeyETHx = uint256(addHexPrefix(pubKeyETH.slice(0, -64)));\n      return [\n        felt(pubKeyETHx.low),\n        felt(pubKeyETHx.high),\n        felt(pubKeyETHy.low),\n        felt(pubKeyETHy.high)\n      ];\n    }\n    default:\n      return felt(val);\n  }\n}\nfunction parseTuple(element, typeStr) {\n  const memberTypes = extractTupleMemberTypes(typeStr);\n  const elements = Object.values(element);\n  if (elements.length !== memberTypes.length) {\n    throw Error(\n      `ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`\n    );\n  }\n  return memberTypes.map((it, dx) => {\n    return {\n      element: elements[dx],\n      type: it.type ?? it\n    };\n  });\n}\nfunction parseByteArray(element) {\n  const myByteArray = byteArrayFromString(element);\n  return [\n    myByteArray.data.length.toString(),\n    ...myByteArray.data.map((bn) => bn.toString()),\n    myByteArray.pending_word.toString(),\n    myByteArray.pending_word_len.toString()\n  ];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n  if (element === void 0) {\n    throw Error(`Missing parameter for type ${type}`);\n  }\n  if (Array.isArray(element)) {\n    const result = [];\n    result.push(felt(element.length));\n    const arrayType = getArrayType(type);\n    return element.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n    }, result);\n  }\n  if (structs[type] && structs[type].members.length) {\n    if (CairoUint256.isAbiType(type)) {\n      return new CairoUint256(element).toApiRequest();\n    }\n    if (CairoUint512.isAbiType(type)) {\n      return new CairoUint512(element).toApiRequest();\n    }\n    if (type === \"core::starknet::eth_address::EthAddress\")\n      return parseBaseTypes(type, element);\n    if (type === \"core::byte_array::ByteArray\")\n      return parseByteArray(element);\n    const { members } = structs[type];\n    const subElement = element;\n    return members.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n    }, []);\n  }\n  if (isTypeTuple(type)) {\n    const tupled = parseTuple(element, type);\n    return tupled.reduce((acc, it) => {\n      const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n      return acc.concat(parsedData);\n    }, []);\n  }\n  if (CairoUint256.isAbiType(type)) {\n    return new CairoUint256(element).toApiRequest();\n  }\n  if (CairoUint512.isAbiType(type)) {\n    return new CairoUint512(element).toApiRequest();\n  }\n  if (isTypeEnum(type, enums)) {\n    const { variants } = enums[type];\n    if (isTypeOption(type)) {\n      const myOption = element;\n      if (myOption.isSome()) {\n        const listTypeVariant2 = variants.find((variant) => variant.name === \"Some\");\n        if (typeof listTypeVariant2 === \"undefined\") {\n          throw Error(`Error in abi : Option has no 'Some' variant.`);\n        }\n        const typeVariantSome = listTypeVariant2.type;\n        if (typeVariantSome === \"()\") {\n          return 0 /* Some */.toString();\n        }\n        const parsedParameter2 = parseCalldataValue(\n          myOption.unwrap(),\n          typeVariantSome,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter2)) {\n          return [0 /* Some */.toString(), ...parsedParameter2];\n        }\n        return [0 /* Some */.toString(), parsedParameter2];\n      }\n      return 1 /* None */.toString();\n    }\n    if (isTypeResult(type)) {\n      const myResult = element;\n      if (myResult.isOk()) {\n        const listTypeVariant3 = variants.find((variant) => variant.name === \"Ok\");\n        if (typeof listTypeVariant3 === \"undefined\") {\n          throw Error(`Error in abi : Result has no 'Ok' variant.`);\n        }\n        const typeVariantOk = listTypeVariant3.type;\n        if (typeVariantOk === \"()\") {\n          return 0 /* Ok */.toString();\n        }\n        const parsedParameter3 = parseCalldataValue(\n          myResult.unwrap(),\n          typeVariantOk,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter3)) {\n          return [0 /* Ok */.toString(), ...parsedParameter3];\n        }\n        return [0 /* Ok */.toString(), parsedParameter3];\n      }\n      const listTypeVariant2 = variants.find((variant) => variant.name === \"Err\");\n      if (typeof listTypeVariant2 === \"undefined\") {\n        throw Error(`Error in abi : Result has no 'Err' variant.`);\n      }\n      const typeVariantErr = listTypeVariant2.type;\n      if (typeVariantErr === \"()\") {\n        return 1 /* Err */.toString();\n      }\n      const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n      if (Array.isArray(parsedParameter2)) {\n        return [1 /* Err */.toString(), ...parsedParameter2];\n      }\n      return [1 /* Err */.toString(), parsedParameter2];\n    }\n    const myEnum = element;\n    const activeVariant = myEnum.activeVariant();\n    const listTypeVariant = variants.find((variant) => variant.name === activeVariant);\n    if (typeof listTypeVariant === \"undefined\") {\n      throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n    }\n    const typeActiveVariant = listTypeVariant.type;\n    const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant);\n    if (typeActiveVariant === \"()\") {\n      return numActiveVariant.toString();\n    }\n    const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n    if (Array.isArray(parsedParameter)) {\n      return [numActiveVariant.toString(), ...parsedParameter];\n    }\n    return [numActiveVariant.toString(), parsedParameter];\n  }\n  if (typeof element === \"object\") {\n    throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n  }\n  return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n  const { name, type } = input;\n  let { value } = argsIterator.next();\n  switch (true) {\n    case isTypeArray(type):\n      if (!Array.isArray(value) && !isText(value)) {\n        throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n      }\n      if (isString(value)) {\n        value = splitLongString(value);\n      }\n      return parseCalldataValue(value, input.type, structs, enums);\n    case type === \"core::starknet::eth_address::EthAddress\":\n      return parseBaseTypes(type, value);\n    case (isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type) || CairoUint256.isAbiType(type)):\n      return parseCalldataValue(value, type, structs, enums);\n    case isTypeEnum(type, enums):\n      return parseCalldataValue(\n        value,\n        type,\n        structs,\n        enums\n      );\n    default:\n      return parseBaseTypes(type, value);\n  }\n}\n\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n  let temp;\n  switch (true) {\n    case isTypeBool(type):\n      temp = it.next().value;\n      return Boolean(BigInt(temp));\n    case CairoUint256.isAbiType(type):\n      const low = it.next().value;\n      const high = it.next().value;\n      return new CairoUint256(low, high).toBigInt();\n    case CairoUint512.isAbiType(type):\n      const limb0 = it.next().value;\n      const limb1 = it.next().value;\n      const limb2 = it.next().value;\n      const limb3 = it.next().value;\n      return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n    case type === \"core::starknet::eth_address::EthAddress\":\n      temp = it.next().value;\n      return BigInt(temp);\n    case type === \"core::bytes_31::bytes31\":\n      temp = it.next().value;\n      return decodeShortString(temp);\n    case isTypeSecp256k1Point(type):\n      const xLow = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const xHigh = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const yLow = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const yHigh = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const pubK = BigInt(addHexPrefix(xHigh + xLow + yHigh + yLow));\n      return pubK;\n    default:\n      temp = it.next().value;\n      return BigInt(temp);\n  }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n  if (element.type === \"()\") {\n    return {};\n  }\n  if (CairoUint256.isAbiType(element.type)) {\n    const low = responseIterator.next().value;\n    const high = responseIterator.next().value;\n    return new CairoUint256(low, high).toBigInt();\n  }\n  if (CairoUint512.isAbiType(element.type)) {\n    const limb0 = responseIterator.next().value;\n    const limb1 = responseIterator.next().value;\n    const limb2 = responseIterator.next().value;\n    const limb3 = responseIterator.next().value;\n    return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n  }\n  if (isTypeByteArray(element.type)) {\n    const parsedBytes31Arr = [];\n    const bytes31ArrLen = BigInt(responseIterator.next().value);\n    while (parsedBytes31Arr.length < bytes31ArrLen) {\n      parsedBytes31Arr.push(toHex(responseIterator.next().value));\n    }\n    const pending_word = toHex(responseIterator.next().value);\n    const pending_word_len = BigInt(responseIterator.next().value);\n    const myByteArray = {\n      data: parsedBytes31Arr,\n      pending_word,\n      pending_word_len\n    };\n    return stringFromByteArray(myByteArray);\n  }\n  if (isTypeArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value);\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  if (structs && element.type in structs && structs[element.type]) {\n    if (element.type === \"core::starknet::eth_address::EthAddress\") {\n      return parseBaseTypes2(element.type, responseIterator);\n    }\n    return structs[element.type].members.reduce((acc, el) => {\n      acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {});\n  }\n  if (enums && element.type in enums && enums[element.type]) {\n    const variantNum = Number(responseIterator.next().value);\n    const rawEnum = enums[element.type].variants.reduce((acc, variant, num) => {\n      if (num === variantNum) {\n        acc[variant.name] = parseResponseValue(\n          responseIterator,\n          { name: \"\", type: variant.type },\n          structs,\n          enums\n        );\n        return acc;\n      }\n      acc[variant.name] = void 0;\n      return acc;\n    }, {});\n    if (element.type.startsWith(\"core::option::Option\")) {\n      const content = variantNum === 0 /* Some */ ? rawEnum.Some : void 0;\n      return new CairoOption(variantNum, content);\n    }\n    if (element.type.startsWith(\"core::result::Result\")) {\n      let content;\n      if (variantNum === 0 /* Ok */) {\n        content = rawEnum.Ok;\n      } else {\n        content = rawEnum.Err;\n      }\n      return new CairoResult(variantNum, content);\n    }\n    const customEnum = new CairoCustomEnum(rawEnum);\n    return customEnum;\n  }\n  if (isTypeTuple(element.type)) {\n    const memberTypes = extractTupleMemberTypes(element.type);\n    return memberTypes.reduce((acc, it, idx) => {\n      const name = it?.name ? it.name : idx;\n      const type = it?.type ? it.type : it;\n      const el = { name, type };\n      acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {});\n  }\n  if (isTypeArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value);\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n  const { name, type } = output;\n  let temp;\n  switch (true) {\n    case isLen(name):\n      temp = responseIterator.next().value;\n      return BigInt(temp);\n    case (structs && type in structs || isTypeTuple(type)):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case (enums && isTypeEnum(type, enums)):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case isTypeArray(type):\n      if (isCairo1Type(type)) {\n        return parseResponseValue(responseIterator, output, structs, enums);\n      }\n      const parsedDataArr = [];\n      if (parsedResult && parsedResult[`${name}_len`]) {\n        const arrLen = parsedResult[`${name}_len`];\n        while (parsedDataArr.length < arrLen) {\n          parsedDataArr.push(\n            parseResponseValue(\n              responseIterator,\n              { name, type: output.type.replace(\"*\", \"\") },\n              structs,\n              enums\n            )\n          );\n        }\n      }\n      return parsedDataArr;\n    default:\n      return parseBaseTypes2(type, responseIterator);\n  }\n}\n\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input) => {\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter),\n    `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`\n  );\n  if (isString(parameter) && !isHex(parameter))\n    return;\n  const param = BigInt(parameter.toString(10));\n  assert(\n    // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n  );\n};\nvar validateBytes31 = (parameter, input) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n  assert(\n    parameter.length < 32,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`\n  );\n};\nvar validateByteArray = (parameter, input) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n};\nvar validateUint = (parameter, input) => {\n  if (isNumber(parameter)) {\n    assert(\n      parameter <= Number.MAX_SAFE_INTEGER,\n      `Validation: Parameter is to large to be typed as Number use (BigInt or String)`\n    );\n  }\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter) || typeof parameter === \"object\" && \"low\" in parameter && \"high\" in parameter || typeof parameter === \"object\" && [\"limb0\", \"limb1\", \"limb2\", \"limb3\"].every((key) => key in parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`\n  );\n  let param;\n  switch (input.type) {\n    case \"core::integer::u256\" /* u256 */:\n      param = new CairoUint256(parameter).toBigInt();\n      break;\n    case \"core::integer::u512\" /* u512 */:\n      param = new CairoUint512(parameter).toBigInt();\n      break;\n    default:\n      param = toBigInt(parameter);\n  }\n  switch (input.type) {\n    case \"core::integer::u8\" /* u8 */:\n      assert(\n        param >= 0n && param <= 255n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`\n      );\n      break;\n    case \"core::integer::u16\" /* u16 */:\n      assert(\n        param >= 0n && param <= 65535n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`\n      );\n      break;\n    case \"core::integer::u32\" /* u32 */:\n      assert(\n        param >= 0n && param <= 4294967295n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`\n      );\n      break;\n    case \"core::integer::u64\" /* u64 */:\n      assert(\n        param >= 0n && param <= 2n ** 64n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`\n      );\n      break;\n    case \"core::integer::u128\" /* u128 */:\n      assert(\n        param >= 0n && param <= 2n ** 128n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`\n      );\n      break;\n    case \"core::integer::u256\" /* u256 */:\n      assert(\n        param >= 0n && param <= 2n ** 256n - 1n,\n        `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`\n      );\n      break;\n    case \"core::integer::u512\" /* u512 */:\n      assert(CairoUint512.is(param), `Validate: arg ${input.name} is ${input.type} 0 - 2^512-1`);\n      break;\n    case \"core::starknet::class_hash::ClassHash\" /* ClassHash */:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case \"core::starknet::contract_address::ContractAddress\" /* ContractAddress */:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case \"core::starknet::secp256k1::Secp256k1Point\" /* Secp256k1Point */: {\n      assert(\n        param >= 0n && param <= 2n ** 512n - 1n,\n        `Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`\n      );\n      break;\n    }\n    default:\n      break;\n  }\n};\nvar validateBool = (parameter, input) => {\n  assert(\n    isBoolean(parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`\n  );\n};\nvar validateStruct = (parameter, input, structs) => {\n  if (input.type === \"core::integer::u256\" /* u256 */ || input.type === \"core::integer::u512\" /* u512 */) {\n    validateUint(parameter, input);\n    return;\n  }\n  if (input.type === \"core::starknet::eth_address::EthAddress\") {\n    assert(\n      typeof parameter !== \"object\",\n      `EthAddress type is waiting a BigNumberish. Got ${parameter}`\n    );\n    const param = BigInt(parameter.toString(10));\n    assert(\n      // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n      param >= 0n && param <= 2n ** 160n - 1n,\n      `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`\n    );\n    return;\n  }\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`\n  );\n  structs[input.type].members.forEach(({ name }) => {\n    assert(\n      Object.keys(parameter).includes(name),\n      `Validate: arg ${input.name} should have a property ${name}`\n    );\n  });\n};\nvar validateEnum = (parameter, input) => {\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`\n  );\n  const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n  const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];\n  if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n    return;\n  }\n  if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n    return;\n  }\n  if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n    return;\n  }\n  throw new Error(\n    `Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`\n  );\n};\nvar validateTuple = (parameter, input) => {\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} should be a tuple (defined as object)`\n  );\n};\nvar validateArray = (parameter, input, structs, enums) => {\n  const baseType = getArrayType(input.type);\n  if (isTypeFelt(baseType) && isLongText(parameter)) {\n    return;\n  }\n  assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n  switch (true) {\n    case isTypeFelt(baseType):\n      parameter.forEach((param) => validateFelt(param, input));\n      break;\n    case isTypeTuple(baseType):\n      parameter.forEach((it) => validateTuple(it, { name: input.name, type: baseType }));\n      break;\n    case isTypeArray(baseType):\n      parameter.forEach(\n        (param) => validateArray(param, { name: \"\", type: baseType }, structs, enums)\n      );\n      break;\n    case isTypeStruct(baseType, structs):\n      parameter.forEach(\n        (it) => validateStruct(it, { name: input.name, type: baseType }, structs)\n      );\n      break;\n    case isTypeEnum(baseType, enums):\n      parameter.forEach((it) => validateEnum(it, { name: input.name, type: baseType }));\n      break;\n    case (isTypeUint(baseType) || isTypeLiteral(baseType)):\n      parameter.forEach((param) => validateUint(param, { name: \"\", type: baseType }));\n      break;\n    case isTypeBool(baseType):\n      parameter.forEach((param) => validateBool(param, input));\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n  abiMethod.inputs.reduce((acc, input) => {\n    const parameter = args[acc];\n    switch (true) {\n      case isLen(input.name):\n        return acc;\n      case isTypeFelt(input.type):\n        validateFelt(parameter, input);\n        break;\n      case isTypeBytes31(input.type):\n        validateBytes31(parameter, input);\n        break;\n      case (isTypeUint(input.type) || isTypeLiteral(input.type)):\n        validateUint(parameter, input);\n        break;\n      case isTypeBool(input.type):\n        validateBool(parameter, input);\n        break;\n      case isTypeByteArray(input.type):\n        validateByteArray(parameter, input);\n        break;\n      case isTypeArray(input.type):\n        validateArray(parameter, input, structs, enums);\n        break;\n      case isTypeStruct(input.type, structs):\n        validateStruct(parameter, input, structs);\n        break;\n      case isTypeEnum(input.type, enums):\n        validateEnum(parameter, input);\n        break;\n      case isTypeTuple(input.type):\n        validateTuple(parameter, input);\n        break;\n      default:\n        throw new Error(\n          `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n        );\n    }\n    return acc + 1;\n  }, 0);\n}\n\n// src/utils/calldata/index.ts\nvar CallData = class _CallData {\n  abi;\n  parser;\n  structs;\n  enums;\n  constructor(abi) {\n    this.structs = _CallData.getAbiStruct(abi);\n    this.enums = _CallData.getAbiEnum(abi);\n    this.parser = createAbiParser(abi);\n    this.abi = this.parser.getLegacyFormat();\n  }\n  /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */\n  validate(type, method, args = []) {\n    if (type !== \"DEPLOY\" /* DEPLOY */) {\n      const invocableFunctionNames = this.abi.filter((abi) => {\n        if (abi.type !== \"function\")\n          return false;\n        const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n        return type === \"INVOKE\" /* INVOKE */ ? !isView : isView;\n      }).map((abi) => abi.name);\n      assert(\n        invocableFunctionNames.includes(method),\n        `${type === \"INVOKE\" /* INVOKE */ ? \"invocable\" : \"viewable\"} method not found in abi`\n      );\n    }\n    const abiMethod = this.abi.find(\n      (abi) => type === \"DEPLOY\" /* DEPLOY */ ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\"\n    );\n    if (isNoConstructorValid(method, args, abiMethod)) {\n      return;\n    }\n    const inputsLength = this.parser.methodInputsLength(abiMethod);\n    if (args.length !== inputsLength) {\n      throw Error(\n        `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`\n      );\n    }\n    validateFields(abiMethod, args, this.structs, this.enums);\n  }\n  /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */\n  compile(method, argsCalldata) {\n    const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method);\n    if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n      return [];\n    }\n    let args;\n    if (Array.isArray(argsCalldata)) {\n      args = argsCalldata;\n    } else {\n      const orderedObject = orderPropsByAbi(\n        argsCalldata,\n        abiMethod.inputs,\n        this.structs,\n        this.enums\n      );\n      args = Object.values(orderedObject);\n      validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    const argsIterator = args[Symbol.iterator]();\n    const callArray = abiMethod.inputs.reduce(\n      (acc, input) => isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)),\n      []\n    );\n    Object.defineProperty(callArray, \"__compiled__\", {\n      enumerable: false,\n      writable: false,\n      value: true\n    });\n    return callArray;\n  }\n  /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */\n  static compile(rawArgs) {\n    const createTree = (obj) => {\n      const getEntries = (o, prefix = \".\") => {\n        const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;\n        return Object.entries(oe).flatMap(([k, v]) => {\n          let value = v;\n          if (k === \"entrypoint\")\n            value = getSelectorFromName(value);\n          else if (isLongText(value))\n            value = byteArrayFromString(value);\n          const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n          if (isBigInt(value))\n            return [[`${prefix}${kk}`, felt(value)]];\n          if (Object(value) === value) {\n            const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n            const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];\n            if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n              const myOption = value;\n              const variantNb = myOption.isSome() ? 0 /* Some */ : 1 /* None */;\n              if (myOption.isSome())\n                return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);\n              return [[`${prefix}${kk}`, felt(variantNb)]];\n            }\n            if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n              const myResult = value;\n              const variantNb = myResult.isOk() ? 0 /* Ok */ : 1 /* Err */;\n              return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);\n            }\n            if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n              const myEnum = value;\n              const activeVariant = myEnum.activeVariant();\n              const listVariants = Object.keys(myEnum.variant);\n              const activeVariantNb = listVariants.findIndex(\n                (variant) => variant === activeVariant\n              );\n              if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                return [[`${prefix}${kk}`, felt(activeVariantNb)]];\n              }\n              return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);\n            }\n            return getEntries(value, `${prefix}${kk}.`);\n          }\n          return [[`${prefix}${kk}`, felt(value)]];\n        });\n      };\n      const result = Object.fromEntries(getEntries(obj));\n      return result;\n    };\n    let callTreeArray;\n    if (!Array.isArray(rawArgs)) {\n      const callTree = createTree(rawArgs);\n      callTreeArray = Object.values(callTree);\n    } else {\n      const callObj = { ...rawArgs };\n      const callTree = createTree(callObj);\n      callTreeArray = Object.values(callTree);\n    }\n    Object.defineProperty(callTreeArray, \"__compiled__\", {\n      enumerable: false,\n      writable: false,\n      value: true\n    });\n    return callTreeArray;\n  }\n  /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */\n  parse(method, response) {\n    const { outputs } = this.abi.find((abi) => abi.name === method);\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const parsed = outputs.flat().reduce((acc, output, idx) => {\n      const propName = output.name ?? idx;\n      acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n      if (acc[propName] && acc[`${propName}_len`]) {\n        delete acc[`${propName}_len`];\n      }\n      return acc;\n    }, {});\n    return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n  }\n  /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */\n  format(method, response, format) {\n    const parsed = this.parse(method, response);\n    return formatter(parsed, format);\n  }\n  /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */\n  static getAbiStruct(abi) {\n    return abi.filter((abiEntry) => abiEntry.type === \"struct\").reduce(\n      (acc, abiEntry) => ({\n        ...acc,\n        [abiEntry.name]: abiEntry\n      }),\n      {}\n    );\n  }\n  /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */\n  static getAbiEnum(abi) {\n    const fullEnumList = abi.filter((abiEntry) => abiEntry.type === \"enum\").reduce(\n      (acc, abiEntry) => ({\n        ...acc,\n        [abiEntry.name]: abiEntry\n      }),\n      {}\n    );\n    delete fullEnumList[\"core::bool\"];\n    return fullEnumList;\n  }\n  /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */\n  static toCalldata(rawCalldata = []) {\n    return _CallData.compile(rawCalldata);\n  }\n  /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */\n  static toHex(raw = []) {\n    const calldata = _CallData.compile(raw);\n    return calldata.map((it) => toHex(it));\n  }\n  /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */\n  decodeParameters(typeCairo, response) {\n    const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const decodedArray = typeCairoArray.map(\n      (typeParam) => responseParser(\n        responseIterator,\n        { name: \"\", type: typeParam },\n        this.structs,\n        this.enums\n      )\n    );\n    return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n  }\n};\n\n// src/utils/hash/index.ts\nvar hash_exports = {};\n__export(hash_exports, {\n  calculateContractAddressFromHash: () => calculateContractAddressFromHash,\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash3,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash3,\n  calculateInvokeTransactionHash: () => calculateInvokeTransactionHash2,\n  computeCompiledClassHash: () => computeCompiledClassHash,\n  computeContractClassHash: () => computeContractClassHash,\n  computeHashOnElements: () => computeHashOnElements2,\n  computeLegacyContractClassHash: () => computeLegacyContractClassHash,\n  computePedersenHash: () => computePedersenHash,\n  computePedersenHashOnElements: () => computePedersenHashOnElements,\n  computePoseidonHash: () => computePoseidonHash,\n  computePoseidonHashOnElements: () => computePoseidonHashOnElements,\n  computeSierraContractClassHash: () => computeSierraContractClassHash,\n  formatSpaces: () => formatSpaces,\n  getSelector: () => getSelector,\n  getSelectorFromName: () => getSelectorFromName,\n  hashByteCodeSegments: () => hashByteCodeSegments,\n  keccakBn: () => keccakBn,\n  poseidon: () => _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_5__,\n  starknetKeccak: () => starknetKeccak\n});\n\n\n// src/utils/hash/transactionHash/v2.ts\nvar v2_exports = {};\n__export(v2_exports, {\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash,\n  calculateTransactionHash: () => calculateTransactionHash,\n  calculateTransactionHashCommon: () => calculateTransactionHashCommon,\n  computeHashOnElements: () => computeHashOnElements\n});\n\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n  starkCurve: () => _scure_starknet__WEBPACK_IMPORTED_MODULE_4__,\n  weierstrass: () => _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_6__\n});\n\n\n\n// src/utils/hash/transactionHash/v2.ts\nfunction computeHashOnElements(data) {\n  return [...data, data.length].reduce((x, y) => _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(toBigInt(x), toBigInt(y)), 0).toString();\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n  const calldataHash = computeHashOnElements(calldata);\n  const dataToHash = [\n    txHashPrefix,\n    version,\n    contractAddress,\n    entryPointSelector,\n    calldataHash,\n    maxFee,\n    chainId,\n    ...additionalData\n  ];\n  return computeHashOnElements(dataToHash);\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n  return calculateTransactionHashCommon(\n    \"0x6465636c617265\" /* DECLARE */,\n    version,\n    senderAddress,\n    0,\n    [classHash],\n    maxFee,\n    chainId,\n    [nonce, ...compiledClassHash ? [compiledClassHash] : []]\n  );\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n  const calldata = [classHash, salt, ...constructorCalldata];\n  return calculateTransactionHashCommon(\n    \"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n  return calculateTransactionHashCommon(\n    \"0x696e766f6b65\" /* INVOKE */,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\n\n// src/utils/hash/transactionHash/v3.ts\nvar v3_exports = {};\n__export(v3_exports, {\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash2,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash2,\n  calculateInvokeTransactionHash: () => calculateInvokeTransactionHash,\n  calculateTransactionHashCommon: () => calculateTransactionHashCommon2,\n  hashDAMode: () => hashDAMode,\n  hashFeeField: () => hashFeeField\n});\n\nvar AToBI = (array) => array.map((it) => BigInt(it));\nvar DATA_AVAILABILITY_MODE_BITS = 32n;\nvar MAX_AMOUNT_BITS = 64n;\nvar MAX_PRICE_PER_UNIT_BITS = 128n;\nvar RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;\nvar L1_GAS_NAME = BigInt(encodeShortString(\"L1_GAS\"));\nvar L2_GAS_NAME = BigInt(encodeShortString(\"L2_GAS\"));\nfunction hashDAMode(nonceDAMode, feeDAMode) {\n  return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);\n}\nfunction hashFeeField(tip, bounds) {\n  const L1Bound = (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l1_gas.max_price_per_unit);\n  const L2Bound = (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l2_gas.max_price_per_unit);\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)([BigInt(tip), L1Bound, L2Bound]);\n}\nfunction calculateTransactionHashCommon2(txHashPrefix, version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, additionalData = []) {\n  const feeFieldHash = hashFeeField(tip, resourceBounds);\n  const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);\n  const dataToHash = AToBI([\n    txHashPrefix,\n    version,\n    senderAddress,\n    feeFieldHash,\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(paymasterData)),\n    chainId,\n    nonce,\n    dAModeHash,\n    ...AToBI(additionalData)\n  ]);\n  return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(dataToHash));\n}\nfunction calculateDeployAccountTransactionHash2(contractAddress, classHash, compiledConstructorCalldata, salt, version, chainId, nonce, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */,\n    version,\n    contractAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(compiledConstructorCalldata)), classHash, salt]\n  );\n}\nfunction calculateDeclareTransactionHash2(classHash, compiledClassHash, senderAddress, version, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x6465636c617265\" /* DECLARE */,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    AToBI(paymasterData),\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(accountDeploymentData)), classHash, compiledClassHash]\n  );\n}\nfunction calculateInvokeTransactionHash(senderAddress, version, compiledCalldata, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x696e766f6b65\" /* INVOKE */,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(accountDeploymentData)), (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(compiledCalldata))]\n  );\n}\n\n// src/utils/hash/transactionHash/index.ts\nfunction isV3InvokeTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(\n    args.version\n  );\n}\nfunction calculateInvokeTransactionHash2(args) {\n  if (isV3InvokeTx(args)) {\n    return calculateInvokeTransactionHash(\n      args.senderAddress,\n      args.version,\n      args.compiledCalldata,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateTransactionHash(\n    args.senderAddress,\n    args.version,\n    args.compiledCalldata,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\nfunction isV3DeclareTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(\n    args.version\n  );\n}\nfunction calculateDeclareTransactionHash3(args) {\n  if (isV3DeclareTx(args)) {\n    return calculateDeclareTransactionHash2(\n      args.classHash,\n      args.compiledClassHash,\n      args.senderAddress,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateDeclareTransactionHash(\n    args.classHash,\n    args.senderAddress,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce,\n    args.compiledClassHash\n  );\n}\nfunction isV3DeployAccountTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(\n    args.version\n  );\n}\nfunction calculateDeployAccountTransactionHash3(args) {\n  if (isV3DeployAccountTx(args)) {\n    return calculateDeployAccountTransactionHash2(\n      args.contractAddress,\n      args.classHash,\n      args.compiledConstructorCalldata,\n      args.salt,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateDeployAccountTransactionHash(\n    args.contractAddress,\n    args.classHash,\n    args.constructorCalldata,\n    args.salt,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\n\n// src/utils/hash/classHash.ts\n\n\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n  parse: () => parse2,\n  parseAlwaysAsBig: () => parseAlwaysAsBig,\n  stringify: () => stringify2,\n  stringifyAlwaysAsBig: () => stringifyAlwaysAsBig\n});\n\nvar parseIntAsNumberOrBigInt = (x) => {\n  if (!lossless_json__WEBPACK_IMPORTED_MODULE_7__.isInteger(x))\n    return parseFloat(x);\n  const v = parseInt(x, 10);\n  return Number.isSafeInteger(v) ? v : BigInt(x);\n};\nvar parse2 = (x) => lossless_json__WEBPACK_IMPORTED_MODULE_7__.parse(String(x), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (x) => lossless_json__WEBPACK_IMPORTED_MODULE_7__.parse(String(x), void 0, lossless_json__WEBPACK_IMPORTED_MODULE_7__.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers) => lossless_json__WEBPACK_IMPORTED_MODULE_7__.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n\n// src/utils/hash/classHash.ts\nfunction computePedersenHash(a, b) {\n  return _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(BigInt(a), BigInt(b));\n}\nfunction computePoseidonHash(a, b) {\n  return toHex(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHash(BigInt(a), BigInt(b)));\n}\nfunction computeHashOnElements2(data) {\n  return [...data, data.length].reduce((x, y) => _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(BigInt(x), BigInt(y)), 0).toString();\n}\nvar computePedersenHashOnElements = computeHashOnElements2;\nfunction computePoseidonHashOnElements(data) {\n  return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(data.map((x) => BigInt(x))));\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n  const compiledCalldata = CallData.compile(constructorCalldata);\n  const constructorCalldataHash = computeHashOnElements2(compiledCalldata);\n  const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n  const hash = computeHashOnElements2([\n    CONTRACT_ADDRESS_PREFIX,\n    deployerAddress,\n    salt,\n    classHash,\n    constructorCalldataHash\n  ]);\n  return toHex(BigInt(hash) % ADDR_BOUND);\n}\nfunction nullSkipReplacer(key, value) {\n  if (key === \"attributes\" || key === \"accessible_scopes\") {\n    return Array.isArray(value) && value.length === 0 ? void 0 : value;\n  }\n  if (key === \"debug_info\") {\n    return null;\n  }\n  return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n  let insideQuotes = false;\n  const newString = [];\n  for (const char of json2) {\n    if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n      insideQuotes = !insideQuotes;\n    }\n    if (insideQuotes) {\n      newString.push(char);\n    } else {\n      newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n    }\n  }\n  return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n  const { abi, program } = compiledContract;\n  const contractClass = { abi, program };\n  const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n  return addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  const apiVersion = toHex(API_VERSION);\n  const externalEntryPointsHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])\n  );\n  const l1HandlerEntryPointsHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])\n  );\n  const constructorEntryPointHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])\n  );\n  const builtinsHash = computeHashOnElements2(\n    compiledContract.program.builtins.map((s) => encodeShortString(s))\n  );\n  const hintedClassHash = computeHintedClassHash(compiledContract);\n  const dataHash = computeHashOnElements2(compiledContract.program.data);\n  return computeHashOnElements2([\n    apiVersion,\n    externalEntryPointsHash,\n    l1HandlerEntryPointsHash,\n    constructorEntryPointHash,\n    builtinsHash,\n    hintedClassHash,\n    dataHash\n  ]);\n}\nfunction hashBuiltins(builtins) {\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(\n    builtins.flatMap((it) => {\n      return BigInt(encodeShortString(it));\n    })\n  );\n}\nfunction hashEntryPoint(data) {\n  const base = data.flatMap((it) => {\n    return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];\n  });\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(base);\n}\nfunction hashByteCodeSegments(casm) {\n  const byteCode = casm.bytecode.map((n) => BigInt(n));\n  const bytecodeSegmentLengths = casm.bytecode_segment_lengths ?? [];\n  let segmentStart = 0;\n  const hashLeaves = bytecodeSegmentLengths.flatMap((len) => {\n    const segment = byteCode.slice(segmentStart, segmentStart += len);\n    return [BigInt(len), (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(segment)];\n  });\n  return 1n + (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(hashLeaves);\n}\nfunction computeCompiledClassHash(casm) {\n  const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n  const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n  const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n  const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n  const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n  const bytecode = casm.bytecode_segment_lengths ? hashByteCodeSegments(casm) : (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(casm.bytecode.map((it) => BigInt(it)));\n  return toHex(\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      bytecode\n    ])\n  );\n}\nfunction hashEntryPointSierra(data) {\n  const base = data.flatMap((it) => {\n    return [BigInt(it.selector), BigInt(it.function_idx)];\n  });\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n  const indentString = formatSpaces(stringify2(sierra.abi, null));\n  return BigInt(addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n  const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n  const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n  const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n  const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n  const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n  const abiHash = hashAbi(sierra);\n  const sierraProgram = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(sierra.sierra_program.map((it) => BigInt(it)));\n  return toHex(\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      abiHash,\n      sierraProgram\n    ])\n  );\n}\nfunction computeContractClassHash(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  if (\"sierra_program\" in compiledContract) {\n    return computeSierraContractClassHash(compiledContract);\n  }\n  return computeLegacyContractClassHash(compiledContract);\n}\n\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n  compressProgram: () => compressProgram,\n  decompressProgram: () => decompressProgram,\n  estimateFeeToBounds: () => estimateFeeToBounds,\n  estimatedFeeToMaxFee: () => estimatedFeeToMaxFee,\n  formatSignature: () => formatSignature,\n  intDAM: () => intDAM,\n  makeAddress: () => makeAddress,\n  randomAddress: () => randomAddress,\n  reduceV2: () => reduceV2,\n  signatureToDecimalArray: () => signatureToDecimalArray,\n  signatureToHexArray: () => signatureToHexArray,\n  toFeeVersion: () => toFeeVersion,\n  toTransactionVersion: () => toTransactionVersion,\n  v3Details: () => v3Details\n});\n\n\nfunction compressProgram(jsonProgram) {\n  const stringified = isString(jsonProgram) ? jsonProgram : stringify2(jsonProgram);\n  const compressedProgram = (0,pako__WEBPACK_IMPORTED_MODULE_8__.gzip)(stringified);\n  return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n  if (Array.isArray(base642))\n    return base642;\n  const decompressed = arrayBufferToString((0,pako__WEBPACK_IMPORTED_MODULE_8__.ungzip)(atobUniversal(base642)));\n  return parse2(decompressed);\n}\nfunction randomAddress() {\n  const randomKeyPair = _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.utils.randomPrivateKey();\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n  return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n  if (!sig)\n    throw Error(\"formatSignature: provided signature is undefined\");\n  if (Array.isArray(sig)) {\n    return sig.map((it) => toHex(it));\n  }\n  try {\n    const { r, s } = sig;\n    return [toHex(r), toHex(s)];\n  } catch (e) {\n    throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n  }\n}\nfunction signatureToDecimalArray(sig) {\n  return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n  return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 50 /* MAX_FEE */) {\n  return addPercent(estimatedFee, overhead);\n}\nfunction estimateFeeToBounds(estimate, amountOverhead = 50 /* L1_BOUND_MAX_AMOUNT */, priceOverhead = 50 /* L1_BOUND_MAX_PRICE_PER_UNIT */) {\n  if (isBigInt(estimate)) {\n    return {\n      l2_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" },\n      l1_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" }\n    };\n  }\n  if (typeof estimate.gas_consumed === \"undefined\" || typeof estimate.gas_price === \"undefined\") {\n    throw Error(\"estimateFeeToBounds: estimate is undefined\");\n  }\n  const maxUnits = estimate.data_gas_consumed !== void 0 && estimate.data_gas_price !== void 0 ? toHex(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead)) : toHex(addPercent(estimate.gas_consumed, amountOverhead));\n  const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));\n  return {\n    l2_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" },\n    l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice }\n  };\n}\nfunction intDAM(dam) {\n  if (dam === api_exports.EDataAvailabilityMode.L1)\n    return api_exports.EDAMode.L1;\n  if (dam === api_exports.EDataAvailabilityMode.L2)\n    return api_exports.EDAMode.L2;\n  throw Error(\"EDAM conversion\");\n}\nfunction toTransactionVersion(defaultVersion, providedVersion) {\n  const providedVersion0xs = providedVersion ? toHex(providedVersion) : void 0;\n  const defaultVersion0xs = toHex(defaultVersion);\n  if (providedVersion && !Object.values(api_exports.ETransactionVersion).includes(providedVersion0xs)) {\n    throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);\n  }\n  if (!Object.values(api_exports.ETransactionVersion).includes(defaultVersion0xs)) {\n    throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);\n  }\n  return providedVersion ? providedVersion0xs : defaultVersion0xs;\n}\nfunction toFeeVersion(providedVersion) {\n  if (!providedVersion)\n    return void 0;\n  const version = toHex(providedVersion);\n  if (version === api_exports.ETransactionVersion.V0)\n    return api_exports.ETransactionVersion.F0;\n  if (version === api_exports.ETransactionVersion.V1)\n    return api_exports.ETransactionVersion.F1;\n  if (version === api_exports.ETransactionVersion.V2)\n    return api_exports.ETransactionVersion.F2;\n  if (version === api_exports.ETransactionVersion.V3)\n    return api_exports.ETransactionVersion.F3;\n  throw Error(`toFeeVersion: ${version} is not supported`);\n}\nfunction v3Details(details) {\n  return {\n    tip: details.tip || 0,\n    paymasterData: details.paymasterData || [],\n    accountDeploymentData: details.accountDeploymentData || [],\n    nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,\n    feeDataAvailabilityMode: details.feeDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,\n    resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO)\n  };\n}\nfunction reduceV2(providedVersion) {\n  if (providedVersion === api_exports.ETransactionVersion.F2)\n    return api_exports.ETransactionVersion.F1;\n  if (providedVersion === api_exports.ETransactionVersion.V2)\n    return api_exports.ETransactionVersion.V1;\n  return providedVersion;\n}\n\n// src/utils/contract.ts\nfunction isSierra(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n  const response = { ...payload };\n  if (isSierra(payload.contract)) {\n    if (!payload.compiledClassHash && payload.casm) {\n      response.compiledClassHash = computeCompiledClassHash(payload.casm);\n    }\n    if (!response.compiledClassHash)\n      throw new Error(\n        \"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\"\n      );\n  }\n  response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n  if (!response.classHash)\n    throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n  return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n  if (isSierra(ccr)) {\n    throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n  }\n  const contract = ccr;\n  return { ...contract, program: decompressProgram(contract.program) };\n}\n\n// src/utils/eth.ts\nvar eth_exports = {};\n__export(eth_exports, {\n  ethRandomPrivateKey: () => ethRandomPrivateKey,\n  validateAndParseEthAddress: () => validateAndParseEthAddress\n});\n\nfunction ethRandomPrivateKey() {\n  return sanitizeHex(buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.utils.randomPrivateKey()));\n}\nfunction validateAndParseEthAddress(address) {\n  assertInRange(address, ZERO, 2n ** 160n - 1n, \"Ethereum Address \");\n  const result = addHexPrefix(removeHexPrefix(toHex(address)).padStart(40, \"0\"));\n  assert(result.match(/^(0x)?[0-9a-f]{40}$/), \"Invalid Ethereum Address Format\");\n  return result;\n}\n\n// src/utils/fetchPonyfill.ts\n\n\nvar fetchPonyfill_default = typeof window !== \"undefined\" && window.fetch || // use buildin fetch in browser if available\ntypeof global !== \"undefined\" && (0,fetch_cookie__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(global.fetch) || // use buildin fetch in node, react-native and service worker if available\nisomorphic_fetch__WEBPACK_IMPORTED_MODULE_11__;\n\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n  Block: () => Block,\n  createSierraContractClass: () => createSierraContractClass,\n  formatHash: () => formatHash,\n  getDefaultNodeUrl: () => getDefaultNodeUrl,\n  isPendingBlock: () => isPendingBlock,\n  isPendingStateUpdate: () => isPendingStateUpdate,\n  isPendingTransaction: () => isPendingTransaction,\n  isV3Tx: () => isV3Tx,\n  isVersion: () => isVersion,\n  parseContract: () => parseContract,\n  txIdentifier: () => txIdentifier,\n  validBlockTags: () => validBlockTags,\n  wait: () => wait\n});\nfunction wait(delay) {\n  return new Promise((res) => {\n    setTimeout(res, delay);\n  });\n}\nfunction createSierraContractClass(contract) {\n  const result = { ...contract };\n  delete result.sierra_program_debug_info;\n  result.abi = formatSpaces(stringify2(contract.abi));\n  result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n  result.sierra_program = compressProgram(result.sierra_program);\n  return result;\n}\nfunction parseContract(contract) {\n  const parsedContract = isString(contract) ? parse2(contract) : contract;\n  if (!isSierra(contract)) {\n    return {\n      ...parsedContract,\n      ...\"program\" in parsedContract && { program: compressProgram(parsedContract.program) }\n    };\n  }\n  return createSierraContractClass(parsedContract);\n}\nvar getDefaultNodeUrl = (networkName, mute = false) => {\n  if (!mute) {\n    console.warn(\"Using default public node url, please provide nodeUrl in provider options!\");\n  }\n  const nodes = RPC_NODES[networkName ?? \"SN_SEPOLIA\" /* SN_SEPOLIA */];\n  const randIdx = Math.floor(Math.random() * nodes.length);\n  return nodes[randIdx];\n};\nfunction formatHash(hashValue) {\n  if (isString(hashValue))\n    return hashValue;\n  return toHex(hashValue);\n}\nfunction txIdentifier(txHash, txId) {\n  if (!txHash) {\n    return `transactionId=${JSON.stringify(txId)}`;\n  }\n  const hashString = formatHash(txHash);\n  return `transactionHash=${hashString}`;\n}\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n  hash = null;\n  number = null;\n  tag = null;\n  setIdentifier(__identifier) {\n    if (isString(__identifier)) {\n      if (isDecimalString(__identifier)) {\n        this.number = parseInt(__identifier, 10);\n      } else if (isHex(__identifier)) {\n        this.hash = __identifier;\n      } else if (validBlockTags.includes(__identifier)) {\n        this.tag = __identifier;\n      } else {\n        throw TypeError(`Block identifier unmanaged: ${__identifier}`);\n      }\n    } else if (isBigInt(__identifier)) {\n      this.hash = toHex(__identifier);\n    } else if (isNumber(__identifier)) {\n      this.number = __identifier;\n    } else {\n      this.tag = \"pending\" /* pending */;\n    }\n    if (isNumber(this.number) && this.number < 0) {\n      throw TypeError(`Block number (${this.number}) can't be negative`);\n    }\n  }\n  constructor(_identifier) {\n    this.setIdentifier(_identifier);\n  }\n  // TODO: fix any\n  get queryIdentifier() {\n    if (this.number !== null) {\n      return `blockNumber=${this.number}`;\n    }\n    if (this.hash !== null) {\n      return `blockHash=${this.hash}`;\n    }\n    return `blockNumber=${this.tag}`;\n  }\n  // TODO: fix any\n  get identifier() {\n    if (this.number !== null) {\n      return { block_number: this.number };\n    }\n    if (this.hash !== null) {\n      return { block_hash: this.hash };\n    }\n    return this.tag;\n  }\n  set identifier(_identifier) {\n    this.setIdentifier(_identifier);\n  }\n  valueOf = () => this.number;\n  toString = () => this.hash;\n};\nfunction isV3Tx(details) {\n  const version = details.version ? toHex(details.version) : api_exports.ETransactionVersion.V3;\n  return version === api_exports.ETransactionVersion.V3 || version === api_exports.ETransactionVersion.F3;\n}\nfunction isVersion(version, response) {\n  const [majorS, minorS] = version.split(\".\");\n  const [majorR, minorR] = response.split(\".\");\n  return majorS === majorR && minorS === minorR;\n}\nfunction isPendingBlock(response) {\n  return response.status === \"PENDING\";\n}\nfunction isPendingTransaction(response) {\n  return !(\"block_hash\" in response);\n}\nfunction isPendingStateUpdate(response) {\n  return !(\"block_hash\" in response);\n}\n\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n  buildUDCCall: () => buildUDCCall,\n  fromCallsToExecuteCalldata: () => fromCallsToExecuteCalldata,\n  fromCallsToExecuteCalldataWithNonce: () => fromCallsToExecuteCalldataWithNonce,\n  fromCallsToExecuteCalldata_cairo1: () => fromCallsToExecuteCalldata_cairo1,\n  getExecuteCalldata: () => getExecuteCalldata,\n  getVersionsByType: () => getVersionsByType,\n  transformCallsToMulticallArrays: () => transformCallsToMulticallArrays,\n  transformCallsToMulticallArrays_cairo1: () => transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls) => {\n  const callArray = [];\n  const calldata = [];\n  calls.forEach((call) => {\n    const data = CallData.compile(call.calldata || []);\n    callArray.push({\n      to: toBigInt(call.contractAddress).toString(10),\n      selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n      data_offset: calldata.length.toString(),\n      data_len: data.length.toString()\n    });\n    calldata.push(...data);\n  });\n  return {\n    callArray,\n    calldata: CallData.compile({ calldata })\n  };\n};\nvar fromCallsToExecuteCalldata = (calls) => {\n  const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n  const compiledCalls = CallData.compile({ callArray });\n  return [...compiledCalls, ...calldata];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce) => {\n  return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls) => {\n  const callArray = calls.map((call) => ({\n    to: toBigInt(call.contractAddress).toString(10),\n    selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n    calldata: CallData.compile(call.calldata || [])\n  }));\n  return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls) => {\n  const orderCalls = calls.map((call) => ({\n    contractAddress: call.contractAddress,\n    entrypoint: call.entrypoint,\n    calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n    // RawArgsObject | RawArgsArray type\n  }));\n  return CallData.compile({ orderCalls });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\") => {\n  if (cairoVersion === \"1\") {\n    return fromCallsToExecuteCalldata_cairo1(calls);\n  }\n  return fromCallsToExecuteCalldata(calls);\n};\nfunction buildUDCCall(payload, address) {\n  const params = [].concat(payload).map((it) => {\n    const {\n      classHash,\n      salt,\n      unique = true,\n      constructorCalldata = []\n    } = it;\n    const compiledConstructorCallData = CallData.compile(constructorCalldata);\n    const deploySalt = salt ?? randomAddress();\n    return {\n      call: {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          deploySalt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData\n        ]\n      },\n      address: calculateContractAddressFromHash(\n        unique ? _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(address, deploySalt) : deploySalt,\n        classHash,\n        compiledConstructorCallData,\n        unique ? UDC.ADDRESS : 0\n      )\n    };\n  });\n  return {\n    calls: params.map((it) => it.call),\n    addresses: params.map((it) => it.address)\n  };\n}\nfunction getVersionsByType(versionType) {\n  return versionType === \"fee\" ? {\n    v1: api_exports.ETransactionVersion.F1,\n    v2: api_exports.ETransactionVersion.F2,\n    v3: api_exports.ETransactionVersion.F3\n  } : { v1: api_exports.ETransactionVersion.V1, v2: api_exports.ETransactionVersion.V2, v3: api_exports.ETransactionVersion.V3 };\n}\n\n// src/channel/rpc_0_6.ts\nvar defaultOptions = {\n  headers: { \"Content-Type\": \"application/json\" },\n  blockIdentifier: \"pending\" /* pending */,\n  retries: 200\n};\nvar RpcChannel = class {\n  nodeUrl;\n  headers;\n  retries;\n  requestId;\n  blockIdentifier;\n  chainId;\n  specVersion;\n  waitMode;\n  // behave like web2 rpc and return when tx is processed\n  constructor(optionsOrProvider) {\n    const { nodeUrl, retries, headers, blockIdentifier, chainId, specVersion, waitMode } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n    }\n    this.retries = retries || defaultOptions.retries;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.specVersion = specVersion;\n    this.waitMode = waitMode || false;\n    this.requestId = 0;\n  }\n  setChainId(chainId) {\n    this.chainId = chainId;\n  }\n  fetch(method, params, id = 0) {\n    const rpcRequestBody = {\n      id,\n      jsonrpc: \"2.0\",\n      method,\n      ...params && { params }\n    };\n    return fetchPonyfill_default(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(rpcRequestBody),\n      headers: this.headers\n    });\n  }\n  errorHandler(method, params, rpcError, otherError) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify2(params, null, 2)}\n \n        ${code}: ${message}: ${stringify2(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n  async fetchEndpoint(method, params) {\n    try {\n      const rawResult = await this.fetch(method, params, this.requestId += 1);\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result;\n    } catch (error) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n  async getChainId() {\n    this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n    return this.chainId;\n  }\n  async getSpecVersion() {\n    this.specVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n    return this.specVersion;\n  }\n  getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getNonce\", {\n      contract_address,\n      block_id\n    });\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  getBlockLatestAccepted() {\n    return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  getBlockNumber() {\n    return this.fetchEndpoint(\"starknet_blockNumber\");\n  }\n  getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", { block_id });\n  }\n  getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxs\", { block_id });\n  }\n  getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStateUpdate\", { block_id });\n  }\n  getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_traceBlockTransactions\", { block_id });\n  }\n  getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", { block_id });\n  }\n  getTransactionByHash(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n      transaction_hash\n    });\n  }\n  getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", { block_id, index });\n  }\n  getTransactionReceipt(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionReceipt\", { transaction_hash });\n  }\n  getTransactionTrace(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_traceTransaction\", { transaction_hash });\n  }\n  /**\n   * Get the status of a transaction\n   */\n  getTransactionStatus(transactionHash) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint(\"starknet_getTransactionStatus\", { transaction_hash });\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  simulateTransaction(invocations, {\n    blockIdentifier = this.blockIdentifier,\n    skipValidate = true,\n    skipFeeCharge = true\n  } = {}) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags = [];\n    if (skipValidate)\n      simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge)\n      simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n    return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags\n    });\n  }\n  async waitForTransaction(txHash, options) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? 5e3;\n    const errorStates = options?.errorStates ?? [\n      rpcspec_0_6_exports.ETransactionStatus.REJECTED\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates = options?.successStates ?? [\n      rpcspec_0_6_exports.ETransactionExecutionStatus.SUCCEEDED,\n      rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L2,\n      rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L1\n    ];\n    let txStatus;\n    while (!onchain) {\n      await wait(retryInterval);\n      try {\n        txStatus = await this.getTransactionStatus(transactionHash);\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n        if (!finalityStatus) {\n          const error = new Error(\"waiting for transaction status\");\n          throw error;\n        }\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message);\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n    }\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      await wait(retryInterval);\n    }\n    return txReceipt;\n  }\n  getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStorageAt\", {\n      contract_address,\n      key: parsedKey,\n      block_id\n    });\n  }\n  getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  getClass(classHash, blockIdentifier = this.blockIdentifier) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClass\", {\n      class_hash,\n      block_id\n    });\n  }\n  getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion(\"0.5\", await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE] : []\n      };\n    }\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: invocations.map((it) => this.buildTransaction(it, \"fee\")),\n      block_id,\n      ...flags\n    });\n  }\n  async invoke(functionInvocation, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          compiled_class_hash: compiledClassHash || \"\",\n          version: rpcspec_0_6_exports.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || \"\",\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    } else {\n      throw Error(\"declare unspotted parameters\");\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  callContract(call, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_call\", {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata)\n      },\n      block_id\n    });\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload)\n    };\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n      message: formattedMessage,\n      block_id\n    });\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  getSyncingStats() {\n    return this.fetchEndpoint(\"starknet_syncing\");\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  getEvents(eventFilter) {\n    return this.fetchEndpoint(\"starknet_getEvents\", { filter: eventFilter });\n  }\n  buildTransaction(invocation, versionType) {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n    if (!isV3Tx(invocation)) {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0)\n      };\n    } else {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it))\n      };\n    }\n    if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n      return {\n        // v0 v1 v3\n        type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DECLARE\" /* DECLARE */) {\n      if (!isSierra(invocation.contract)) {\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details\n        };\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program)\n        },\n        compiled_class_hash: invocation.compiledClassHash || \"\",\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n      const { account_deployment_data, ...restDetails } = details;\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...restDetails\n      };\n    }\n    throw Error(\"RPC buildTransaction received unknown TransactionType\");\n  }\n};\n\n// src/channel/rpc_0_7.ts\nvar rpc_0_7_exports = {};\n__export(rpc_0_7_exports, {\n  RpcChannel: () => RpcChannel2\n});\nvar defaultOptions2 = {\n  headers: { \"Content-Type\": \"application/json\" },\n  blockIdentifier: \"pending\" /* pending */,\n  retries: 200\n};\nvar RpcChannel2 = class {\n  nodeUrl;\n  headers;\n  retries;\n  requestId;\n  blockIdentifier;\n  chainId;\n  specVersion;\n  waitMode;\n  // behave like web2 rpc and return when tx is processed\n  constructor(optionsOrProvider) {\n    const { nodeUrl, retries, headers, blockIdentifier, chainId, specVersion, waitMode } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n    }\n    this.retries = retries || defaultOptions2.retries;\n    this.headers = { ...defaultOptions2.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions2.blockIdentifier;\n    this.chainId = chainId;\n    this.specVersion = specVersion;\n    this.waitMode = waitMode || false;\n    this.requestId = 0;\n  }\n  setChainId(chainId) {\n    this.chainId = chainId;\n  }\n  fetch(method, params, id = 0) {\n    const rpcRequestBody = {\n      id,\n      jsonrpc: \"2.0\",\n      method,\n      ...params && { params }\n    };\n    return fetchPonyfill_default(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(rpcRequestBody),\n      headers: this.headers\n    });\n  }\n  errorHandler(method, params, rpcError, otherError) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify2(params, null, 2)}\n \n        ${code}: ${message}: ${stringify2(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n  async fetchEndpoint(method, params) {\n    try {\n      const rawResult = await this.fetch(method, params, this.requestId += 1);\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result;\n    } catch (error) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n  async getChainId() {\n    this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n    return this.chainId;\n  }\n  async getSpecVersion() {\n    this.specVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n    return this.specVersion;\n  }\n  getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getNonce\", {\n      contract_address,\n      block_id\n    });\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  getBlockLatestAccepted() {\n    return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  getBlockNumber() {\n    return this.fetchEndpoint(\"starknet_blockNumber\");\n  }\n  getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", { block_id });\n  }\n  getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxs\", { block_id });\n  }\n  getBlockWithReceipts(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithReceipts\", { block_id });\n  }\n  getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStateUpdate\", { block_id });\n  }\n  getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_traceBlockTransactions\", { block_id });\n  }\n  getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", { block_id });\n  }\n  getTransactionByHash(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n      transaction_hash\n    });\n  }\n  getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", { block_id, index });\n  }\n  getTransactionReceipt(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionReceipt\", { transaction_hash });\n  }\n  getTransactionTrace(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_traceTransaction\", { transaction_hash });\n  }\n  /**\n   * Get the status of a transaction\n   */\n  getTransactionStatus(transactionHash) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint(\"starknet_getTransactionStatus\", { transaction_hash });\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  simulateTransaction(invocations, {\n    blockIdentifier = this.blockIdentifier,\n    skipValidate = true,\n    skipFeeCharge = true\n  } = {}) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags = [];\n    if (skipValidate)\n      simulationFlags.push(starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge)\n      simulationFlags.push(starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ESimulationFlag.SKIP_FEE_CHARGE);\n    return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags\n    });\n  }\n  async waitForTransaction(txHash, options) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? 5e3;\n    const errorStates = options?.errorStates ?? [\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionStatus.REJECTED\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates = options?.successStates ?? [\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionExecutionStatus.SUCCEEDED,\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionStatus.ACCEPTED_ON_L2,\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionStatus.ACCEPTED_ON_L1\n    ];\n    let txStatus;\n    while (!onchain) {\n      await wait(retryInterval);\n      try {\n        txStatus = await this.getTransactionStatus(transactionHash);\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n        if (!finalityStatus) {\n          const error = new Error(\"waiting for transaction status\");\n          throw error;\n        }\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message);\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n    }\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      await wait(retryInterval);\n    }\n    return txReceipt;\n  }\n  getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStorageAt\", {\n      contract_address,\n      key: parsedKey,\n      block_id\n    });\n  }\n  getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  getClass(classHash, blockIdentifier = this.blockIdentifier) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClass\", {\n      class_hash,\n      block_id\n    });\n  }\n  getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion(\"0.5\", await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ESimulationFlag.SKIP_VALIDATE] : []\n      };\n    }\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: invocations.map((it) => this.buildTransaction(it, \"fee\")),\n      block_id,\n      ...flags\n    });\n  }\n  async invoke(functionInvocation, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          compiled_class_hash: compiledClassHash || \"\",\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || \"\",\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    } else {\n      throw Error(\"declare unspotted parameters\");\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DEPLOY_ACCOUNT,\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  callContract(call, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_call\", {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata)\n      },\n      block_id\n    });\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload)\n    };\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n      message: formattedMessage,\n      block_id\n    });\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  getSyncingStats() {\n    return this.fetchEndpoint(\"starknet_syncing\");\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  getEvents(eventFilter) {\n    return this.fetchEndpoint(\"starknet_getEvents\", { filter: eventFilter });\n  }\n  buildTransaction(invocation, versionType) {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n    if (!isV3Tx(invocation)) {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0)\n      };\n    } else {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it))\n      };\n    }\n    if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n      return {\n        // v0 v1 v3\n        type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DECLARE\" /* DECLARE */) {\n      if (!isSierra(invocation.contract)) {\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details\n        };\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program)\n        },\n        compiled_class_hash: invocation.compiledClassHash || \"\",\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n      const { account_deployment_data, ...restDetails } = details;\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...restDetails\n      };\n    }\n    throw Error(\"RPC buildTransaction received unknown TransactionType\");\n  }\n};\n\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n  margin;\n  constructor(margin) {\n    this.margin = margin;\n  }\n  estimatedFeeToMaxFee(estimatedFee) {\n    return estimatedFeeToMaxFee(estimatedFee, this.margin?.maxFee);\n  }\n  estimateFeeToBounds(estimate) {\n    return estimateFeeToBounds(\n      estimate,\n      this.margin?.l1BoundMaxAmount,\n      this.margin?.l1BoundMaxPricePerUnit\n    );\n  }\n  parseGetBlockResponse(res) {\n    return { status: \"PENDING\", ...res };\n  }\n  parseTransactionReceipt(res) {\n    if (\"actual_fee\" in res && isString(res.actual_fee)) {\n      return {\n        ...res,\n        actual_fee: {\n          amount: res.actual_fee,\n          unit: \"FRI\"\n        }\n      };\n    }\n    return res;\n  }\n  parseFeeEstimateResponse(res) {\n    const val = res[0];\n    return {\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n\n    };\n  }\n  parseFeeEstimateBulkResponse(res) {\n    return res.map((val) => ({\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n\n    }));\n  }\n  parseSimulateTransactionResponse(res) {\n    return res.map((it) => {\n      return {\n        ...it,\n        suggestedMaxFee: this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),\n        resourceBounds: this.estimateFeeToBounds(it.fee_estimation)\n      };\n    });\n  }\n  parseContractClassResponse(res) {\n    return {\n      ...res,\n      abi: isString(res.abi) ? JSON.parse(res.abi) : res.abi\n    };\n  }\n  parseL1GasPriceResponse(res) {\n    return res.l1_gas_price.price_in_wei;\n  }\n};\n\n// src/utils/transactionReceipt.ts\nvar ReceiptTx = class _ReceiptTx {\n  statusReceipt;\n  value;\n  constructor(receipt) {\n    [this.statusReceipt, this.value] = _ReceiptTx.isSuccess(receipt) ? [\"success\", receipt] : _ReceiptTx.isReverted(receipt) ? [\"reverted\", receipt] : _ReceiptTx.isRejected(receipt) ? [\"rejected\", receipt] : [\"error\", new Error(\"Unknown response type\")];\n    for (const [key] of Object.entries(this)) {\n      Object.defineProperty(this, key, {\n        enumerable: false\n      });\n    }\n    for (const [key, value] of Object.entries(receipt)) {\n      Object.defineProperty(this, key, {\n        enumerable: true,\n        writable: false,\n        value\n      });\n    }\n  }\n  match(callbacks) {\n    if (this.statusReceipt in callbacks) {\n      return callbacks[this.statusReceipt](this.value);\n    }\n    return callbacks._();\n  }\n  isSuccess() {\n    return this.statusReceipt === \"success\";\n  }\n  isReverted() {\n    return this.statusReceipt === \"reverted\";\n  }\n  isRejected() {\n    return this.statusReceipt === \"rejected\";\n  }\n  isError() {\n    return this.statusReceipt === \"error\";\n  }\n  static isSuccess(transactionReceipt) {\n    return transactionReceipt.execution_status === \"SUCCEEDED\" /* SUCCEEDED */;\n  }\n  static isReverted(transactionReceipt) {\n    return transactionReceipt.execution_status === \"REVERTED\" /* REVERTED */;\n  }\n  static isRejected(transactionReceipt) {\n    return transactionReceipt.status === \"REJECTED\" /* REJECTED */;\n  }\n};\n\n// src/provider/rpc.ts\nvar RpcProvider = class {\n  responseParser;\n  channel;\n  constructor(optionsOrProvider) {\n    if (optionsOrProvider && \"channel\" in optionsOrProvider) {\n      this.channel = optionsOrProvider.channel;\n      this.responseParser = optionsOrProvider.responseParser;\n    } else {\n      this.channel = new RpcChannel2({ ...optionsOrProvider, waitMode: false });\n      this.responseParser = new RPCResponseParser(optionsOrProvider?.feeMarginPercentage);\n    }\n  }\n  fetch(method, params, id = 0) {\n    return this.channel.fetch(method, params, id);\n  }\n  async getChainId() {\n    return this.channel.getChainId();\n  }\n  async getSpecVersion() {\n    return this.channel.getSpecVersion();\n  }\n  async getNonceForAddress(contractAddress, blockIdentifier) {\n    return this.channel.getNonceForAddress(contractAddress, blockIdentifier);\n  }\n  async getBlock(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  async getBlockLatestAccepted() {\n    return this.channel.getBlockLatestAccepted();\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  async getBlockNumber() {\n    return this.channel.getBlockNumber();\n  }\n  async getBlockWithTxHashes(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier);\n  }\n  async getBlockWithTxs(blockIdentifier) {\n    return this.channel.getBlockWithTxs(blockIdentifier);\n  }\n  async getL1GasPrice(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseL1GasPriceResponse);\n  }\n  async getBlockWithReceipts(blockIdentifier) {\n    if (this.channel instanceof rpc_0_6_exports.RpcChannel)\n      throw new LibraryError(\"Unsupported method for RPC version\");\n    return this.channel.getBlockWithReceipts(blockIdentifier);\n  }\n  getStateUpdate = this.getBlockStateUpdate;\n  async getBlockStateUpdate(blockIdentifier) {\n    return this.channel.getBlockStateUpdate(blockIdentifier);\n  }\n  async getBlockTransactionsTraces(blockIdentifier) {\n    return this.channel.getBlockTransactionsTraces(blockIdentifier);\n  }\n  async getBlockTransactionCount(blockIdentifier) {\n    return this.channel.getBlockTransactionCount(blockIdentifier);\n  }\n  /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.pending); (will be removed in next minor version)\n   * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);\n   */\n  async getPendingTransactions() {\n    const { transactions } = await this.getBlockWithTxHashes(\"pending\" /* pending */).then(\n      this.responseParser.parseGetBlockResponse\n    );\n    return Promise.all(transactions.map((it) => this.getTransactionByHash(it)));\n  }\n  async getTransaction(txHash) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n  async getTransactionByHash(txHash) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n  async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);\n  }\n  async getTransactionReceipt(txHash) {\n    const txReceiptWoHelper = await this.channel.getTransactionReceipt(txHash);\n    const txReceiptWoHelperModified = this.responseParser.parseTransactionReceipt(txReceiptWoHelper);\n    return new ReceiptTx(txReceiptWoHelperModified);\n  }\n  async getTransactionTrace(txHash) {\n    return this.channel.getTransactionTrace(txHash);\n  }\n  /**\n   * Get the status of a transaction\n   */\n  async getTransactionStatus(transactionHash) {\n    return this.channel.getTransactionStatus(transactionHash);\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  async getSimulateTransaction(invocations, options) {\n    return this.channel.simulateTransaction(invocations, options).then((r) => this.responseParser.parseSimulateTransactionResponse(r));\n  }\n  async waitForTransaction(txHash, options) {\n    const receiptWoHelper = await this.channel.waitForTransaction(\n      txHash,\n      options\n    );\n    return new ReceiptTx(receiptWoHelper);\n  }\n  async getStorageAt(contractAddress, key, blockIdentifier) {\n    return this.channel.getStorageAt(contractAddress, key, blockIdentifier);\n  }\n  async getClassHashAt(contractAddress, blockIdentifier) {\n    return this.channel.getClassHashAt(contractAddress, blockIdentifier);\n  }\n  async getClassByHash(classHash) {\n    return this.getClass(classHash);\n  }\n  async getClass(classHash, blockIdentifier) {\n    return this.channel.getClass(classHash, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n  }\n  async getClassAt(contractAddress, blockIdentifier) {\n    return this.channel.getClassAt(contractAddress, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n  }\n  async getContractVersion(contractAddress, classHash, {\n    blockIdentifier = this.channel.blockIdentifier,\n    compiler = true\n  } = {}) {\n    let contractClass;\n    if (contractAddress) {\n      contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n    } else if (classHash) {\n      contractClass = await this.getClass(classHash, blockIdentifier);\n    } else {\n      throw Error(\"getContractVersion require contractAddress or classHash\");\n    }\n    if (isSierra(contractClass)) {\n      if (compiler) {\n        const abiTest = getAbiContractVersion(contractClass.abi);\n        return { cairo: \"1\", compiler: abiTest.compiler };\n      }\n      return { cairo: \"1\", compiler: void 0 };\n    }\n    return { cairo: \"0\", compiler: \"0\" };\n  }\n  /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */\n  async getEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n  }\n  async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: \"INVOKE_FUNCTION\" /* INVOKE */,\n          ...invocation,\n          ...invocationDetails\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getDeclareEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: \"DECLARE\" /* DECLARE */,\n          ...invocation,\n          ...details\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getDeployAccountEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */,\n          ...invocation,\n          ...details\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getEstimateFeeBulk(invocations, options) {\n    return this.channel.getEstimateFee(invocations, options).then((r) => this.responseParser.parseFeeEstimateBulkResponse(r));\n  }\n  async invokeFunction(functionInvocation, details) {\n    return this.channel.invoke(functionInvocation, details);\n  }\n  async declareContract(transaction, details) {\n    return this.channel.declare(transaction, details);\n  }\n  async deployAccountContract(transaction, details) {\n    return this.channel.deployAccount(\n      transaction,\n      details\n    );\n  }\n  async callContract(call, blockIdentifier) {\n    return this.channel.callContract(call, blockIdentifier);\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  async estimateMessageFee(message, blockIdentifier) {\n    return this.channel.estimateMessageFee(message, blockIdentifier);\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  async getSyncingStats() {\n    return this.channel.getSyncingStats();\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  async getEvents(eventFilter) {\n    return this.channel.getEvents(eventFilter);\n  }\n};\n\n// src/provider/extensions/default.ts\n\n\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n  StarknetIdContract: () => StarknetIdContract,\n  StarknetIdIdentityContract: () => StarknetIdIdentityContract,\n  StarknetIdMulticallContract: () => StarknetIdMulticallContract,\n  StarknetIdPfpContract: () => StarknetIdPfpContract,\n  StarknetIdPopContract: () => StarknetIdPopContract,\n  StarknetIdVerifierContract: () => StarknetIdVerifierContract,\n  dynamicCallData: () => dynamicCallData,\n  dynamicFelt: () => dynamicFelt,\n  execution: () => execution,\n  getStarknetIdContract: () => getStarknetIdContract,\n  getStarknetIdIdentityContract: () => getStarknetIdIdentityContract,\n  getStarknetIdMulticallContract: () => getStarknetIdMulticallContract,\n  getStarknetIdPfpContract: () => getStarknetIdPfpContract,\n  getStarknetIdPopContract: () => getStarknetIdPopContract,\n  getStarknetIdVerifierContract: () => getStarknetIdVerifierContract,\n  useDecoded: () => useDecoded,\n  useEncoded: () => useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"\\u8FD9\\u6765\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n  let k = 0;\n  while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {\n    str = str.substring(0, str.length - 1);\n    k += 1;\n  }\n  return [str, k];\n}\nfunction useDecoded(encoded) {\n  let decoded = \"\";\n  encoded.forEach((subdomain) => {\n    while (subdomain !== ZERO) {\n      const code = subdomain % basicSizePlusOne;\n      subdomain /= basicSizePlusOne;\n      if (code === BigInt(basicAlphabet.length)) {\n        const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n        if (nextSubdomain === ZERO) {\n          const code2 = subdomain % bigAlphabetSizePlusOne;\n          subdomain = nextSubdomain;\n          if (code2 === ZERO)\n            decoded += basicAlphabet[0];\n          else\n            decoded += bigAlphabet[Number(code2) - 1];\n        } else {\n          const code2 = subdomain % bigAlphabetSize;\n          decoded += bigAlphabet[Number(code2)];\n          subdomain /= bigAlphabetSize;\n        }\n      } else\n        decoded += basicAlphabet[Number(code)];\n    }\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n    decoded += \".\";\n  });\n  if (!decoded) {\n    return decoded;\n  }\n  return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n  let encoded = BigInt(0);\n  let multiplier = BigInt(1);\n  if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n    const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n  } else {\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n  }\n  for (let i = 0; i < decoded.length; i += 1) {\n    const char = decoded[i];\n    const index = basicAlphabet.indexOf(char);\n    const bnIndex = BigInt(basicAlphabet.indexOf(char));\n    if (index !== -1) {\n      if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n        encoded += multiplier * basicAlphabetSize;\n        multiplier *= basicSizePlusOne;\n        multiplier *= basicSizePlusOne;\n      } else {\n        encoded += multiplier * bnIndex;\n        multiplier *= basicSizePlusOne;\n      }\n    } else if (bigAlphabet.indexOf(char) !== -1) {\n      encoded += multiplier * basicAlphabetSize;\n      multiplier *= basicSizePlusOne;\n      const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n      encoded += multiplier * BigInt(newid);\n      multiplier *= bigAlphabetSize;\n    }\n  }\n  return encoded;\n}\nvar StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2) => {\n  StarknetIdContract2[\"MAINNET\"] = \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\";\n  StarknetIdContract2[\"TESTNET\"] = \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\";\n  StarknetIdContract2[\"TESTNET_SEPOLIA\"] = \"0x0707f09bc576bd7cfee59694846291047e965f4184fe13dac62c56759b3b6fa7\";\n  return StarknetIdContract2;\n})(StarknetIdContract || {});\nfunction getStarknetIdContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\" /* MAINNET */;\n    case \"0x534e5f474f45524c49\" /* SN_GOERLI */:\n      return \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\" /* TESTNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x0707f09bc576bd7cfee59694846291047e965f4184fe13dac62c56759b3b6fa7\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\"Starknet.id is not yet deployed on this network\");\n  }\n}\nvar StarknetIdIdentityContract = /* @__PURE__ */ ((StarknetIdIdentityContract2) => {\n  StarknetIdIdentityContract2[\"MAINNET\"] = \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\";\n  StarknetIdIdentityContract2[\"TESTNET\"] = \"0x783a9097b26eae0586373b2ce0ed3529ddc44069d1e0fbc4f66d42b69d6850d\";\n  StarknetIdIdentityContract2[\"TESTNET_SEPOLIA\"] = \"0x070DF8B4F5cb2879f8592849fA8f3134da39d25326B8558cc9C8FE8D47EA3A90\";\n  return StarknetIdIdentityContract2;\n})(StarknetIdIdentityContract || {});\nfunction getStarknetIdIdentityContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\" /* MAINNET */;\n    case \"0x534e5f474f45524c49\" /* SN_GOERLI */:\n      return \"0x783a9097b26eae0586373b2ce0ed3529ddc44069d1e0fbc4f66d42b69d6850d\" /* TESTNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x070DF8B4F5cb2879f8592849fA8f3134da39d25326B8558cc9C8FE8D47EA3A90\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\"Starknet.id verifier contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdMulticallContract = \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\";\nfunction getStarknetIdMulticallContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return StarknetIdMulticallContract;\n    case \"0x534e5f474f45524c49\" /* SN_GOERLI */:\n      return StarknetIdMulticallContract;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return StarknetIdMulticallContract;\n    default:\n      throw new Error(\"Starknet.id multicall contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdVerifierContract = /* @__PURE__ */ ((StarknetIdVerifierContract2) => {\n  StarknetIdVerifierContract2[\"MAINNET\"] = \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\";\n  StarknetIdVerifierContract2[\"TESTNET\"] = \"0x057c942544063c3aea6ea6c37009cc9d1beacd750cb6801549a129c7265f0f11\";\n  StarknetIdVerifierContract2[\"TESTNET_SEPOLIA\"] = \"0x0182EcE8173C216A395f4828e1523541b7e3600bf190CB252E1a1A0cE219d184\";\n  return StarknetIdVerifierContract2;\n})(StarknetIdVerifierContract || {});\nfunction getStarknetIdVerifierContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\" /* MAINNET */;\n    case \"0x534e5f474f45524c49\" /* SN_GOERLI */:\n      return \"0x057c942544063c3aea6ea6c37009cc9d1beacd750cb6801549a129c7265f0f11\" /* TESTNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x0182EcE8173C216A395f4828e1523541b7e3600bf190CB252E1a1A0cE219d184\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\"Starknet.id verifier contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdPfpContract = /* @__PURE__ */ ((StarknetIdPfpContract2) => {\n  StarknetIdPfpContract2[\"MAINNET\"] = \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\";\n  StarknetIdPfpContract2[\"TESTNET\"] = \"0x03cac3228b434259734ee0e4ff445f642206ea11adace7e4f45edd2596748698\";\n  StarknetIdPfpContract2[\"TESTNET_SEPOLIA\"] = \"0x058061bb6bdc501eE215172c9f87d557C1E0f466dC498cA81b18f998Bf1362b2\";\n  return StarknetIdPfpContract2;\n})(StarknetIdPfpContract || {});\nfunction getStarknetIdPfpContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\" /* MAINNET */;\n    case \"0x534e5f474f45524c49\" /* SN_GOERLI */:\n      return \"0x03cac3228b434259734ee0e4ff445f642206ea11adace7e4f45edd2596748698\" /* TESTNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x058061bb6bdc501eE215172c9f87d557C1E0f466dC498cA81b18f998Bf1362b2\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\n        \"Starknet.id profile picture verifier contract is not yet deployed on this network\"\n      );\n  }\n}\nvar StarknetIdPopContract = /* @__PURE__ */ ((StarknetIdPopContract2) => {\n  StarknetIdPopContract2[\"MAINNET\"] = \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\";\n  StarknetIdPopContract2[\"TESTNET\"] = \"0x03528caf090179e337931ee669a5b0214041e1bae30d460ff07d2cea2c7a9106\";\n  StarknetIdPopContract2[\"TESTNET_SEPOLIA\"] = \"0x0023FE3b845ed5665a9eb3792bbB17347B490EE4090f855C1298d03BB5F49B49\";\n  return StarknetIdPopContract2;\n})(StarknetIdPopContract || {});\nfunction getStarknetIdPopContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\" /* MAINNET */;\n    case \"0x534e5f474f45524c49\" /* SN_GOERLI */:\n      return \"0x03528caf090179e337931ee669a5b0214041e1bae30d460ff07d2cea2c7a9106\" /* TESTNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x0023FE3b845ed5665a9eb3792bbB17347B490EE4090f855C1298d03BB5F49B49\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\n        \"Starknet.id proof of personhood verifier contract is not yet deployed on this network\"\n      );\n  }\n}\nfunction execution(staticEx, ifEqual = void 0, ifNotEqual = void 0) {\n  return new CairoCustomEnum({\n    Static: staticEx,\n    IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : void 0,\n    IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : void 0\n  });\n}\nfunction dynamicFelt(hardcoded, reference = void 0) {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : void 0\n  });\n}\nfunction dynamicCallData(hardcoded, reference = void 0, arrayReference = void 0) {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : void 0,\n    ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : void 0\n  });\n}\n\n// src/provider/extensions/starknetId.ts\nvar StarknetId = class _StarknetId {\n  async getStarkName(address, StarknetIdContract2) {\n    return _StarknetId.getStarkName(\n      // After Mixin, this is ProviderInterface\n      this,\n      address,\n      StarknetIdContract2\n    );\n  }\n  async getAddressFromStarkName(name, StarknetIdContract2) {\n    return _StarknetId.getAddressFromStarkName(\n      // After Mixin, this is ProviderInterface\n      this,\n      name,\n      StarknetIdContract2\n    );\n  }\n  async getStarkProfile(address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {\n    return _StarknetId.getStarkProfile(\n      // After Mixin, this is ProviderInterface\n      this,\n      address,\n      StarknetIdContract2,\n      StarknetIdIdentityContract2,\n      StarknetIdVerifierContract2,\n      StarknetIdPfpContract2,\n      StarknetIdPopContract2,\n      StarknetIdMulticallContract2\n    );\n  }\n  static async getStarkName(provider, address, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n      const hexDomain = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: \"address_to_domain\",\n        calldata: CallData.compile({\n          address\n        })\n      });\n      const decimalDomain = hexDomain.map((element) => BigInt(element)).slice(1);\n      const stringDomain = useDecoded(decimalDomain);\n      if (!stringDomain) {\n        throw Error(\"Starkname not found\");\n      }\n      return stringDomain;\n    } catch (e) {\n      if (e instanceof Error && e.message === \"Starkname not found\") {\n        throw e;\n      }\n      throw Error(\"Could not get stark name\");\n    }\n  }\n  static async getAddressFromStarkName(provider, name, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n      const encodedDomain = name.replace(\".stark\", \"\").split(\".\").map((part) => useEncoded(part).toString(10));\n      const addressData = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: \"domain_to_address\",\n        calldata: CallData.compile({ domain: encodedDomain, hint: [] })\n      });\n      return addressData[0];\n    } catch {\n      throw Error(\"Could not get address from stark name\");\n    }\n  }\n  static async getStarkProfile(provider, address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    const identityContract = StarknetIdIdentityContract2 ?? getStarknetIdIdentityContract(chainId);\n    const verifierContract = StarknetIdVerifierContract2 ?? getStarknetIdVerifierContract(chainId);\n    const pfpContract = StarknetIdPfpContract2 ?? getStarknetIdPfpContract(chainId);\n    const popContract = StarknetIdPopContract2 ?? getStarknetIdPopContract(chainId);\n    const multicallAddress = StarknetIdMulticallContract2 ?? getStarknetIdMulticallContract(chainId);\n    try {\n      const data = await provider.callContract({\n        contractAddress: multicallAddress,\n        entrypoint: \"aggregate\",\n        calldata: CallData.compile({\n          calls: [\n            {\n              execution: execution({}),\n              to: dynamicFelt(contract),\n              selector: dynamicFelt(getSelectorFromName(\"address_to_domain\")),\n              calldata: [dynamicCallData(address)]\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(contract),\n              selector: dynamicFelt(getSelectorFromName(\"domain_to_id\")),\n              calldata: [dynamicCallData(void 0, void 0, [0, 0])]\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n              calldata: [\n                dynamicCallData(void 0, [1, 0]),\n                dynamicCallData(encodeShortString(\"twitter\")),\n                dynamicCallData(verifierContract),\n                dynamicCallData(\"0\")\n              ]\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n              calldata: [\n                dynamicCallData(void 0, [1, 0]),\n                dynamicCallData(encodeShortString(\"github\")),\n                dynamicCallData(verifierContract),\n                dynamicCallData(\"0\")\n              ]\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n              calldata: [\n                dynamicCallData(void 0, [1, 0]),\n                dynamicCallData(encodeShortString(\"discord\")),\n                dynamicCallData(verifierContract),\n                dynamicCallData(\"0\")\n              ]\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n              calldata: [\n                dynamicCallData(void 0, [1, 0]),\n                dynamicCallData(encodeShortString(\"proof_of_personhood\")),\n                dynamicCallData(popContract),\n                dynamicCallData(\"0\")\n              ]\n            },\n            // PFP\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n              calldata: [\n                dynamicCallData(void 0, [1, 0]),\n                dynamicCallData(encodeShortString(\"nft_pp_contract\")),\n                dynamicCallData(pfpContract),\n                dynamicCallData(\"0\")\n              ]\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName(\"get_extended_verifier_data\")),\n              calldata: [\n                dynamicCallData(void 0, [1, 0]),\n                dynamicCallData(encodeShortString(\"nft_pp_id\")),\n                dynamicCallData(\"2\"),\n                dynamicCallData(pfpContract),\n                dynamicCallData(\"0\")\n              ]\n            },\n            {\n              execution: execution(void 0, void 0, [6, 0, 0]),\n              to: dynamicFelt(void 0, [6, 0]),\n              selector: dynamicFelt(getSelectorFromName(\"tokenURI\")),\n              calldata: [dynamicCallData(void 0, [7, 1]), dynamicCallData(void 0, [7, 2])]\n            }\n          ]\n        })\n      });\n      if (Array.isArray(data)) {\n        const size = parseInt(data[0], 16);\n        const finalArray = [];\n        let index = 1;\n        for (let i = 0; i < size; i += 1) {\n          if (index < data.length) {\n            const subArraySize = parseInt(data[index], 16);\n            index += 1;\n            const subArray = data.slice(index, index + subArraySize);\n            finalArray.push(subArray);\n            index += subArraySize;\n          } else {\n            break;\n          }\n        }\n        const name = useDecoded(finalArray[0].slice(1).map((hexString) => BigInt(hexString)));\n        const twitter = finalArray[2][0] !== \"0x0\" ? BigInt(finalArray[2][0]).toString() : void 0;\n        const github = finalArray[3][0] !== \"0x0\" ? BigInt(finalArray[3][0]).toString() : void 0;\n        const discord = finalArray[4][0] !== \"0x0\" ? BigInt(finalArray[4][0]).toString() : void 0;\n        const proofOfPersonhood = finalArray[5][0] === \"0x1\";\n        const profilePictureMetadata = data[0] === \"0x9\" ? finalArray[8].slice(1).map((val) => decodeShortString(val)).join(\"\") : void 0;\n        const profilePicture = profilePictureMetadata || `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;\n        return {\n          name,\n          twitter,\n          github,\n          discord,\n          proofOfPersonhood,\n          profilePicture\n        };\n      }\n      throw Error(\"Error while calling aggregate function\");\n    } catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      throw Error(\"Could not get user stark profile data from address\");\n    }\n  }\n};\n\n// src/provider/extensions/default.ts\nvar RpcProvider2 = class extends (0,ts_mixer__WEBPACK_IMPORTED_MODULE_13__.Mixin)(RpcProvider, StarknetId) {\n};\n\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n\n// src/provider/index.ts\nvar defaultProvider = new RpcProvider({ default: true });\n\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n  TypedDataRevision: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision,\n  encodeData: () => encodeData,\n  encodeType: () => encodeType,\n  encodeValue: () => encodeValue,\n  getDependencies: () => getDependencies,\n  getMessageHash: () => getMessageHash,\n  getStructHash: () => getStructHash,\n  getTypeHash: () => getTypeHash,\n  isMerkleTreeType: () => isMerkleTreeType,\n  prepareSelector: () => prepareSelector\n});\n\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n  MerkleTree: () => MerkleTree,\n  proofMerklePath: () => proofMerklePath\n});\nvar MerkleTree = class _MerkleTree {\n  leaves;\n  branches = [];\n  root;\n  hashMethod;\n  constructor(leafHashes, hashMethod = computePedersenHash) {\n    this.hashMethod = hashMethod;\n    this.leaves = leafHashes;\n    this.root = this.build(leafHashes);\n  }\n  /**\n   * Create Merkle tree\n   * @param leaves hex-string array\n   * @returns format: hex-string; Merkle tree root\n   */\n  build(leaves) {\n    if (leaves.length === 1) {\n      return leaves[0];\n    }\n    if (leaves.length !== this.leaves.length) {\n      this.branches.push(leaves);\n    }\n    const newLeaves = [];\n    for (let i = 0; i < leaves.length; i += 2) {\n      if (i + 1 === leaves.length) {\n        newLeaves.push(_MerkleTree.hash(leaves[i], \"0x0\", this.hashMethod));\n      } else {\n        newLeaves.push(_MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n      }\n    }\n    return this.build(newLeaves);\n  }\n  /**\n   * Create hash from ordered a and b, Pedersen hash default\n   * @returns format: hex-string\n   */\n  static hash(a, b, hashMethod = computePedersenHash) {\n    const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) => x >= y ? 1 : -1);\n    return hashMethod(aSorted, bSorted);\n  }\n  /**\n   * Return path to leaf\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns format: hex-string array\n   */\n  getProof(leaf, branch = this.leaves, hashPath = []) {\n    const index = branch.indexOf(leaf);\n    if (index === -1) {\n      throw new Error(\"leaf not found\");\n    }\n    if (branch.length === 1) {\n      return hashPath;\n    }\n    const isLeft = index % 2 === 0;\n    const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n    const newHashPath = [...hashPath, neededBranch];\n    const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b) => b.length === branch.length);\n    const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];\n    return this.getProof(\n      _MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod),\n      nextBranch,\n      newHashPath\n    );\n  }\n};\nfunction proofMerklePath(root, leaf, path, hashMethod = computePedersenHash) {\n  if (path.length === 0) {\n    return root === leaf;\n  }\n  const [next, ...rest] = path;\n  return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n\n// src/utils/typedData.ts\nvar presetTypes = {\n  u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n  TokenAmount: JSON.parse(\n    '[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'\n  ),\n  NftId: JSON.parse(\n    '[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]'\n  )\n};\nvar revisionConfiguration = {\n  [starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active]: {\n    domain: \"StarknetDomain\",\n    hashMethod: computePoseidonHashOnElements,\n    hashMerkleMethod: computePoseidonHash,\n    escapeTypeString: (s) => `\"${s}\"`,\n    presetTypes\n  },\n  [starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy]: {\n    domain: \"StarkNetDomain\",\n    hashMethod: computePedersenHashOnElements,\n    hashMerkleMethod: computePedersenHash,\n    escapeTypeString: (s) => s,\n    presetTypes: {}\n  }\n};\nfunction assertRange(data, type, { min, max }) {\n  const value = BigInt(data);\n  assert(value >= min && value <= max, `${value} (${type}) is out of bounds [${min}, ${max}]`);\n}\nfunction identifyRevision({ types, domain }) {\n  if (revisionConfiguration[starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active].domain in types && domain.revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active)\n    return starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active;\n  if (revisionConfiguration[starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy].domain in types && (domain.revision ?? starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy) === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy)\n    return starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy;\n  return void 0;\n}\nfunction getHex(value) {\n  try {\n    return toHex(value);\n  } catch (e) {\n    if (isString(value)) {\n      return toHex(encodeShortString(value));\n    }\n    throw new Error(`Invalid BigNumberish: ${value}`);\n  }\n}\nfunction validateTypedData(data) {\n  const typedData = data;\n  return Boolean(\n    typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData)\n  );\n}\nfunction prepareSelector(selector) {\n  return isHex(selector) ? selector : getSelectorFromName(selector);\n}\nfunction isMerkleTreeType(type) {\n  return type.type === \"merkletree\";\n}\nfunction getDependencies(types, type, dependencies = [], contains = \"\", revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy) {\n  if (type[type.length - 1] === \"*\") {\n    type = type.slice(0, -1);\n  } else if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active) {\n    if (type === \"enum\") {\n      type = contains;\n    } else if (type.match(/^\\(.*\\)$/)) {\n      type = type.slice(1, -1);\n    }\n  }\n  if (dependencies.includes(type) || !types[type]) {\n    return dependencies;\n  }\n  return [\n    type,\n    ...types[type].reduce(\n      (previous, t) => [\n        ...previous,\n        ...getDependencies(types, t.type, previous, t.contains, revision).filter(\n          (dependency) => !previous.includes(dependency)\n        )\n      ],\n      []\n    )\n  ];\n}\nfunction getMerkleTreeType(types, ctx) {\n  if (ctx.parent && ctx.key) {\n    const parentType = types[ctx.parent];\n    const merkleType = parentType.find((t) => t.name === ctx.key);\n    const isMerkleTree = isMerkleTreeType(merkleType);\n    if (!isMerkleTree) {\n      throw new Error(`${ctx.key} is not a merkle tree`);\n    }\n    if (merkleType.contains.endsWith(\"*\")) {\n      throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n    }\n    return merkleType.contains;\n  }\n  return \"raw\";\n}\nfunction encodeType(types, type, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy) {\n  const allTypes = revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active ? { ...types, ...revisionConfiguration[revision].presetTypes } : types;\n  const [primary, ...dependencies] = getDependencies(\n    allTypes,\n    type,\n    void 0,\n    void 0,\n    revision\n  );\n  const newTypes = !primary ? [] : [primary, ...dependencies.sort()];\n  const esc = revisionConfiguration[revision].escapeTypeString;\n  return newTypes.map((dependency) => {\n    const dependencyElements = allTypes[dependency].map((t) => {\n      const targetType = t.type === \"enum\" && revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active ? t.contains : t.type;\n      const typeString = targetType.match(/^\\(.*\\)$/) ? `(${targetType.slice(1, -1).split(\",\").map((e) => e ? esc(e) : e).join(\",\")})` : esc(targetType);\n      return `${esc(t.name)}:${typeString}`;\n    });\n    return `${esc(dependency)}(${dependencyElements})`;\n  }).join(\"\");\n}\nfunction getTypeHash(types, type, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy) {\n  return getSelectorFromName(encodeType(types, type, revision));\n}\nfunction encodeValue(types, type, data, ctx = {}, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy) {\n  if (types[type]) {\n    return [type, getStructHash(types, type, data, revision)];\n  }\n  if (revisionConfiguration[revision].presetTypes[type]) {\n    return [\n      type,\n      getStructHash(\n        revisionConfiguration[revision].presetTypes,\n        type,\n        data,\n        revision\n      )\n    ];\n  }\n  if (type.endsWith(\"*\")) {\n    const hashes = data.map(\n      (entry) => encodeValue(types, type.slice(0, -1), entry, void 0, revision)[1]\n    );\n    return [type, revisionConfiguration[revision].hashMethod(hashes)];\n  }\n  switch (type) {\n    case \"enum\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active) {\n        const [variantKey, variantData] = Object.entries(data)[0];\n        const parentType = types[ctx.parent][0];\n        const enumType = types[parentType.contains];\n        const variantType = enumType.find((t) => t.name === variantKey);\n        const variantIndex = enumType.indexOf(variantType);\n        const encodedSubtypes = variantType.type.slice(1, -1).split(\",\").map((subtype, index) => {\n          if (!subtype)\n            return subtype;\n          const subtypeData = variantData[index];\n          return encodeValue(types, subtype, subtypeData, void 0, revision)[1];\n        });\n        return [\n          type,\n          revisionConfiguration[revision].hashMethod([variantIndex, ...encodedSubtypes])\n        ];\n      }\n      return [type, getHex(data)];\n    }\n    case \"merkletree\": {\n      const merkleTreeType = getMerkleTreeType(types, ctx);\n      const structHashes = data.map((struct) => {\n        return encodeValue(types, merkleTreeType, struct, void 0, revision)[1];\n      });\n      const { root } = new MerkleTree(\n        structHashes,\n        revisionConfiguration[revision].hashMerkleMethod\n      );\n      return [\"felt\", root];\n    }\n    case \"selector\": {\n      return [\"felt\", prepareSelector(data)];\n    }\n    case \"string\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active) {\n        const byteArray = byteArrayFromString(data);\n        const elements = [\n          byteArray.data.length,\n          ...byteArray.data,\n          byteArray.pending_word,\n          byteArray.pending_word_len\n        ];\n        return [type, revisionConfiguration[revision].hashMethod(elements)];\n      }\n      return [type, getHex(data)];\n    }\n    case \"i128\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active) {\n        const value = BigInt(data);\n        assertRange(value, type, RANGE_I128);\n        return [type, getHex(value < 0n ? PRIME + value : value)];\n      }\n      return [type, getHex(data)];\n    }\n    case \"timestamp\":\n    case \"u128\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active) {\n        assertRange(data, type, RANGE_U128);\n      }\n      return [type, getHex(data)];\n    }\n    case \"felt\":\n    case \"shortstring\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active) {\n        assertRange(getHex(data), type, RANGE_FELT);\n      }\n      return [type, getHex(data)];\n    }\n    case \"ClassHash\":\n    case \"ContractAddress\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active) {\n        assertRange(data, type, RANGE_FELT);\n      }\n      return [type, getHex(data)];\n    }\n    case \"bool\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active) {\n        assert(typeof data === \"boolean\", `Type mismatch for ${type} ${data}`);\n      }\n      return [type, getHex(data)];\n    }\n    default: {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Active) {\n        throw new Error(`Unsupported type: ${type}`);\n      }\n      return [type, getHex(data)];\n    }\n  }\n}\nfunction encodeData(types, type, data, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy) {\n  const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n  const [returnTypes, values] = targetType.reduce(\n    ([ts, vs], field) => {\n      if (data[field.name] === void 0 || data[field.name] === null && field.type !== \"enum\") {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n      const value = data[field.name];\n      const ctx = { parent: type, key: field.name };\n      const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n      return [\n        [...ts, t],\n        [...vs, encodedValue]\n      ];\n    },\n    [[\"felt\"], [getTypeHash(types, type, revision)]]\n  );\n  return [returnTypes, values];\n}\nfunction getStructHash(types, type, data, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.Legacy) {\n  return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\nfunction getMessageHash(typedData, account) {\n  if (!validateTypedData(typedData)) {\n    throw new Error(\"Typed data does not match JSON schema\");\n  }\n  const revision = identifyRevision(typedData);\n  const { domain, hashMethod } = revisionConfiguration[revision];\n  const message = [\n    encodeShortString(\"StarkNet Message\"),\n    getStructHash(typedData.types, domain, typedData.domain, revision),\n    account,\n    getStructHash(typedData.types, typedData.primaryType, typedData.message, revision)\n  ];\n  return hashMethod(message);\n}\n\n// src/signer/default.ts\nvar Signer = class {\n  pk;\n  constructor(pk = _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.utils.randomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n  }\n  async getPubKey() {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.getStarkKey(this.pk);\n  }\n  async signMessage(typedData, accountAddress) {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    return this.signRaw(msgHash);\n  }\n  async signTransaction(transactions, details) {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeployAccountTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signDeclareTransaction(details) {\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeclareTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signRaw(msgHash) {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.sign(msgHash, this.pk);\n  }\n};\n\n// src/signer/ethSigner.ts\n\n\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n  UINT_128_MAX: () => UINT_128_MAX,\n  UINT_256_MAX: () => UINT_256_MAX,\n  bnToUint256: () => bnToUint256,\n  isUint256: () => isUint256,\n  uint256ToBN: () => uint256ToBN\n});\nfunction uint256ToBN(uint2562) {\n  return new CairoUint256(uint2562).toBigInt();\n}\nfunction isUint256(bn) {\n  return CairoUint256.is(bn);\n}\nfunction bnToUint256(bn) {\n  return new CairoUint256(bn).toUint256HexString();\n}\n\n// src/signer/ethSigner.ts\nvar EthSigner = class {\n  pk;\n  // hex string without 0x and with an odd number of characters\n  constructor(pk = ethRandomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk).padStart(64, \"0\") : removeHexPrefix(toHex(pk)).padStart(64, \"0\");\n  }\n  /**\n   * provides the Ethereum full public key (without parity prefix)\n   * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   */\n  async getPubKey() {\n    return addHexPrefix(\n      buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.getPublicKey(this.pk, false)).padStart(130, \"0\").slice(2)\n    );\n  }\n  async signMessage(typedData, accountAddress) {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signTransaction(transactions, details) {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeployAccountTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signDeclareTransaction(details) {\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeclareTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  /**\n   * Serialize the signature in conformity with starknet::eth_signature::Signature\n   * @param ethSignature secp256k1 signature from Noble curves library\n   * @return an array of felts, representing a Cairo Eth Signature.\n   */\n  formatEthSignature(ethSignature) {\n    const r = bnToUint256(ethSignature.r);\n    const s = bnToUint256(ethSignature.s);\n    return [\n      toHex(r.low),\n      toHex(r.high),\n      toHex(s.low),\n      toHex(s.high),\n      toHex(ethSignature.recovery)\n    ];\n  }\n};\n\n// src/utils/events.ts\nfunction parseUDCEvent(txReceipt) {\n  if (!txReceipt.events) {\n    throw new Error(\"UDC emitted event is empty\");\n  }\n  const event = txReceipt.events.find(\n    (it) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)\n  ) || {\n    data: []\n  };\n  return {\n    transaction_hash: txReceipt.transaction_hash,\n    contract_address: event.data[0],\n    address: event.data[0],\n    deployer: event.data[1],\n    unique: event.data[2],\n    classHash: event.data[3],\n    calldata_len: event.data[4],\n    calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n    salt: event.data[event.data.length - 1]\n  };\n}\n\n// src/account/default.ts\nvar Account = class extends RpcProvider2 {\n  signer;\n  address;\n  cairoVersion;\n  transactionVersion;\n  constructor(providerOrOptions, address, pkOrSigner, cairoVersion, transactionVersion = api_exports.ETransactionVersion.V2) {\n    super(providerOrOptions);\n    this.address = address.toLowerCase();\n    this.signer = isString(pkOrSigner) || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n    if (cairoVersion) {\n      this.cairoVersion = cairoVersion.toString();\n    }\n    this.transactionVersion = transactionVersion;\n  }\n  // provided version or contract based preferred transactionVersion\n  getPreferredVersion(type12, type3) {\n    if (this.transactionVersion === api_exports.ETransactionVersion.V3)\n      return type3;\n    if (this.transactionVersion === api_exports.ETransactionVersion.V2)\n      return type12;\n    return api_exports.ETransactionVersion.V3;\n  }\n  async getNonce(blockIdentifier) {\n    return super.getNonceForAddress(this.address, blockIdentifier);\n  }\n  async getNonceSafe(nonce) {\n    try {\n      return toBigInt(nonce ?? await this.getNonce());\n    } catch (error) {\n      return 0n;\n    }\n  }\n  /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */\n  async getCairoVersion(classHash) {\n    if (!this.cairoVersion) {\n      const { cairo } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n      this.cairoVersion = cairo;\n    }\n    return this.cairoVersion;\n  }\n  async estimateFee(calls, estimateFeeDetails = {}) {\n    return this.estimateInvokeFee(calls, estimateFeeDetails);\n  }\n  async estimateInvokeFee(calls, details = {}) {\n    const {\n      nonce: providedNonce,\n      blockIdentifier,\n      version: providedVersion,\n      skipValidate = true\n    } = details;\n    const transactions = Array.isArray(calls) ? calls : [calls];\n    const nonce = toBigInt(providedNonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n    const signerDetails = {\n      ...v3Details(details),\n      walletAddress: this.address,\n      nonce,\n      maxFee: ZERO,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion(),\n      skipValidate\n    };\n    const invocation = await this.buildInvocation(transactions, signerDetails);\n    return super.getInvokeEstimateFee(\n      { ...invocation },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateDeclareFee(payload, details = {}) {\n    const {\n      blockIdentifier,\n      nonce: providedNonce,\n      version: providedVersion,\n      skipValidate = true\n    } = details;\n    const nonce = toBigInt(providedNonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      !isSierra(payload.contract) ? api_exports.ETransactionVersion.F1 : this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n    const declareContractTransaction = await this.buildDeclarePayload(payload, {\n      ...v3Details(details),\n      nonce,\n      chainId,\n      version,\n      walletAddress: this.address,\n      maxFee: ZERO,\n      cairoVersion: void 0,\n      // unused parameter\n      skipValidate\n    });\n    return super.getDeclareEstimateFee(\n      declareContractTransaction,\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateAccountDeployFee({\n    classHash,\n    addressSalt = 0,\n    constructorCalldata = [],\n    contractAddress\n  }, details = {}) {\n    const { blockIdentifier, version: providedVersion, skipValidate = true } = details;\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const nonce = ZERO;\n    const chainId = await this.getChainId();\n    const payload = await this.buildAccountDeployPayload(\n      { classHash, addressSalt, constructorCalldata, contractAddress },\n      {\n        ...v3Details(details),\n        nonce,\n        chainId,\n        version,\n        walletAddress: this.address,\n        // unused parameter\n        maxFee: ZERO,\n        cairoVersion: void 0,\n        // unused parameter,\n        skipValidate\n      }\n    );\n    return super.getDeployAccountEstimateFee(\n      { ...payload },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateDeployFee(payload, details = {}) {\n    const calls = this.buildUDCContractPayload(payload);\n    return this.estimateInvokeFee(calls, details);\n  }\n  async estimateFeeBulk(invocations, details = {}) {\n    const { nonce, blockIdentifier, version, skipValidate } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        api_exports.ETransactionVersion.F1,\n        // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3),\n          version\n        )\n        // sierra\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate\n    });\n    return super.getEstimateFeeBulk(accountInvocations, {\n      blockIdentifier,\n      skipValidate\n    });\n  }\n  async simulateTransaction(invocations, details = {}) {\n    const { nonce, blockIdentifier, skipValidate = true, skipExecute, version } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        api_exports.ETransactionVersion.V1,\n        // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3),\n          version\n        )\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate\n    });\n    return super.getSimulateTransaction(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n      skipExecute\n    });\n  }\n  async execute(transactions, arg2, transactionsDetail = {}) {\n    const details = arg2 === void 0 || Array.isArray(arg2) ? transactionsDetail : arg2;\n    const calls = Array.isArray(transactions) ? transactions : [transactions];\n    const nonce = toBigInt(details.nonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3),\n      // TODO: does this depend on cairo version ?\n      details.version\n    );\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      { type: \"INVOKE_FUNCTION\" /* INVOKE */, payload: transactions },\n      {\n        ...details,\n        version\n      }\n    );\n    const chainId = await this.getChainId();\n    const signerDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      walletAddress: this.address,\n      nonce,\n      maxFee: estimate.maxFee,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion()\n    };\n    const signature = await this.signer.signTransaction(calls, signerDetails);\n    const calldata = getExecuteCalldata(calls, await this.getCairoVersion());\n    return this.invokeFunction(\n      { contractAddress: this.address, calldata, signature },\n      {\n        ...v3Details(details),\n        resourceBounds: estimate.resourceBounds,\n        nonce,\n        maxFee: estimate.maxFee,\n        version\n      }\n    );\n  }\n  /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */\n  async declareIfNot(payload, transactionsDetail = {}) {\n    const declareContractPayload = extractContractHashes(payload);\n    try {\n      await this.getClassByHash(declareContractPayload.classHash);\n    } catch (error) {\n      return this.declare(payload, transactionsDetail);\n    }\n    return {\n      transaction_hash: \"\",\n      class_hash: declareContractPayload.classHash\n    };\n  }\n  async declare(payload, details = {}) {\n    const declareContractPayload = extractContractHashes(payload);\n    const { nonce, version: providedVersion } = details;\n    const version = toTransactionVersion(\n      !isSierra(payload.contract) ? api_exports.ETransactionVersion.V1 : this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3),\n      providedVersion\n    );\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: \"DECLARE\" /* DECLARE */,\n        payload: declareContractPayload\n      },\n      {\n        ...details,\n        version\n      }\n    );\n    const declareDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      nonce: toBigInt(nonce ?? await this.getNonce()),\n      version,\n      chainId: await this.getChainId(),\n      walletAddress: this.address,\n      cairoVersion: void 0\n    };\n    const declareContractTransaction = await this.buildDeclarePayload(\n      declareContractPayload,\n      declareDetails\n    );\n    return this.declareContract(declareContractTransaction, declareDetails);\n  }\n  async deploy(payload, details = {}) {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls, void 0, details);\n    return {\n      ...invokeResponse,\n      contract_address: addresses\n    };\n  }\n  async deployContract(payload, details = {}) {\n    const deployTx = await this.deploy(payload, details);\n    const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n    return parseUDCEvent(txReceipt);\n  }\n  async declareAndDeploy(payload, details = {}) {\n    const { constructorCalldata, salt, unique } = payload;\n    let declare = await this.declareIfNot(payload, details);\n    if (declare.transaction_hash !== \"\") {\n      const tx = await this.waitForTransaction(declare.transaction_hash);\n      declare = { ...declare, ...tx };\n    }\n    const deploy = await this.deployContract(\n      { classHash: declare.class_hash, salt, unique, constructorCalldata },\n      details\n    );\n    return { declare: { ...declare }, deploy };\n  }\n  deploySelf = this.deployAccount;\n  async deployAccount({\n    classHash,\n    constructorCalldata = [],\n    addressSalt = 0,\n    contractAddress: providedContractAddress\n  }, details = {}) {\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3),\n      details.version\n    );\n    const nonce = ZERO;\n    const chainId = await this.getChainId();\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */,\n        payload: {\n          classHash,\n          constructorCalldata: compiledCalldata,\n          addressSalt,\n          contractAddress\n        }\n      },\n      details\n    );\n    const signature = await this.signer.signDeployAccountTransaction({\n      ...v3Details(details),\n      classHash,\n      constructorCalldata: compiledCalldata,\n      contractAddress,\n      addressSalt,\n      chainId,\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      version,\n      nonce\n    });\n    return this.deployAccountContract(\n      { classHash, addressSalt, constructorCalldata, signature },\n      {\n        ...v3Details(details),\n        nonce,\n        resourceBounds: estimate.resourceBounds,\n        maxFee: estimate.maxFee,\n        version\n      }\n    );\n  }\n  async signMessage(typedData) {\n    return this.signer.signMessage(typedData, this.address);\n  }\n  async hashMessage(typedData) {\n    return getMessageHash(typedData, this.address);\n  }\n  async verifyMessageHash(hash, signature) {\n    try {\n      const resp = await this.callContract({\n        contractAddress: this.address,\n        entrypoint: \"isValidSignature\",\n        calldata: CallData.compile({\n          hash: toBigInt(hash).toString(),\n          signature: formatSignature(signature)\n        })\n      });\n      if (BigInt(resp[0]) === 0n) {\n        return false;\n      }\n      return true;\n    } catch (err) {\n      if ([\"argent/invalid-signature\", \"is invalid, with respect to the public key\"].some(\n        (errMessage) => err.message.includes(errMessage)\n      )) {\n        return false;\n      }\n      throw Error(`Signature verification request is rejected by the network: ${err}`);\n    }\n  }\n  async verifyMessage(typedData, signature) {\n    const hash = await this.hashMessage(typedData);\n    return this.verifyMessageHash(hash, signature);\n  }\n  /*\n   * Support methods\n   */\n  async getUniversalSuggestedFee(version, { type, payload }, details) {\n    let maxFee = 0;\n    let resourceBounds = estimateFeeToBounds(ZERO);\n    if (version === api_exports.ETransactionVersion.V3) {\n      resourceBounds = details.resourceBounds ?? (await this.getSuggestedFee({ type, payload }, details)).resourceBounds;\n    } else {\n      maxFee = details.maxFee ?? (await this.getSuggestedFee({ type, payload }, details)).suggestedMaxFee;\n    }\n    return {\n      maxFee,\n      resourceBounds\n    };\n  }\n  async getSuggestedFee({ type, payload }, details) {\n    let feeEstimate;\n    switch (type) {\n      case \"INVOKE_FUNCTION\" /* INVOKE */:\n        feeEstimate = await this.estimateInvokeFee(payload, details);\n        break;\n      case \"DECLARE\" /* DECLARE */:\n        feeEstimate = await this.estimateDeclareFee(payload, details);\n        break;\n      case \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */:\n        feeEstimate = await this.estimateAccountDeployFee(payload, details);\n        break;\n      case \"DEPLOY\" /* DEPLOY */:\n        feeEstimate = await this.estimateDeployFee(payload, details);\n        break;\n      default:\n        feeEstimate = {\n          gas_consumed: 0n,\n          gas_price: 0n,\n          overall_fee: ZERO,\n          unit: \"FRI\",\n          suggestedMaxFee: ZERO,\n          resourceBounds: estimateFeeToBounds(ZERO),\n          data_gas_consumed: 0n,\n          data_gas_price: 0n\n        };\n        break;\n    }\n    return feeEstimate;\n  }\n  async buildInvocation(call, details) {\n    const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n    const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];\n    return {\n      ...v3Details(details),\n      contractAddress: this.address,\n      calldata,\n      signature\n    };\n  }\n  async buildDeclarePayload(payload, details) {\n    const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n    const compressedCompiledContract = parseContract(contract);\n    if (typeof compiledClassHash === \"undefined\" && (details.version === api_exports.ETransactionVersion3.F3 || details.version === api_exports.ETransactionVersion3.V3)) {\n      throw Error(\"V3 Transaction work with Cairo1 Contracts and require compiledClassHash\");\n    }\n    const signature = !details.skipValidate ? await this.signer.signDeclareTransaction({\n      ...details,\n      ...v3Details(details),\n      classHash,\n      compiledClassHash,\n      // TODO: TS, cast because optional for v2 and required for v3, thrown if not present\n      senderAddress: details.walletAddress\n    }) : [];\n    return {\n      senderAddress: details.walletAddress,\n      signature,\n      contract: compressedCompiledContract,\n      compiledClassHash\n    };\n  }\n  async buildAccountDeployPayload({\n    classHash,\n    addressSalt = 0,\n    constructorCalldata = [],\n    contractAddress: providedContractAddress\n  }, details) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n    const signature = !details.skipValidate ? await this.signer.signDeployAccountTransaction({\n      ...details,\n      ...v3Details(details),\n      classHash,\n      contractAddress,\n      addressSalt,\n      constructorCalldata: compiledCalldata\n    }) : [];\n    return {\n      ...v3Details(details),\n      classHash,\n      addressSalt,\n      constructorCalldata: compiledCalldata,\n      signature\n    };\n  }\n  buildUDCContractPayload(payload) {\n    const calls = [].concat(payload).map((it) => {\n      const {\n        classHash,\n        salt = \"0\",\n        unique = true,\n        constructorCalldata = []\n      } = it;\n      const compiledConstructorCallData = CallData.compile(constructorCalldata);\n      return {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          salt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData\n        ]\n      };\n    });\n    return calls;\n  }\n  async accountInvocationsFactory(invocations, details) {\n    const { nonce, blockIdentifier, skipValidate = true } = details;\n    const safeNonce = await this.getNonceSafe(nonce);\n    const chainId = await this.getChainId();\n    const versions = details.versions.map((it) => toTransactionVersion(it));\n    const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n    const cairoVersion = invocations[0].type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n    return Promise.all(\n      [].concat(invocations).map(async (transaction, index) => {\n        const txPayload = \"payload\" in transaction ? transaction.payload : transaction;\n        const signerDetails = {\n          ...v3Details(details),\n          walletAddress: this.address,\n          nonce: toBigInt(Number(safeNonce) + index),\n          maxFee: ZERO,\n          chainId,\n          cairoVersion,\n          version: \"\",\n          skipValidate\n        };\n        const common = {\n          type: transaction.type,\n          nonce: toBigInt(Number(safeNonce) + index),\n          blockIdentifier,\n          version: \"\"\n        };\n        if (transaction.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildInvocation(\n            [].concat(txPayload),\n            signerDetails\n          );\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        if (transaction.type === \"DEPLOY\" /* DEPLOY */) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const calls = this.buildUDCContractPayload(txPayload);\n          const payload = await this.buildInvocation(calls, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            type: \"INVOKE_FUNCTION\" /* INVOKE */\n          };\n        }\n        if (transaction.type === \"DECLARE\" /* DECLARE */) {\n          const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        if (transaction.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n      })\n    );\n  }\n  async getStarkName(address = this.address, StarknetIdContract2) {\n    return super.getStarkName(address, StarknetIdContract2);\n  }\n};\n\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n\n// src/wallet/connect.ts\nvar connect_exports = {};\n__export(connect_exports, {\n  addDeclareTransaction: () => addDeclareTransaction,\n  addInvokeTransaction: () => addInvokeTransaction,\n  addStarknetChain: () => addStarknetChain,\n  deploymentData: () => deploymentData,\n  getPermissions: () => getPermissions,\n  onAccountChange: () => onAccountChange,\n  onNetworkChanged: () => onNetworkChanged,\n  requestAccounts: () => requestAccounts,\n  requestChainId: () => requestChainId,\n  signMessage: () => signMessage,\n  supportedSpecs: () => supportedSpecs,\n  switchStarknetChain: () => switchStarknetChain,\n  watchAsset: () => watchAsset\n});\nfunction requestAccounts(swo, silent_mode = false) {\n  return swo.request({\n    type: \"wallet_requestAccounts\",\n    params: {\n      silent_mode\n    }\n  });\n}\nfunction getPermissions(swo) {\n  return swo.request({ type: \"wallet_getPermissions\" });\n}\nfunction watchAsset(swo, asset) {\n  return swo.request({\n    type: \"wallet_watchAsset\",\n    params: asset\n  });\n}\nfunction addStarknetChain(swo, chain) {\n  return swo.request({\n    type: \"wallet_addStarknetChain\",\n    params: chain\n  });\n}\nfunction switchStarknetChain(swo, chainId) {\n  return swo.request({\n    type: \"wallet_switchStarknetChain\",\n    params: {\n      chainId\n    }\n  });\n}\nfunction requestChainId(swo) {\n  return swo.request({ type: \"wallet_requestChainId\" });\n}\nfunction deploymentData(swo) {\n  return swo.request({ type: \"wallet_deploymentData\" });\n}\nfunction addInvokeTransaction(swo, params) {\n  return swo.request({\n    type: \"wallet_addInvokeTransaction\",\n    params\n  });\n}\nfunction addDeclareTransaction(swo, params) {\n  return swo.request({\n    type: \"wallet_addDeclareTransaction\",\n    params\n  });\n}\nfunction signMessage(swo, typedData) {\n  return swo.request({\n    type: \"wallet_signTypedData\",\n    params: typedData\n  });\n}\nfunction supportedSpecs(swo) {\n  return swo.request({ type: \"wallet_supportedSpecs\" });\n}\nfunction onAccountChange(swo, callback) {\n  swo.on(\"accountsChanged\", callback);\n}\nfunction onNetworkChanged(swo, callback) {\n  swo.on(\"networkChanged\", callback);\n}\n\n// src/wallet/account.ts\nvar WalletAccount = class extends Account {\n  address = \"\";\n  walletProvider;\n  constructor(providerOrOptions, walletProvider, cairoVersion) {\n    super(providerOrOptions, \"\", \"\", cairoVersion);\n    this.walletProvider = walletProvider;\n    this.walletProvider.on(\"accountsChanged\", (res) => {\n      if (!res)\n        return;\n      this.address = res[0].toLowerCase();\n    });\n    this.walletProvider.on(\"networkChanged\", (res) => {\n      if (!res)\n        return;\n      this.channel.setChainId(res);\n    });\n    walletProvider.request({\n      type: \"wallet_requestAccounts\",\n      params: {\n        silent_mode: false\n      }\n    }).then((res) => {\n      this.address = res[0].toLowerCase();\n    });\n  }\n  /**\n   * WALLET EVENTS\n   */\n  onAccountChange(callback) {\n    onAccountChange(this.walletProvider, callback);\n  }\n  onNetworkChanged(callback) {\n    onNetworkChanged(this.walletProvider, callback);\n  }\n  /**\n   * WALLET SPECIFIC METHODS\n   */\n  requestAccounts(silentMode = false) {\n    return requestAccounts(this.walletProvider, silentMode);\n  }\n  getPermissions() {\n    return getPermissions(this.walletProvider);\n  }\n  switchStarknetChain(chainId) {\n    return switchStarknetChain(this.walletProvider, chainId);\n  }\n  watchAsset(asset) {\n    return watchAsset(this.walletProvider, asset);\n  }\n  addStarknetChain(chain) {\n    return addStarknetChain(this.walletProvider, chain);\n  }\n  /**\n   * ACCOUNT METHODS\n   */\n  execute(calls) {\n    const txCalls = [].concat(calls).map((it) => {\n      const { contractAddress, entrypoint, calldata } = it;\n      return {\n        contract_address: contractAddress,\n        entry_point: entrypoint,\n        calldata\n      };\n    });\n    const params = {\n      calls: txCalls\n    };\n    return addInvokeTransaction(this.walletProvider, params);\n  }\n  declare(payload) {\n    const declareContractPayload = extractContractHashes(payload);\n    const pContract = payload.contract;\n    const cairo1Contract = {\n      ...pContract,\n      abi: stringify2(pContract.abi)\n    };\n    if (!declareContractPayload.compiledClassHash) {\n      throw Error(\"compiledClassHash is required\");\n    }\n    const params = {\n      compiled_class_hash: declareContractPayload.compiledClassHash,\n      contract_class: cairo1Contract\n    };\n    return addDeclareTransaction(this.walletProvider, params);\n  }\n  async deploy(payload) {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls);\n    return {\n      ...invokeResponse,\n      contract_address: addresses\n    };\n  }\n  signMessage(typedData) {\n    return signMessage(this.walletProvider, typedData);\n  }\n  // TODO: MISSING ESTIMATES\n};\n\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n  getAbiEvents: () => getAbiEvents,\n  parseEvents: () => parseEvents\n});\nfunction getAbiEvents(abi) {\n  return abi.filter((abiEntry) => abiEntry.type === \"event\" && (abiEntry.size || abiEntry.kind !== \"enum\")).reduce((acc, abiEntry) => {\n    const entryName = abiEntry.name.slice(abiEntry.name.lastIndexOf(\":\") + 1);\n    const abiEntryMod = { ...abiEntry };\n    abiEntryMod.name = entryName;\n    return {\n      ...acc,\n      [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n    };\n  }, {});\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n  const ret = providerReceivedEvents.flat().reduce((acc, recEvent) => {\n    const abiEvent = abiEvents[recEvent.keys[0]];\n    if (!abiEvent) {\n      return acc;\n    }\n    const parsedEvent = {};\n    parsedEvent[abiEvent.name] = {};\n    recEvent.keys.shift();\n    const keysIter = recEvent.keys[Symbol.iterator]();\n    const dataIter = recEvent.data[Symbol.iterator]();\n    const abiEventKeys = abiEvent.members?.filter((it) => it.kind === \"key\") || abiEvent.keys;\n    const abiEventData = abiEvent.members?.filter((it) => it.kind === \"data\") || abiEvent.data;\n    abiEventKeys.forEach((key) => {\n      parsedEvent[abiEvent.name][key.name] = responseParser(\n        keysIter,\n        key,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    abiEventData.forEach((data) => {\n      parsedEvent[abiEvent.name][data.name] = responseParser(\n        dataIter,\n        data,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    acc.push(parsedEvent);\n    return acc;\n  }, []);\n  return ret;\n}\n\n// src/contract/default.ts\nvar splitArgsAndOptions = (args) => {\n  const options = [\n    \"blockIdentifier\",\n    \"parseRequest\",\n    \"parseResponse\",\n    \"formatResponse\",\n    \"maxFee\",\n    \"nonce\",\n    \"signature\",\n    \"addressSalt\"\n  ];\n  const lastArg = args[args.length - 1];\n  if (typeof lastArg === \"object\" && options.some((x) => x in lastArg)) {\n    return { args, options: args.pop() };\n  }\n  return { args };\n};\nfunction buildCall(contract, functionAbi) {\n  return async function(...args) {\n    const params = splitArgsAndOptions(args);\n    return contract.call(functionAbi.name, params.args, {\n      parseRequest: true,\n      parseResponse: true,\n      ...params.options\n    });\n  };\n}\nfunction buildInvoke(contract, functionAbi) {\n  return async function(...args) {\n    const params = splitArgsAndOptions(args);\n    return contract.invoke(functionAbi.name, params.args, {\n      parseRequest: true,\n      ...params.options\n    });\n  };\n}\nfunction buildDefault(contract, functionAbi) {\n  if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n    return buildCall(contract, functionAbi);\n  }\n  return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n  return function(...args) {\n    return contract.populate(functionAbi.name, args);\n  };\n}\nfunction buildEstimate(contract, functionAbi) {\n  return function(...args) {\n    return contract.estimate(functionAbi.name, args);\n  };\n}\nfunction getCalldata(args, callback) {\n  if (Array.isArray(args) && \"__compiled__\" in args)\n    return args;\n  if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0])\n    return args[0];\n  return callback();\n}\nvar Contract = class {\n  abi;\n  address;\n  providerOrAccount;\n  deployTransactionHash;\n  structs;\n  events;\n  functions;\n  callStatic;\n  populateTransaction;\n  estimateFee;\n  callData;\n  /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */\n  constructor(abi, address, providerOrAccount = defaultProvider) {\n    this.address = address && address.toLowerCase();\n    this.providerOrAccount = providerOrAccount;\n    this.callData = new CallData(abi);\n    this.structs = CallData.getAbiStruct(abi);\n    this.events = getAbiEvents(abi);\n    const parser = createAbiParser(abi);\n    this.abi = parser.getLegacyFormat();\n    const options = { enumerable: true, value: {}, writable: false };\n    Object.defineProperties(this, {\n      functions: { enumerable: true, value: {}, writable: false },\n      callStatic: { enumerable: true, value: {}, writable: false },\n      populateTransaction: { enumerable: true, value: {}, writable: false },\n      estimateFee: { enumerable: true, value: {}, writable: false }\n    });\n    this.abi.forEach((abiElement) => {\n      if (abiElement.type !== \"function\")\n        return;\n      const signature = abiElement.name;\n      if (!this[signature]) {\n        Object.defineProperty(this, signature, {\n          ...options,\n          value: buildDefault(this, abiElement)\n        });\n      }\n      if (!this.functions[signature]) {\n        Object.defineProperty(this.functions, signature, {\n          ...options,\n          value: buildDefault(this, abiElement)\n        });\n      }\n      if (!this.callStatic[signature]) {\n        Object.defineProperty(this.callStatic, signature, {\n          ...options,\n          value: buildCall(this, abiElement)\n        });\n      }\n      if (!this.populateTransaction[signature]) {\n        Object.defineProperty(this.populateTransaction, signature, {\n          ...options,\n          value: buildPopulate(this, abiElement)\n        });\n      }\n      if (!this.estimateFee[signature]) {\n        Object.defineProperty(this.estimateFee, signature, {\n          ...options,\n          value: buildEstimate(this, abiElement)\n        });\n      }\n    });\n  }\n  attach(address) {\n    this.address = address;\n  }\n  connect(providerOrAccount) {\n    this.providerOrAccount = providerOrAccount;\n  }\n  async deployed() {\n    if (this.deployTransactionHash) {\n      await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n      this.deployTransactionHash = void 0;\n    }\n    return this;\n  }\n  async call(method, args = [], {\n    parseRequest = true,\n    parseResponse = true,\n    formatResponse = void 0,\n    blockIdentifier = void 0\n  } = {}) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(\"CALL\" /* CALL */, method, args);\n        return this.callData.compile(method, args);\n      }\n      console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n      return args;\n    });\n    return this.providerOrAccount.callContract(\n      {\n        contractAddress: this.address,\n        calldata,\n        entrypoint: method\n      },\n      blockIdentifier\n    ).then((it) => {\n      if (!parseResponse) {\n        return it;\n      }\n      if (formatResponse) {\n        return this.callData.format(method, it, formatResponse);\n      }\n      return this.callData.parse(method, it);\n    });\n  }\n  invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(\"INVOKE\" /* INVOKE */, method, args);\n        return this.callData.compile(method, args);\n      }\n      console.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n      return args;\n    });\n    const invocation = {\n      contractAddress: this.address,\n      calldata,\n      entrypoint: method\n    };\n    if (\"execute\" in this.providerOrAccount) {\n      return this.providerOrAccount.execute(invocation, void 0, {\n        maxFee,\n        nonce\n      });\n    }\n    if (!nonce)\n      throw new Error(`Nonce is required when invoking a function without an account`);\n    console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n    return this.providerOrAccount.invokeFunction(\n      {\n        ...invocation,\n        signature\n      },\n      {\n        nonce\n      }\n    );\n  }\n  async estimate(method, args = []) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    if (!getCalldata(args, () => false)) {\n      this.callData.validate(\"INVOKE\" /* INVOKE */, method, args);\n    }\n    const invocation = this.populate(method, args);\n    if (\"estimateInvokeFee\" in this.providerOrAccount) {\n      return this.providerOrAccount.estimateInvokeFee(invocation);\n    }\n    throw Error(\"Contract must be connected to the account contract to estimate\");\n  }\n  populate(method, args = []) {\n    const calldata = getCalldata(args, () => this.callData.compile(method, args));\n    return {\n      contractAddress: this.address,\n      entrypoint: method,\n      calldata\n    };\n  }\n  parseEvents(receipt) {\n    return parseEvents(\n      receipt.events?.filter(\n        (event) => cleanHex(event.from_address) === cleanHex(this.address),\n        []\n      ) || [],\n      this.events,\n      this.structs,\n      CallData.getAbiEnum(this.abi)\n    );\n  }\n  isCairo1() {\n    return cairo_exports.isCairo1Abi(this.abi);\n  }\n  async getVersion() {\n    return this.providerOrAccount.getContractVersion(this.address);\n  }\n  typedv2(tAbi) {\n    return this;\n  }\n};\n\n// src/contract/interface.ts\nvar ContractInterface = class {\n  functions;\n  callStatic;\n  populateTransaction;\n  estimateFee;\n};\n\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n  compiledContract;\n  account;\n  abi;\n  classHash;\n  casm;\n  compiledClassHash;\n  CallData;\n  /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */\n  constructor(params) {\n    this.compiledContract = params.compiledContract;\n    this.account = params.account;\n    this.casm = params.casm;\n    this.abi = params.abi ?? params.compiledContract.abi;\n    this.classHash = params.classHash;\n    this.compiledClassHash = params.compiledClassHash;\n    this.CallData = new CallData(this.abi);\n  }\n  /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */\n  async deploy(...args) {\n    const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);\n    const constructorCalldata = getCalldata(param, () => {\n      if (options.parseRequest) {\n        this.CallData.validate(\"DEPLOY\" /* DEPLOY */, \"constructor\", param);\n        return this.CallData.compile(\"constructor\", param);\n      }\n      console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n      return param;\n    });\n    const {\n      deploy: { contract_address, transaction_hash }\n    } = await this.account.declareAndDeploy({\n      contract: this.compiledContract,\n      casm: this.casm,\n      classHash: this.classHash,\n      compiledClassHash: this.compiledClassHash,\n      constructorCalldata,\n      salt: options.addressSalt\n    });\n    assert(Boolean(contract_address), \"Deployment of the contract failed\");\n    const contractInstance = new Contract(\n      this.compiledContract.abi,\n      contract_address,\n      this.account\n    );\n    contractInstance.deployTransactionHash = transaction_hash;\n    return contractInstance;\n  }\n  /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */\n  connect(account) {\n    this.account = account;\n    return this;\n  }\n  /**\n   * Attaches current abi and account to the new address\n   */\n  attach(address) {\n    return new Contract(this.abi, address, this.account);\n  }\n  // ethers.js' getDeployTransaction can't be supported as it requires the account or signer to return a signed transaction which is not possible with the current implementation\n};\n\n// src/utils/address.ts\n\nfunction addAddressPadding(address) {\n  return addHexPrefix(removeHexPrefix(toHex(address)).padStart(64, \"0\"));\n}\nfunction validateAndParseAddress(address) {\n  assertInRange(address, ZERO, ADDR_BOUND - 1n, \"Starknet Address\");\n  const result = addAddressPadding(address);\n  if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error(\"Invalid Address Format\");\n  }\n  return result;\n}\nfunction getChecksumAddress(address) {\n  const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n  const hex = removeHexPrefix(keccakBn(address));\n  const hashed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(hex.padStart(64, \"0\"));\n  for (let i = 0; i < chars.length; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 15) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n  return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n  return getChecksumAddress(address) === address;\n}\n\n// src/utils/url.ts\n\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nfunction isUrl(s) {\n  if (!s) {\n    return false;\n  }\n  if (typeof s !== \"string\") {\n    return false;\n  }\n  const match = s.match(protocolAndDomainRE);\n  if (!match) {\n    return false;\n  }\n  const everythingAfterProtocol = match[1];\n  if (!everythingAfterProtocol) {\n    return false;\n  }\n  if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n    return true;\n  }\n  return false;\n}\nfunction buildUrl(baseUrl, defaultPath, urlOrPath) {\n  return isUrl(urlOrPath) ? urlOrPath : url_join__WEBPACK_IMPORTED_MODULE_14__(baseUrl, urlOrPath ?? defaultPath);\n}\n\n// src/index.ts\nvar number = num_exports;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBUztBQUM1QixDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQ0FBbUM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJB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QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJLEdBQUcsVUFBVSwyQkFBMkIsSUFBSSxHQUFHLFdBQVcseUJBQXlCLGlCQUFpQjtBQUNsSjtBQUNBLEdBQUc7QUFDSDtBQUNBLG1EQUFtRCxJQUFJLEdBQUcsV0FBVyxXQUFXLElBQUksR0FBRyxVQUFVO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsaUVBQWlFLGVBQWU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0VBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQ0FBMEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2QkFBNkI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUNBQXlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixZQUFZO0FBQzVGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBaUI7QUFDckM7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0NBQU87QUFDL0M7O0FBRUE7QUFDQTtBQTZGRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2Fpcm8xLWpzLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L2Rpc3QvaW5kZXgubWpzP2U2ODIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZCwgc2Vjb25kVGFyZ2V0KSA9PiAoX19jb3B5UHJvcHModGFyZ2V0LCBtb2QsIFwiZGVmYXVsdFwiKSwgc2Vjb25kVGFyZ2V0ICYmIF9fY29weVByb3BzKHNlY29uZFRhcmdldCwgbW9kLCBcImRlZmF1bHRcIikpO1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgY29uc3RhbnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbnN0YW50c19leHBvcnRzLCB7XG4gIEFERFJfQk9VTkQ6ICgpID0+IEFERFJfQk9VTkQsXG4gIEFQSV9WRVJTSU9OOiAoKSA9PiBBUElfVkVSU0lPTixcbiAgQmFzZVVybDogKCkgPT4gQmFzZVVybCxcbiAgSVNfQlJPV1NFUjogKCkgPT4gSVNfQlJPV1NFUixcbiAgTUFTS18yNTA6ICgpID0+IE1BU0tfMjUwLFxuICBNQVhfU1RPUkFHRV9JVEVNX1NJWkU6ICgpID0+IE1BWF9TVE9SQUdFX0lURU1fU0laRSxcbiAgTmV0d29ya05hbWU6ICgpID0+IE5ldHdvcmtOYW1lLFxuICBQUklNRTogKCkgPT4gUFJJTUUsXG4gIFJBTkdFX0ZFTFQ6ICgpID0+IFJBTkdFX0ZFTFQsXG4gIFJBTkdFX0kxMjg6ICgpID0+IFJBTkdFX0kxMjgsXG4gIFJBTkdFX1UxMjg6ICgpID0+IFJBTkdFX1UxMjgsXG4gIFJQQ19ERUZBVUxUX1ZFUlNJT046ICgpID0+IFJQQ19ERUZBVUxUX1ZFUlNJT04sXG4gIFJQQ19OT0RFUzogKCkgPT4gUlBDX05PREVTLFxuICBTdGFya25ldENoYWluSWQ6ICgpID0+IFN0YXJrbmV0Q2hhaW5JZCxcbiAgVEVYVF9UT19GRUxUX01BWF9MRU46ICgpID0+IFRFWFRfVE9fRkVMVF9NQVhfTEVOLFxuICBUUkFOU0FDVElPTl9WRVJTSU9OOiAoKSA9PiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLFxuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXg6ICgpID0+IFRyYW5zYWN0aW9uSGFzaFByZWZpeCxcbiAgVURDOiAoKSA9PiBVREMsXG4gIFpFUk86ICgpID0+IFpFUk8sXG4gIGZlZU1hcmdpblBlcmNlbnRhZ2U6ICgpID0+IGZlZU1hcmdpblBlcmNlbnRhZ2Vcbn0pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL2luZGV4LnRzXG52YXIgYXBpX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGFwaV9leHBvcnRzLCB7XG4gIEpSUEM6ICgpID0+IGpzb25ycGNfZXhwb3J0cyxcbiAgUlBDU1BFQzA2OiAoKSA9PiBycGNzcGVjXzBfNl9leHBvcnRzLFxuICBSUENTUEVDMDc6ICgpID0+IFJQQ1NQRUMwN1xufSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvanNvbnJwYy9pbmRleC50c1xudmFyIGpzb25ycGNfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWNfMF82L2luZGV4LnRzXG52YXIgcnBjc3BlY18wXzZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocnBjc3BlY18wXzZfZXhwb3J0cywge1xuICBFQmxvY2tUYWc6ICgpID0+IEVCbG9ja1RhZyxcbiAgRURBTW9kZTogKCkgPT4gRURBTW9kZSxcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlOiAoKSA9PiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gIEVTaW11bGF0aW9uRmxhZzogKCkgPT4gRVNpbXVsYXRpb25GbGFnLFxuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBFVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uVHlwZTogKCkgPT4gRVRyYW5zYWN0aW9uVHlwZSxcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbixcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI6ICgpID0+IEVUcmFuc2FjdGlvblZlcnNpb24yLFxuICBFVHJhbnNhY3Rpb25WZXJzaW9uMzogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbjMsXG4gIEVycm9yczogKCkgPT4gZXJyb3JzX2V4cG9ydHMsXG4gIFNQRUM6ICgpID0+IGNvbXBvbmVudHNfZXhwb3J0c1xufSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvZXJyb3JzLnRzXG52YXIgZXJyb3JzX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGNzcGVjXzBfNi9jb21wb25lbnRzLnRzXG52YXIgY29tcG9uZW50c19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvbm9uc3BlYy50c1xudmFyIEVUcmFuc2FjdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25UeXBlMikgPT4ge1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFQ0xBUkVcIl0gPSBcIkRFQ0xBUkVcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCJERVBMT1lfQUNDT1VOVFwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIklOVk9LRVwiXSA9IFwiSU5WT0tFXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiTDFfSEFORExFUlwiXSA9IFwiTDFfSEFORExFUlwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uVHlwZTI7XG59KShFVHJhbnNhY3Rpb25UeXBlIHx8IHt9KTtcbnZhciBFU2ltdWxhdGlvbkZsYWcgPSAvKiBAX19QVVJFX18gKi8gKChFU2ltdWxhdGlvbkZsYWcyKSA9PiB7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX1ZBTElEQVRFXCJdID0gXCJTS0lQX1ZBTElEQVRFXCI7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX0ZFRV9DSEFSR0VcIl0gPSBcIlNLSVBfRkVFX0NIQVJHRVwiO1xuICByZXR1cm4gRVNpbXVsYXRpb25GbGFnMjtcbn0pKEVTaW11bGF0aW9uRmxhZyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25TdGF0dXMyO1xufSkoRVRyYW5zYWN0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czI7XG59KShFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiU1VDQ0VFREVEXCJdID0gXCJTVUNDRUVERURcIjtcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMjtcbn0pKEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyB8fCB7fSk7XG52YXIgRUJsb2NrVGFnID0gLyogQF9fUFVSRV9fICovICgoRUJsb2NrVGFnMikgPT4ge1xuICBFQmxvY2tUYWcyW1wiTEFURVNUXCJdID0gXCJsYXRlc3RcIjtcbiAgRUJsb2NrVGFnMltcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgcmV0dXJuIEVCbG9ja1RhZzI7XG59KShFQmxvY2tUYWcgfHwge30pO1xudmFyIEVEYXRhQXZhaWxhYmlsaXR5TW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVEYXRhQXZhaWxhYmlsaXR5TW9kZTMpID0+IHtcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlM1tcIkwxXCJdID0gXCJMMVwiO1xuICBFRGF0YUF2YWlsYWJpbGl0eU1vZGUzW1wiTDJcIl0gPSBcIkwyXCI7XG4gIHJldHVybiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUzO1xufSkoRURhdGFBdmFpbGFiaWxpdHlNb2RlIHx8IHt9KTtcbnZhciBFREFNb2RlID0gLyogQF9fUFVSRV9fICovICgoRURBTW9kZTQpID0+IHtcbiAgRURBTW9kZTRbRURBTW9kZTRbXCJMMVwiXSA9IDBdID0gXCJMMVwiO1xuICBFREFNb2RlNFtFREFNb2RlNFtcIkwyXCJdID0gMV0gPSBcIkwyXCI7XG4gIHJldHVybiBFREFNb2RlNDtcbn0pKEVEQU1vZGUgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvblZlcnNpb24gPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25WZXJzaW9uMTApID0+IHtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiVjBcIl0gPSBcIjB4MFwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJWMVwiXSA9IFwiMHgxXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24xMFtcIlYyXCJdID0gXCIweDJcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiVjNcIl0gPSBcIjB4M1wiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJGMFwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiRjFcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24xMFtcIkYyXCJdID0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMlwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJGM1wiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblZlcnNpb24xMDtcbn0pKEVUcmFuc2FjdGlvblZlcnNpb24gfHwge30pO1xudmFyIEVUcmFuc2FjdGlvblZlcnNpb24yID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uVmVyc2lvbjI1KSA9PiB7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24yNVtcIlYwXCJdID0gXCIweDBcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI1W1wiVjFcIl0gPSBcIjB4MVwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMjVbXCJWMlwiXSA9IFwiMHgyXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24yNVtcIkYwXCJdID0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMjVbXCJGMVwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI1W1wiRjJcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25WZXJzaW9uMjU7XG59KShFVHJhbnNhY3Rpb25WZXJzaW9uMiB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uVmVyc2lvbjMgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25WZXJzaW9uMzYpID0+IHtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjM2W1wiVjNcIl0gPSBcIjB4M1wiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMzZbXCJGM1wiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblZlcnNpb24zNjtcbn0pKEVUcmFuc2FjdGlvblZlcnNpb24zIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9pbmRleC50c1xuX19yZUV4cG9ydChhcGlfZXhwb3J0cywgc3RhcmtuZXRfdHlwZXNfMDdfc3Rhcik7XG5pbXBvcnQgKiBhcyBSUENTUEVDMDcgZnJvbSBcInN0YXJrbmV0LXR5cGVzLTA3XCI7XG5pbXBvcnQgKiBhcyBzdGFya25ldF90eXBlc18wN19zdGFyIGZyb20gXCJzdGFya25ldC10eXBlcy0wN1wiO1xuXG4vLyBzcmMvdXRpbHMvZW5jb2RlLnRzXG52YXIgZW5jb2RlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVuY29kZV9leHBvcnRzLCB7XG4gIElTX0JST1dTRVI6ICgpID0+IElTX0JST1dTRVIsXG4gIGFkZEhleFByZWZpeDogKCkgPT4gYWRkSGV4UHJlZml4LFxuICBhcnJheUJ1ZmZlclRvU3RyaW5nOiAoKSA9PiBhcnJheUJ1ZmZlclRvU3RyaW5nLFxuICBhdG9iVW5pdmVyc2FsOiAoKSA9PiBhdG9iVW5pdmVyc2FsLFxuICBidG9hVW5pdmVyc2FsOiAoKSA9PiBidG9hVW5pdmVyc2FsLFxuICBidWYyaGV4OiAoKSA9PiBidWYyaGV4LFxuICBjYWxjQnl0ZUxlbmd0aDogKCkgPT4gY2FsY0J5dGVMZW5ndGgsXG4gIHBhZExlZnQ6ICgpID0+IHBhZExlZnQsXG4gIHBhc2NhbFRvU25ha2U6ICgpID0+IHBhc2NhbFRvU25ha2UsXG4gIHJlbW92ZUhleFByZWZpeDogKCkgPT4gcmVtb3ZlSGV4UHJlZml4LFxuICBzYW5pdGl6ZUJ5dGVzOiAoKSA9PiBzYW5pdGl6ZUJ5dGVzLFxuICBzYW5pdGl6ZUhleDogKCkgPT4gc2FuaXRpemVIZXgsXG4gIHN0cmluZ1RvQXJyYXlCdWZmZXI6ICgpID0+IHN0cmluZ1RvQXJyYXlCdWZmZXIsXG4gIHV0ZjhUb0FycmF5OiAoKSA9PiB1dGY4VG9BcnJheVxufSk7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBTVFJJTkdfWkVSTyA9IFwiMFwiO1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb1N0cmluZyhhcnJheSkge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpLnJlZHVjZSgoZGF0YSwgYnl0ZSkgPT4gZGF0YSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSksIFwiXCIpO1xufVxuZnVuY3Rpb24gdXRmOFRvQXJyYXkoc3RyKSB7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlCdWZmZXIoc3RyKSB7XG4gIHJldHVybiB1dGY4VG9BcnJheShzdHIpO1xufVxuZnVuY3Rpb24gYXRvYlVuaXZlcnNhbChhKSB7XG4gIHJldHVybiBiYXNlNjQuZGVjb2RlKGEpO1xufVxuZnVuY3Rpb24gYnRvYVVuaXZlcnNhbChiKSB7XG4gIHJldHVybiBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGIpKTtcbn1cbmZ1bmN0aW9uIGJ1ZjJoZXgoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIucmVkdWNlKChyLCB4KSA9PiByICsgeC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUhleFByZWZpeChoZXgpIHtcbiAgcmV0dXJuIGhleC5yZXBsYWNlKC9eMHgvaSwgXCJcIik7XG59XG5mdW5jdGlvbiBhZGRIZXhQcmVmaXgoaGV4KSB7XG4gIHJldHVybiBgMHgke3JlbW92ZUhleFByZWZpeChoZXgpfWA7XG59XG5mdW5jdGlvbiBwYWRTdHJpbmcoc3RyLCBsZW5ndGgsIGxlZnQsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICBjb25zdCBkaWZmID0gbGVuZ3RoIC0gc3RyLmxlbmd0aDtcbiAgbGV0IHJlc3VsdCA9IHN0cjtcbiAgaWYgKGRpZmYgPiAwKSB7XG4gICAgY29uc3QgcGFkID0gcGFkZGluZy5yZXBlYXQoZGlmZik7XG4gICAgcmVzdWx0ID0gbGVmdCA/IHBhZCArIHN0ciA6IHN0ciArIHBhZDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFkTGVmdChzdHIsIGxlbmd0aCwgcGFkZGluZyA9IFNUUklOR19aRVJPKSB7XG4gIHJldHVybiBwYWRTdHJpbmcoc3RyLCBsZW5ndGgsIHRydWUsIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gY2FsY0J5dGVMZW5ndGgoc3RyLCBieXRlU2l6ZSA9IDgpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IHN0cjtcbiAgY29uc3QgcmVtYWluZGVyID0gbGVuZ3RoICUgYnl0ZVNpemU7XG4gIHJldHVybiByZW1haW5kZXIgPyAobGVuZ3RoIC0gcmVtYWluZGVyKSAvIGJ5dGVTaXplICogYnl0ZVNpemUgKyBieXRlU2l6ZSA6IGxlbmd0aDtcbn1cbmZ1bmN0aW9uIHNhbml0aXplQnl0ZXMoc3RyLCBieXRlU2l6ZSA9IDgsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICByZXR1cm4gcGFkTGVmdChzdHIsIGNhbGNCeXRlTGVuZ3RoKHN0ciwgYnl0ZVNpemUpLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplSGV4KGhleCkge1xuICBoZXggPSByZW1vdmVIZXhQcmVmaXgoaGV4KTtcbiAgaGV4ID0gc2FuaXRpemVCeXRlcyhoZXgsIDIpO1xuICBpZiAoaGV4KSB7XG4gICAgaGV4ID0gYWRkSGV4UHJlZml4KGhleCk7XG4gIH1cbiAgcmV0dXJuIGhleDtcbn1cbnZhciBwYXNjYWxUb1NuYWtlID0gKHRleHQpID0+IC9bYS16XS8udGVzdCh0ZXh0KSA/IHRleHQuc3BsaXQoLyg/PVtBLVpdKS8pLmpvaW4oXCJfXCIpLnRvVXBwZXJDYXNlKCkgOiB0ZXh0O1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgVEVYVF9UT19GRUxUX01BWF9MRU4gPSAzMTtcbnZhciBaRVJPID0gMG47XG52YXIgTUFTS18yNTAgPSAybiAqKiAyNTBuIC0gMW47XG52YXIgQVBJX1ZFUlNJT04gPSBaRVJPO1xudmFyIFBSSU1FID0gMm4gKiogMjUxbiArIDE3biAqIDJuICoqIDE5Mm4gKyAxbjtcbnZhciBNQVhfU1RPUkFHRV9JVEVNX1NJWkUgPSAyNTZuO1xudmFyIEFERFJfQk9VTkQgPSAybiAqKiAyNTFuIC0gTUFYX1NUT1JBR0VfSVRFTV9TSVpFO1xudmFyIHJhbmdlID0gKG1pbiwgbWF4KSA9PiAoeyBtaW4sIG1heCB9KTtcbnZhciBSQU5HRV9GRUxUID0gcmFuZ2UoWkVSTywgUFJJTUUgLSAxbik7XG52YXIgUkFOR0VfSTEyOCA9IHJhbmdlKC0oMm4gKiogMTI3biksIDJuICoqIDEyN24gLSAxbik7XG52YXIgUkFOR0VfVTEyOCA9IHJhbmdlKFpFUk8sIDJuICoqIDEyOG4gLSAxbik7XG52YXIgQmFzZVVybCA9IC8qIEBfX1BVUkVfXyAqLyAoKEJhc2VVcmwyKSA9PiB7XG4gIEJhc2VVcmwyW1wiU05fTUFJTlwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1tYWlubmV0LnN0YXJrbmV0LmlvXCI7XG4gIEJhc2VVcmwyW1wiU05fR09FUkxJXCJdID0gXCJodHRwczovL2FscGhhNC5zdGFya25ldC5pb1wiO1xuICBCYXNlVXJsMltcIlNOX1NFUE9MSUFcIl0gPSBcImh0dHBzOi8vYWxwaGEtc2Vwb2xpYS5zdGFya25ldC5pb1wiO1xuICByZXR1cm4gQmFzZVVybDI7XG59KShCYXNlVXJsIHx8IHt9KTtcbnZhciBOZXR3b3JrTmFtZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ldHdvcmtOYW1lMikgPT4ge1xuICBOZXR3b3JrTmFtZTJbXCJTTl9NQUlOXCJdID0gXCJTTl9NQUlOXCI7XG4gIE5ldHdvcmtOYW1lMltcIlNOX0dPRVJMSVwiXSA9IFwiU05fR09FUkxJXCI7XG4gIE5ldHdvcmtOYW1lMltcIlNOX1NFUE9MSUFcIl0gPSBcIlNOX1NFUE9MSUFcIjtcbiAgcmV0dXJuIE5ldHdvcmtOYW1lMjtcbn0pKE5ldHdvcmtOYW1lIHx8IHt9KTtcbnZhciBTdGFya25ldENoYWluSWQgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldENoYWluSWQ2KSA9PiB7XG4gIFN0YXJrbmV0Q2hhaW5JZDZbXCJTTl9NQUlOXCJdID0gXCIweDUzNGU1ZjRkNDE0OTRlXCI7XG4gIFN0YXJrbmV0Q2hhaW5JZDZbXCJTTl9HT0VSTElcIl0gPSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCI7XG4gIFN0YXJrbmV0Q2hhaW5JZDZbXCJTTl9TRVBPTElBXCJdID0gXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCI7XG4gIHJldHVybiBTdGFya25ldENoYWluSWQ2O1xufSkoU3RhcmtuZXRDaGFpbklkIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkhhc2hQcmVmaXggPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkhhc2hQcmVmaXgyKSA9PiB7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERUNMQVJFXCJdID0gXCIweDY0NjU2MzZjNjE3MjY1XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERVBMT1lcIl0gPSBcIjB4NjQ2NTcwNmM2Zjc5XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERVBMT1lfQUNDT1VOVFwiXSA9IFwiMHg2NDY1NzA2YzZmNzk1ZjYxNjM2MzZmNzU2ZTc0XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJJTlZPS0VcIl0gPSBcIjB4Njk2ZTc2NmY2YjY1XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJMMV9IQU5ETEVSXCJdID0gXCIweDZjMzE1ZjY4NjE2ZTY0NmM2NTcyXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyO1xufSkoVHJhbnNhY3Rpb25IYXNoUHJlZml4IHx8IHt9KTtcbnZhciBmZWVNYXJnaW5QZXJjZW50YWdlID0gLyogQF9fUFVSRV9fICovICgoZmVlTWFyZ2luUGVyY2VudGFnZTIpID0+IHtcbiAgZmVlTWFyZ2luUGVyY2VudGFnZTJbZmVlTWFyZ2luUGVyY2VudGFnZTJbXCJMMV9CT1VORF9NQVhfQU1PVU5UXCJdID0gNTBdID0gXCJMMV9CT1VORF9NQVhfQU1PVU5UXCI7XG4gIGZlZU1hcmdpblBlcmNlbnRhZ2UyW2ZlZU1hcmdpblBlcmNlbnRhZ2UyW1wiTDFfQk9VTkRfTUFYX1BSSUNFX1BFUl9VTklUXCJdID0gNTBdID0gXCJMMV9CT1VORF9NQVhfUFJJQ0VfUEVSX1VOSVRcIjtcbiAgZmVlTWFyZ2luUGVyY2VudGFnZTJbZmVlTWFyZ2luUGVyY2VudGFnZTJbXCJNQVhfRkVFXCJdID0gNTBdID0gXCJNQVhfRkVFXCI7XG4gIHJldHVybiBmZWVNYXJnaW5QZXJjZW50YWdlMjtcbn0pKGZlZU1hcmdpblBlcmNlbnRhZ2UgfHwge30pO1xudmFyIFVEQyA9IHtcbiAgQUREUkVTUzogXCIweDA0MWE3OGU3NDFlNWFmMmZlYzM0YjY5NTY3OWJjNjg5MTc0MjQzOWY3YWZiODQ4NGVjZDc3NjY2NjFhZDAyYmZcIixcbiAgRU5UUllQT0lOVDogXCJkZXBsb3lDb250cmFjdFwiXG59O1xudmFyIFJQQ19ERUZBVUxUX1ZFUlNJT04gPSBcInYwXzdcIjtcbnZhciBSUENfTk9ERVMgPSB7XG4gIFNOX0dPRVJMSTogW1xuICAgIGBodHRwczovL3N0YXJrbmV0LXRlc3RuZXQucHVibGljLmJsYXN0YXBpLmlvL3JwYy8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YCxcbiAgICBgaHR0cHM6Ly9mcmVlLXJwYy5uZXRoZXJtaW5kLmlvL2dvZXJsaS1qdW5vLyR7UlBDX0RFRkFVTFRfVkVSU0lPTn1gXG4gIF0sXG4gIFNOX01BSU46IFtcbiAgICBgaHR0cHM6Ly9zdGFya25ldC1tYWlubmV0LnB1YmxpYy5ibGFzdGFwaS5pby9ycGMvJHtSUENfREVGQVVMVF9WRVJTSU9OfWAsXG4gICAgYGh0dHBzOi8vZnJlZS1ycGMubmV0aGVybWluZC5pby9tYWlubmV0LWp1bm8vJHtSUENfREVGQVVMVF9WRVJTSU9OfWBcbiAgXSxcbiAgU05fU0VQT0xJQTogW1xuICAgIGBodHRwczovL3N0YXJrbmV0LXNlcG9saWEucHVibGljLmJsYXN0YXBpLmlvL3JwYy8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YCxcbiAgICBgaHR0cHM6Ly9mcmVlLXJwYy5uZXRoZXJtaW5kLmlvL3NlcG9saWEtanVuby8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YFxuICBdXG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvZXJyb3JzLnRzXG5mdW5jdGlvbiBmaXhTdGFjayh0YXJnZXQsIGZuID0gdGFyZ2V0LmNvbnN0cnVjdG9yKSB7XG4gIGNvbnN0IHsgY2FwdHVyZVN0YWNrVHJhY2UgfSA9IEVycm9yO1xuICBjYXB0dXJlU3RhY2tUcmFjZSAmJiBjYXB0dXJlU3RhY2tUcmFjZSh0YXJnZXQsIGZuKTtcbn1cbmZ1bmN0aW9uIGZpeFByb3RvKHRhcmdldCwgcHJvdG90eXBlKSB7XG4gIGNvbnN0IHsgc2V0UHJvdG90eXBlT2YgfSA9IE9iamVjdDtcbiAgc2V0UHJvdG90eXBlT2YgPyBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvdHlwZSkgOiB0YXJnZXQuX19wcm90b19fID0gcHJvdG90eXBlO1xufVxudmFyIEN1c3RvbUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWU7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIHZhbHVlOiBuZXcudGFyZ2V0Lm5hbWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGZpeFByb3RvKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICBmaXhTdGFjayh0aGlzKTtcbiAgfVxufTtcbnZhciBMaWJyYXJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEN1c3RvbUVycm9yIHtcbn07XG52YXIgR2F0ZXdheUVycm9yID0gY2xhc3MgZXh0ZW5kcyBMaWJyYXJ5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvckNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgfVxufTtcbnZhciBIdHRwRXJyb3IgPSBjbGFzcyBleHRlbmRzIExpYnJhcnlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yQ29kZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyb3JDb2RlO1xuICB9XG59O1xuXG4vLyBzcmMvY2hhbm5lbC9ycGNfMF82LnRzXG52YXIgcnBjXzBfNl9leHBvcnRzID0ge307XG5fX2V4cG9ydChycGNfMF82X2V4cG9ydHMsIHtcbiAgUnBjQ2hhbm5lbDogKCkgPT4gUnBjQ2hhbm5lbFxufSk7XG5cbi8vIHNyYy90eXBlcy9pbmRleC50c1xudmFyIHR5cGVzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHR5cGVzX2V4cG9ydHMsIHtcbiAgQmxvY2tTdGF0dXM6ICgpID0+IEJsb2NrU3RhdHVzLFxuICBCbG9ja1RhZzogKCkgPT4gQmxvY2tUYWcsXG4gIEVudHJ5UG9pbnRUeXBlOiAoKSA9PiBFbnRyeVBvaW50VHlwZSxcbiAgTGl0ZXJhbDogKCkgPT4gTGl0ZXJhbCxcbiAgUlBDOiAoKSA9PiBhcGlfZXhwb3J0cyxcbiAgU0lNVUxBVElPTl9GTEFHOiAoKSA9PiBTSU1VTEFUSU9OX0ZMQUcsXG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGU6ICgpID0+IFRyYW5zYWN0aW9uVHlwZSxcbiAgVHlwZWREYXRhUmV2aXNpb246ICgpID0+IFR5cGVkRGF0YVJldmlzaW9uLFxuICBVaW50OiAoKSA9PiBVaW50LFxuICBWYWxpZGF0ZVR5cGU6ICgpID0+IFZhbGlkYXRlVHlwZVxufSk7XG5cbi8vIHNyYy90eXBlcy9hY2NvdW50LnRzXG52YXIgU0lNVUxBVElPTl9GTEFHID0gLyogQF9fUFVSRV9fICovICgoU0lNVUxBVElPTl9GTEFHMikgPT4ge1xuICBTSU1VTEFUSU9OX0ZMQUcyW1wiU0tJUF9WQUxJREFURVwiXSA9IFwiU0tJUF9WQUxJREFURVwiO1xuICBTSU1VTEFUSU9OX0ZMQUcyW1wiU0tJUF9FWEVDVVRFXCJdID0gXCJTS0lQX0VYRUNVVEVcIjtcbiAgcmV0dXJuIFNJTVVMQVRJT05fRkxBRzI7XG59KShTSU1VTEFUSU9OX0ZMQUcgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvY2FsbGRhdGEudHNcbnZhciBWYWxpZGF0ZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChWYWxpZGF0ZVR5cGUyKSA9PiB7XG4gIFZhbGlkYXRlVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBWYWxpZGF0ZVR5cGUyW1wiQ0FMTFwiXSA9IFwiQ0FMTFwiO1xuICBWYWxpZGF0ZVR5cGUyW1wiSU5WT0tFXCJdID0gXCJJTlZPS0VcIjtcbiAgcmV0dXJuIFZhbGlkYXRlVHlwZTI7XG59KShWYWxpZGF0ZVR5cGUgfHwge30pO1xudmFyIFVpbnQgPSAvKiBAX19QVVJFX18gKi8gKChVaW50MikgPT4ge1xuICBVaW50MltcInU4XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1OFwiO1xuICBVaW50MltcInUxNlwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTE2XCI7XG4gIFVpbnQyW1widTMyXCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MzJcIjtcbiAgVWludDJbXCJ1NjRcIl0gPSBcImNvcmU6OmludGVnZXI6OnU2NFwiO1xuICBVaW50MltcInUxMjhcIl0gPSBcImNvcmU6OmludGVnZXI6OnUxMjhcIjtcbiAgVWludDJbXCJ1MjU2XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCI7XG4gIFVpbnQyW1widTUxMlwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTUxMlwiO1xuICByZXR1cm4gVWludDI7XG59KShVaW50IHx8IHt9KTtcbnZhciBMaXRlcmFsID0gLyogQF9fUFVSRV9fICovICgoTGl0ZXJhbDIpID0+IHtcbiAgTGl0ZXJhbDJbXCJDbGFzc0hhc2hcIl0gPSBcImNvcmU6OnN0YXJrbmV0OjpjbGFzc19oYXNoOjpDbGFzc0hhc2hcIjtcbiAgTGl0ZXJhbDJbXCJDb250cmFjdEFkZHJlc3NcIl0gPSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIjtcbiAgTGl0ZXJhbDJbXCJTZWNwMjU2azFQb2ludFwiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OnNlY3AyNTZrMTo6U2VjcDI1NmsxUG9pbnRcIjtcbiAgcmV0dXJuIExpdGVyYWwyO1xufSkoTGl0ZXJhbCB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9saWIvY29udHJhY3QvaW5kZXgudHNcbnZhciBFbnRyeVBvaW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVudHJ5UG9pbnRUeXBlMikgPT4ge1xuICBFbnRyeVBvaW50VHlwZTJbXCJFWFRFUk5BTFwiXSA9IFwiRVhURVJOQUxcIjtcbiAgRW50cnlQb2ludFR5cGUyW1wiTDFfSEFORExFUlwiXSA9IFwiTDFfSEFORExFUlwiO1xuICBFbnRyeVBvaW50VHlwZTJbXCJDT05TVFJVQ1RPUlwiXSA9IFwiQ09OU1RSVUNUT1JcIjtcbiAgcmV0dXJuIEVudHJ5UG9pbnRUeXBlMjtcbn0pKEVudHJ5UG9pbnRUeXBlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2xpYi9pbmRleC50c1xudmFyIFRyYW5zYWN0aW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uVHlwZTIpID0+IHtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIkRFQ0xBUkVcIl0gPSBcIkRFQ0xBUkVcIjtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWVwiXSA9IFwiREVQTE9ZXCI7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lfQUNDT1VOVFwiXSA9IFwiREVQTE9ZX0FDQ09VTlRcIjtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIklOVk9LRVwiXSA9IFwiSU5WT0tFX0ZVTkNUSU9OXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblR5cGUyO1xufSkoVHJhbnNhY3Rpb25UeXBlIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uU3RhdHVzMikgPT4ge1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJOT1RfUkVDRUlWRURcIl0gPSBcIk5PVF9SRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJSRUNFSVZFRFwiXSA9IFwiUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVWRVJURURcIl0gPSBcIlJFVkVSVEVEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblN0YXR1czI7XG59KShUcmFuc2FjdGlvblN0YXR1cyB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyKSA9PiB7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiTk9UX1JFQ0VJVkVEXCJdID0gXCJOT1RfUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJSRUNFSVZFRFwiXSA9IFwiUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyO1xufSkoVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIpID0+IHtcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJTVUNDRUVERURcIl0gPSBcIlNVQ0NFRURFRFwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyO1xufSkoVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgfHwge30pO1xudmFyIEJsb2NrU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoQmxvY2tTdGF0dXMyKSA9PiB7XG4gIEJsb2NrU3RhdHVzMltcIlBFTkRJTkdcIl0gPSBcIlBFTkRJTkdcIjtcbiAgQmxvY2tTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIEJsb2NrU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBCbG9ja1N0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgcmV0dXJuIEJsb2NrU3RhdHVzMjtcbn0pKEJsb2NrU3RhdHVzIHx8IHt9KTtcbnZhciBCbG9ja1RhZyA9IC8qIEBfX1BVUkVfXyAqLyAoKEJsb2NrVGFnMikgPT4ge1xuICBCbG9ja1RhZzJbXCJwZW5kaW5nXCJdID0gXCJwZW5kaW5nXCI7XG4gIEJsb2NrVGFnMltcImxhdGVzdFwiXSA9IFwibGF0ZXN0XCI7XG4gIHJldHVybiBCbG9ja1RhZzI7XG59KShCbG9ja1RhZyB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy90eXBlZERhdGEudHNcbmltcG9ydCB7XG4gIFR5cGVkRGF0YVJldmlzaW9uXG59IGZyb20gXCJzdGFya25ldC10eXBlcy0wN1wiO1xuXG4vLyBzcmMvdXRpbHMvYXNzZXJ0LnRzXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJBc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvbnVtLnRzXG52YXIgbnVtX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG51bV9leHBvcnRzLCB7XG4gIGFkZFBlcmNlbnQ6ICgpID0+IGFkZFBlcmNlbnQsXG4gIGFzc2VydEluUmFuZ2U6ICgpID0+IGFzc2VydEluUmFuZ2UsXG4gIGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXk6ICgpID0+IGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXksXG4gIGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5OiAoKSA9PiBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheSxcbiAgY2xlYW5IZXg6ICgpID0+IGNsZWFuSGV4LFxuICBnZXREZWNpbWFsU3RyaW5nOiAoKSA9PiBnZXREZWNpbWFsU3RyaW5nLFxuICBnZXRIZXhTdHJpbmc6ICgpID0+IGdldEhleFN0cmluZyxcbiAgZ2V0SGV4U3RyaW5nQXJyYXk6ICgpID0+IGdldEhleFN0cmluZ0FycmF5LFxuICBoZXhUb0J5dGVzOiAoKSA9PiBoZXhUb0J5dGVzLFxuICBoZXhUb0RlY2ltYWxTdHJpbmc6ICgpID0+IGhleFRvRGVjaW1hbFN0cmluZyxcbiAgaXNCaWdJbnQ6ICgpID0+IGlzQmlnSW50LFxuICBpc0Jvb2xlYW46ICgpID0+IGlzQm9vbGVhbixcbiAgaXNIZXg6ICgpID0+IGlzSGV4LFxuICBpc051bWJlcjogKCkgPT4gaXNOdW1iZXIsXG4gIGlzU3RyaW5nV2hvbGVOdW1iZXI6ICgpID0+IGlzU3RyaW5nV2hvbGVOdW1iZXIsXG4gIHRvQmlnSW50OiAoKSA9PiB0b0JpZ0ludCxcbiAgdG9DYWlyb0Jvb2w6ICgpID0+IHRvQ2Fpcm9Cb29sLFxuICB0b0hleDogKCkgPT4gdG9IZXgsXG4gIHRvSGV4U3RyaW5nOiAoKSA9PiB0b0hleFN0cmluZyxcbiAgdG9TdG9yYWdlS2V5OiAoKSA9PiB0b1N0b3JhZ2VLZXlcbn0pO1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzTm9ibGUgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuZnVuY3Rpb24gaXNIZXgoaGV4KSB7XG4gIHJldHVybiAvXjB4WzAtOWEtZl0qJC9pLnRlc3QoaGV4KTtcbn1cbmZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIjtcbn1cbmZ1bmN0aW9uIHRvSGV4KG51bWJlcjIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCh0b0JpZ0ludChudW1iZXIyKS50b1N0cmluZygxNikpO1xufVxudmFyIHRvSGV4U3RyaW5nID0gdG9IZXg7XG5mdW5jdGlvbiB0b1N0b3JhZ2VLZXkobnVtYmVyMikge1xuICBjb25zdCByZXMgPSBhZGRIZXhQcmVmaXgodG9CaWdJbnQobnVtYmVyMikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCBcIjBcIikpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gaGV4VG9EZWNpbWFsU3RyaW5nKGhleCkge1xuICByZXR1cm4gQmlnSW50KGFkZEhleFByZWZpeChoZXgpKS50b1N0cmluZygxMCk7XG59XG52YXIgY2xlYW5IZXggPSAoaGV4KSA9PiBoZXgudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eKDB4KTArLywgXCIkMVwiKTtcbmZ1bmN0aW9uIGFzc2VydEluUmFuZ2UoaW5wdXQsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIGlucHV0TmFtZSA9IFwiXCIpIHtcbiAgY29uc3QgbWVzc2FnZVN1ZmZpeCA9IGlucHV0TmFtZSA9PT0gXCJcIiA/IFwiaW52YWxpZCBsZW5ndGhcIiA6IGBpbnZhbGlkICR7aW5wdXROYW1lfSBsZW5ndGhgO1xuICBjb25zdCBpbnB1dEJpZ0ludCA9IEJpZ0ludChpbnB1dCk7XG4gIGNvbnN0IGxvd2VyQm91bmRCaWdJbnQgPSBCaWdJbnQobG93ZXJCb3VuZCk7XG4gIGNvbnN0IHVwcGVyQm91bmRCaWdJbnQgPSBCaWdJbnQodXBwZXJCb3VuZCk7XG4gIGFzc2VydChcbiAgICBpbnB1dEJpZ0ludCA+PSBsb3dlckJvdW5kQmlnSW50ICYmIGlucHV0QmlnSW50IDw9IHVwcGVyQm91bmRCaWdJbnQsXG4gICAgYE1lc3NhZ2Ugbm90IHNpZ25hYmxlLCAke21lc3NhZ2VTdWZmaXh9LmBcbiAgKTtcbn1cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXkocmF3Q2FsbGRhdGEpIHtcbiAgcmV0dXJuIHJhd0NhbGxkYXRhLm1hcCgoeCkgPT4gdG9CaWdJbnQoeCkudG9TdHJpbmcoMTApKTtcbn1cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5KHJhd0NhbGxkYXRhKSB7XG4gIHJldHVybiByYXdDYWxsZGF0YS5tYXAoKHgpID0+IHRvSGV4KHgpKTtcbn1cbnZhciBpc1N0cmluZ1dob2xlTnVtYmVyID0gKHZhbHVlKSA9PiAvXlxcZCskLy50ZXN0KHZhbHVlKTtcbmZ1bmN0aW9uIGdldERlY2ltYWxTdHJpbmcodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiBoZXhUb0RlY2ltYWxTdHJpbmcodmFsdWUpO1xuICB9XG4gIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7dmFsdWV9IG5lZWQgdG8gYmUgaGV4LXN0cmluZyBvciB3aG9sZS1udW1iZXItc3RyaW5nYCk7XG59XG5mdW5jdGlvbiBnZXRIZXhTdHJpbmcodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdG9IZXhTdHJpbmcodmFsdWUpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHt2YWx1ZX0gbmVlZCB0byBiZSBoZXgtc3RyaW5nIG9yIHdob2xlLW51bWJlci1zdHJpbmdgKTtcbn1cbmZ1bmN0aW9uIGdldEhleFN0cmluZ0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoKGVsKSA9PiBnZXRIZXhTdHJpbmcoZWwpKTtcbn1cbnZhciB0b0NhaXJvQm9vbCA9ICh2YWx1ZSkgPT4gKCt2YWx1ZSkudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgaWYgKCFpc0hleCh2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3ZhbHVlfSBuZWVkIHRvIGJlIGEgaGV4LXN0cmluZ2ApO1xuICBsZXQgYWRhcHRlZFZhbHVlID0gcmVtb3ZlSGV4UHJlZml4KHZhbHVlKTtcbiAgaWYgKGFkYXB0ZWRWYWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgYWRhcHRlZFZhbHVlID0gYDAke2FkYXB0ZWRWYWx1ZX1gO1xuICB9XG4gIHJldHVybiBoZXhUb0J5dGVzTm9ibGUoYWRhcHRlZFZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFkZFBlcmNlbnQobnVtYmVyMiwgcGVyY2VudCkge1xuICBjb25zdCBiaWdJbnROdW0gPSBCaWdJbnQobnVtYmVyMik7XG4gIHJldHVybiBiaWdJbnROdW0gKyBiaWdJbnROdW0gKiBCaWdJbnQocGVyY2VudCkgLyAxMDBuO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcbn1cblxuLy8gc3JjL3V0aWxzL3NlbGVjdG9yLnRzXG52YXIgc2VsZWN0b3JfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2VsZWN0b3JfZXhwb3J0cywge1xuICBnZXRTZWxlY3RvcjogKCkgPT4gZ2V0U2VsZWN0b3IsXG4gIGdldFNlbGVjdG9yRnJvbU5hbWU6ICgpID0+IGdldFNlbGVjdG9yRnJvbU5hbWUsXG4gIGtlY2Nha0JuOiAoKSA9PiBrZWNjYWtCbixcbiAgc3RhcmtuZXRLZWNjYWs6ICgpID0+IHN0YXJrbmV0S2VjY2FrXG59KTtcbmltcG9ydCB7IGtlY2NhayB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmZ1bmN0aW9uIGtlY2Nha0JuKHZhbHVlKSB7XG4gIGNvbnN0IGhleFdpdGhvdXRQcmVmaXggPSByZW1vdmVIZXhQcmVmaXgodG9IZXgoQmlnSW50KHZhbHVlKSkpO1xuICBjb25zdCBldmVuSGV4ID0gaGV4V2l0aG91dFByZWZpeC5sZW5ndGggJSAyID09PSAwID8gaGV4V2l0aG91dFByZWZpeCA6IGAwJHtoZXhXaXRob3V0UHJlZml4fWA7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoa2VjY2FrKGhleFRvQnl0ZXMoYWRkSGV4UHJlZml4KGV2ZW5IZXgpKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIGtlY2Nha0hleChzdHIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChrZWNjYWsodXRmOFRvQXJyYXkoc3RyKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIHN0YXJrbmV0S2VjY2FrKHN0cikge1xuICBjb25zdCBoYXNoID0gQmlnSW50KGtlY2Nha0hleChzdHIpKTtcbiAgcmV0dXJuIGhhc2ggJiBNQVNLXzI1MDtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yRnJvbU5hbWUoZnVuY05hbWUpIHtcbiAgcmV0dXJuIHRvSGV4KHN0YXJrbmV0S2VjY2FrKGZ1bmNOYW1lKSk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rvcih2YWx1ZSkge1xuICBpZiAoaXNIZXgodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB0b0hleFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGdldFNlbGVjdG9yRnJvbU5hbWUodmFsdWUpO1xufVxuXG4vLyBzcmMvdXRpbHMvc2hvcnRTdHJpbmcudHNcbnZhciBzaG9ydFN0cmluZ19leHBvcnRzID0ge307XG5fX2V4cG9ydChzaG9ydFN0cmluZ19leHBvcnRzLCB7XG4gIGRlY29kZVNob3J0U3RyaW5nOiAoKSA9PiBkZWNvZGVTaG9ydFN0cmluZyxcbiAgZW5jb2RlU2hvcnRTdHJpbmc6ICgpID0+IGVuY29kZVNob3J0U3RyaW5nLFxuICBpc0FTQ0lJOiAoKSA9PiBpc0FTQ0lJLFxuICBpc0RlY2ltYWxTdHJpbmc6ICgpID0+IGlzRGVjaW1hbFN0cmluZyxcbiAgaXNMb25nVGV4dDogKCkgPT4gaXNMb25nVGV4dCxcbiAgaXNTaG9ydFN0cmluZzogKCkgPT4gaXNTaG9ydFN0cmluZyxcbiAgaXNTaG9ydFRleHQ6ICgpID0+IGlzU2hvcnRUZXh0LFxuICBpc1N0cmluZzogKCkgPT4gaXNTdHJpbmcsXG4gIGlzVGV4dDogKCkgPT4gaXNUZXh0LFxuICBzcGxpdExvbmdTdHJpbmc6ICgpID0+IHNwbGl0TG9uZ1N0cmluZ1xufSk7XG5mdW5jdGlvbiBpc0FTQ0lJKHN0cikge1xuICByZXR1cm4gL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzU2hvcnRTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIubGVuZ3RoIDw9IFRFWFRfVE9fRkVMVF9NQVhfTEVOO1xufVxuZnVuY3Rpb24gaXNEZWNpbWFsU3RyaW5nKHN0cikge1xuICByZXR1cm4gL15bMC05XSokL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzVGV4dCh2YWwpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgJiYgIWlzSGV4KHZhbCkgJiYgIWlzU3RyaW5nV2hvbGVOdW1iZXIodmFsKTtcbn1cbnZhciBpc1Nob3J0VGV4dCA9ICh2YWwpID0+IGlzVGV4dCh2YWwpICYmIGlzU2hvcnRTdHJpbmcodmFsKTtcbnZhciBpc0xvbmdUZXh0ID0gKHZhbCkgPT4gaXNUZXh0KHZhbCkgJiYgIWlzU2hvcnRTdHJpbmcodmFsKTtcbmZ1bmN0aW9uIHNwbGl0TG9uZ1N0cmluZyhsb25nU3RyKSB7XG4gIGNvbnN0IHJlZ2V4ID0gUmVnRXhwKGBbXl17MSwke1RFWFRfVE9fRkVMVF9NQVhfTEVOfX1gLCBcImdcIik7XG4gIHJldHVybiBsb25nU3RyLm1hdGNoKHJlZ2V4KSB8fCBbXTtcbn1cbmZ1bmN0aW9uIGVuY29kZVNob3J0U3RyaW5nKHN0cikge1xuICBpZiAoIWlzQVNDSUkoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgYW4gQVNDSUkgc3RyaW5nYCk7XG4gIGlmICghaXNTaG9ydFN0cmluZyhzdHIpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIHRvbyBsb25nYCk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoc3RyLnJlcGxhY2UoLy4vZywgKGNoYXIpID0+IGNoYXIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVNob3J0U3RyaW5nKHN0cikge1xuICBpZiAoIWlzQVNDSUkoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgYW4gQVNDSUkgc3RyaW5nYCk7XG4gIGlmIChpc0hleChzdHIpKSB7XG4gICAgcmV0dXJuIHJlbW92ZUhleFByZWZpeChzdHIpLnJlcGxhY2UoLy57Mn0vZywgKGhleCkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSkpO1xuICB9XG4gIGlmIChpc0RlY2ltYWxTdHJpbmcoc3RyKSkge1xuICAgIHJldHVybiBkZWNvZGVTaG9ydFN0cmluZyhcIjBYXCIuY29uY2F0KEJpZ0ludChzdHIpLnRvU3RyaW5nKDE2KSkpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBIZXggb3IgZGVjaW1hbGApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvYnl0ZUFycmF5LnRzXG52YXIgYnl0ZUFycmF5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGJ5dGVBcnJheV9leHBvcnRzLCB7XG4gIGJ5dGVBcnJheUZyb21TdHJpbmc6ICgpID0+IGJ5dGVBcnJheUZyb21TdHJpbmcsXG4gIHN0cmluZ0Zyb21CeXRlQXJyYXk6ICgpID0+IHN0cmluZ0Zyb21CeXRlQXJyYXlcbn0pO1xuZnVuY3Rpb24gc3RyaW5nRnJvbUJ5dGVBcnJheShteUJ5dGVBcnJheSkge1xuICBjb25zdCBwZW5kaW5nX3dvcmQgPSBCaWdJbnQobXlCeXRlQXJyYXkucGVuZGluZ193b3JkKSA9PT0gMG4gPyBcIlwiIDogZGVjb2RlU2hvcnRTdHJpbmcodG9IZXgobXlCeXRlQXJyYXkucGVuZGluZ193b3JkKSk7XG4gIHJldHVybiBteUJ5dGVBcnJheS5kYXRhLnJlZHVjZSgoY3VtdWxlZFN0cmluZywgZW5jb2RlZFN0cmluZykgPT4ge1xuICAgIGNvbnN0IGFkZCA9IEJpZ0ludChlbmNvZGVkU3RyaW5nKSA9PT0gMG4gPyBcIlwiIDogZGVjb2RlU2hvcnRTdHJpbmcodG9IZXgoZW5jb2RlZFN0cmluZykpO1xuICAgIHJldHVybiBjdW11bGVkU3RyaW5nICsgYWRkO1xuICB9LCBcIlwiKSArIHBlbmRpbmdfd29yZDtcbn1cbmZ1bmN0aW9uIGJ5dGVBcnJheUZyb21TdHJpbmcodGFyZ2V0U3RyaW5nKSB7XG4gIGNvbnN0IHNob3J0U3RyaW5ncyA9IHNwbGl0TG9uZ1N0cmluZyh0YXJnZXRTdHJpbmcpO1xuICBjb25zdCByZW1haW5kZXIgPSBzaG9ydFN0cmluZ3Nbc2hvcnRTdHJpbmdzLmxlbmd0aCAtIDFdO1xuICBjb25zdCBzaG9ydFN0cmluZ3NFbmNvZGVkID0gc2hvcnRTdHJpbmdzLm1hcChlbmNvZGVTaG9ydFN0cmluZyk7XG4gIGNvbnN0IFtwZW5kaW5nV29yZCwgcGVuZGluZ1dvcmRMZW5ndGhdID0gcmVtYWluZGVyID09PSB2b2lkIDAgfHwgcmVtYWluZGVyLmxlbmd0aCA9PT0gMzEgPyBbXCIweDAwXCIsIDBdIDogW3Nob3J0U3RyaW5nc0VuY29kZWQucG9wKCksIHJlbWFpbmRlci5sZW5ndGhdO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IHNob3J0U3RyaW5nc0VuY29kZWQubGVuZ3RoID09PSAwID8gW10gOiBzaG9ydFN0cmluZ3NFbmNvZGVkLFxuICAgIHBlbmRpbmdfd29yZDogcGVuZGluZ1dvcmQsXG4gICAgcGVuZGluZ193b3JkX2xlbjogcGVuZGluZ1dvcmRMZW5ndGhcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgY2Fpcm9fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY2Fpcm9fZXhwb3J0cywge1xuICBmZWx0OiAoKSA9PiBmZWx0LFxuICBnZXRBYmlDb250cmFjdFZlcnNpb246ICgpID0+IGdldEFiaUNvbnRyYWN0VmVyc2lvbixcbiAgZ2V0QXJyYXlUeXBlOiAoKSA9PiBnZXRBcnJheVR5cGUsXG4gIGlzQ2Fpcm8xQWJpOiAoKSA9PiBpc0NhaXJvMUFiaSxcbiAgaXNDYWlybzFUeXBlOiAoKSA9PiBpc0NhaXJvMVR5cGUsXG4gIGlzTGVuOiAoKSA9PiBpc0xlbixcbiAgaXNUeXBlQXJyYXk6ICgpID0+IGlzVHlwZUFycmF5LFxuICBpc1R5cGVCb29sOiAoKSA9PiBpc1R5cGVCb29sLFxuICBpc1R5cGVCeXRlQXJyYXk6ICgpID0+IGlzVHlwZUJ5dGVBcnJheSxcbiAgaXNUeXBlQnl0ZXMzMTogKCkgPT4gaXNUeXBlQnl0ZXMzMSxcbiAgaXNUeXBlQ29udHJhY3RBZGRyZXNzOiAoKSA9PiBpc1R5cGVDb250cmFjdEFkZHJlc3MsXG4gIGlzVHlwZUVudW06ICgpID0+IGlzVHlwZUVudW0sXG4gIGlzVHlwZUV0aEFkZHJlc3M6ICgpID0+IGlzVHlwZUV0aEFkZHJlc3MsXG4gIGlzVHlwZUZlbHQ6ICgpID0+IGlzVHlwZUZlbHQsXG4gIGlzVHlwZUxpdGVyYWw6ICgpID0+IGlzVHlwZUxpdGVyYWwsXG4gIGlzVHlwZU5hbWVkVHVwbGU6ICgpID0+IGlzVHlwZU5hbWVkVHVwbGUsXG4gIGlzVHlwZU9wdGlvbjogKCkgPT4gaXNUeXBlT3B0aW9uLFxuICBpc1R5cGVSZXN1bHQ6ICgpID0+IGlzVHlwZVJlc3VsdCxcbiAgaXNUeXBlU2VjcDI1NmsxUG9pbnQ6ICgpID0+IGlzVHlwZVNlY3AyNTZrMVBvaW50LFxuICBpc1R5cGVTdHJ1Y3Q6ICgpID0+IGlzVHlwZVN0cnVjdCxcbiAgaXNUeXBlVHVwbGU6ICgpID0+IGlzVHlwZVR1cGxlLFxuICBpc1R5cGVVaW50OiAoKSA9PiBpc1R5cGVVaW50LFxuICBpc1R5cGVVaW50MjU2OiAoKSA9PiBpc1R5cGVVaW50MjU2LFxuICB0dXBsZTogKCkgPT4gdHVwbGUsXG4gIHVpbnQyNTY6ICgpID0+IHVpbnQyNTYsXG4gIHVpbnQ1MTI6ICgpID0+IHVpbnQ1MTJcbn0pO1xuXG4vLyBzcmMvdXRpbHMvY2Fpcm9EYXRhVHlwZXMvZmVsdC50c1xuZnVuY3Rpb24gQ2Fpcm9GZWx0KGl0KSB7XG4gIGlmIChpc0JpZ0ludChpdCkgfHwgTnVtYmVyLmlzSW50ZWdlcihpdCkpIHtcbiAgICByZXR1cm4gaXQudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoaXNTdHJpbmcoaXQpKSB7XG4gICAgaWYgKGlzSGV4KGl0KSkge1xuICAgICAgcmV0dXJuIEJpZ0ludChpdCkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzVGV4dChpdCkpIHtcbiAgICAgIGlmICghaXNTaG9ydFN0cmluZyhpdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2l0fSBpcyBhIGxvbmcgc3RyaW5nID4gMzEgY2hhcnMuIFBsZWFzZSBzcGxpdCBpdCBpbnRvIGFuIGFycmF5IG9mIHNob3J0IHN0cmluZ3MuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhpdCkpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKGl0KSkge1xuICAgICAgcmV0dXJuIGl0O1xuICAgIH1cbiAgfVxuICBpZiAoaXNCb29sZWFuKGl0KSkge1xuICAgIHJldHVybiBgJHsraXR9YDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7aXR9IGNhbid0IGJlIGNvbXB1dGVkIGJ5IGZlbHQoKWApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2Fpcm9EYXRhVHlwZXMvdWludDI1Ni50c1xudmFyIFVJTlRfMTI4X01BWCA9ICgxbiA8PCAxMjhuKSAtIDFuO1xudmFyIFVJTlRfMjU2X01BWCA9ICgxbiA8PCAyNTZuKSAtIDFuO1xudmFyIFVJTlRfMjU2X01JTiA9IDBuO1xudmFyIFVJTlRfMjU2X0xPV19NQVggPSAzNDAyODIzNjY5MjA5Mzg0NjM0NjMzNzQ2MDc0MzE3NjgyMTE0NTVuO1xudmFyIFVJTlRfMjU2X0hJR0hfTUFYID0gMzQwMjgyMzY2OTIwOTM4NDYzNDYzMzc0NjA3NDMxNzY4MjExNDU1bjtcbnZhciBVSU5UXzI1Nl9MT1dfTUlOID0gMG47XG52YXIgVUlOVF8yNTZfSElHSF9NSU4gPSAwbjtcbnZhciBDYWlyb1VpbnQyNTYgPSBjbGFzcyBfQ2Fpcm9VaW50MjU2IHtcbiAgbG93O1xuICBoaWdoO1xuICBzdGF0aWMgYWJpU2VsZWN0b3IgPSBcImNvcmU6OmludGVnZXI6OnUyNTZcIjtcbiAgY29uc3RydWN0b3IoLi4uYXJyKSB7XG4gICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwib2JqZWN0XCIgJiYgYXJyLmxlbmd0aCA9PT0gMSAmJiBcImxvd1wiIGluIGFyclswXSAmJiBcImhpZ2hcIiBpbiBhcnJbMF0pIHtcbiAgICAgIGNvbnN0IHByb3BzID0gX0NhaXJvVWludDI1Ni52YWxpZGF0ZVByb3BzKGFyclswXS5sb3csIGFyclswXS5oaWdoKTtcbiAgICAgIHRoaXMubG93ID0gcHJvcHMubG93O1xuICAgICAgdGhpcy5oaWdoID0gcHJvcHMuaGlnaDtcbiAgICB9IGVsc2UgaWYgKGFyci5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGJpZ0ludCA9IF9DYWlyb1VpbnQyNTYudmFsaWRhdGUoYXJyWzBdKTtcbiAgICAgIHRoaXMubG93ID0gYmlnSW50ICYgVUlOVF8xMjhfTUFYO1xuICAgICAgdGhpcy5oaWdoID0gYmlnSW50ID4+IDEyOG47XG4gICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IF9DYWlyb1VpbnQyNTYudmFsaWRhdGVQcm9wcyhhcnJbMF0sIGFyclsxXSk7XG4gICAgICB0aGlzLmxvdyA9IHByb3BzLmxvdztcbiAgICAgIHRoaXMuaGlnaCA9IHByb3BzLmhpZ2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiSW5jb3JyZWN0IGNvbnN0cnVjdG9yIHBhcmFtZXRlcnNcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBpZiBCaWdOdW1iZXJpc2ggY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVuaXQyNTZcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZShiaWdOdW1iZXJpc2gpIHtcbiAgICBjb25zdCBiaWdJbnQgPSBCaWdJbnQoYmlnTnVtYmVyaXNoKTtcbiAgICBpZiAoYmlnSW50IDwgVUlOVF8yNTZfTUlOKVxuICAgICAgdGhyb3cgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgc21hbGxlciB0aGFuIFVJTlRfMjU2X01JTlwiKTtcbiAgICBpZiAoYmlnSW50ID4gVUlOVF8yNTZfTUFYKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmlnTnVtYmVyaXNoIGlzIGJpZ2dlciB0aGFuIFVJTlRfMjU2X01BWFwiKTtcbiAgICByZXR1cm4gYmlnSW50O1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBpZiBsb3cgYW5kIGhpZ2ggY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVuaXQyNTZcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVByb3BzKGxvdywgaGlnaCkge1xuICAgIGNvbnN0IGJpZ0ludExvdyA9IEJpZ0ludChsb3cpO1xuICAgIGNvbnN0IGJpZ0ludEhpZ2ggPSBCaWdJbnQoaGlnaCk7XG4gICAgaWYgKGJpZ0ludExvdyA8IFVJTlRfMjU2X0xPV19NSU4gfHwgYmlnSW50TG93ID4gVUlOVF8yNTZfTE9XX01BWCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG93IGlzIG91dCBvZiByYW5nZSBVSU5UXzI1Nl9MT1dfTUlOIC0gVUlOVF8yNTZfTE9XX01BWFwiKTtcbiAgICB9XG4gICAgaWYgKGJpZ0ludEhpZ2ggPCBVSU5UXzI1Nl9ISUdIX01JTiB8fCBiaWdJbnRIaWdoID4gVUlOVF8yNTZfSElHSF9NQVgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImhpZ2ggaXMgb3V0IG9mIHJhbmdlIFVJTlRfMjU2X0hJR0hfTUlOIC0gVUlOVF8yNTZfSElHSF9NQVhcIik7XG4gICAgfVxuICAgIHJldHVybiB7IGxvdzogYmlnSW50TG93LCBoaWdoOiBiaWdJbnRIaWdoIH07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIEJpZ051bWJlcmlzaCBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgVW5pdDI1NlxuICAgKi9cbiAgc3RhdGljIGlzKGJpZ051bWJlcmlzaCkge1xuICAgIHRyeSB7XG4gICAgICBfQ2Fpcm9VaW50MjU2LnZhbGlkYXRlKGJpZ051bWJlcmlzaCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHByb3ZpZGVkIGFiaSB0eXBlIGlzIHRoaXMgZGF0YSB0eXBlXG4gICAqL1xuICBzdGF0aWMgaXNBYmlUeXBlKGFiaVR5cGUpIHtcbiAgICByZXR1cm4gYWJpVHlwZSA9PT0gX0NhaXJvVWludDI1Ni5hYmlTZWxlY3RvcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGJpZ2ludCByZXByZXNlbnRhdGlvblxuICAgKi9cbiAgdG9CaWdJbnQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmhpZ2ggPDwgMTI4bikgKyB0aGlzLmxvdztcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFVpbnQyNTYgc3RydWN0dXJlIHdpdGggSGV4U3RyaW5nIHByb3BzXG4gICAqIHtsb3c6IEhleFN0cmluZywgaGlnaDogSGV4U3RyaW5nfVxuICAgKi9cbiAgdG9VaW50MjU2SGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb3c6IGFkZEhleFByZWZpeCh0aGlzLmxvdy50b1N0cmluZygxNikpLFxuICAgICAgaGlnaDogYWRkSGV4UHJlZml4KHRoaXMuaGlnaC50b1N0cmluZygxNikpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFVpbnQyNTYgc3RydWN0dXJlIHdpdGggRGVjaW1hbFN0cmluZyBwcm9wc1xuICAgKiB7bG93OiBEZWNTdHJpbmcsIGhpZ2g6IERlY1N0cmluZ31cbiAgICovXG4gIHRvVWludDI1NkRlY2ltYWxTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvdzogdGhpcy5sb3cudG9TdHJpbmcoMTApLFxuICAgICAgaGlnaDogdGhpcy5oaWdoLnRvU3RyaW5nKDEwKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhcGkgcmVxdWVzdHMgcmVwcmVzZW50YXRpb24gd2l0Y2ggaXMgZmVsdCBhcnJheVxuICAgKi9cbiAgdG9BcGlSZXF1ZXN0KCkge1xuICAgIHJldHVybiBbQ2Fpcm9GZWx0KHRoaXMubG93KSwgQ2Fpcm9GZWx0KHRoaXMuaGlnaCldO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2Fpcm9EYXRhVHlwZXMvdWludDUxMi50c1xudmFyIFVJTlRfNTEyX01BWCA9ICgxbiA8PCA1MTJuKSAtIDFuO1xudmFyIFVJTlRfNTEyX01JTiA9IDBuO1xudmFyIFVJTlRfMTI4X01JTiA9IDBuO1xudmFyIENhaXJvVWludDUxMiA9IGNsYXNzIF9DYWlyb1VpbnQ1MTIge1xuICBsaW1iMDtcbiAgbGltYjE7XG4gIGxpbWIyO1xuICBsaW1iMztcbiAgc3RhdGljIGFiaVNlbGVjdG9yID0gXCJjb3JlOjppbnRlZ2VyOjp1NTEyXCI7XG4gIGNvbnN0cnVjdG9yKC4uLmFycikge1xuICAgIGlmICh0eXBlb2YgYXJyWzBdID09PSBcIm9iamVjdFwiICYmIGFyci5sZW5ndGggPT09IDEgJiYgXCJsaW1iMFwiIGluIGFyclswXSAmJiBcImxpbWIxXCIgaW4gYXJyWzBdICYmIFwibGltYjJcIiBpbiBhcnJbMF0gJiYgXCJsaW1iM1wiIGluIGFyclswXSkge1xuICAgICAgY29uc3QgcHJvcHMgPSBfQ2Fpcm9VaW50NTEyLnZhbGlkYXRlUHJvcHMoXG4gICAgICAgIGFyclswXS5saW1iMCxcbiAgICAgICAgYXJyWzBdLmxpbWIxLFxuICAgICAgICBhcnJbMF0ubGltYjIsXG4gICAgICAgIGFyclswXS5saW1iM1xuICAgICAgKTtcbiAgICAgIHRoaXMubGltYjAgPSBwcm9wcy5saW1iMDtcbiAgICAgIHRoaXMubGltYjEgPSBwcm9wcy5saW1iMTtcbiAgICAgIHRoaXMubGltYjIgPSBwcm9wcy5saW1iMjtcbiAgICAgIHRoaXMubGltYjMgPSBwcm9wcy5saW1iMztcbiAgICB9IGVsc2UgaWYgKGFyci5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGJpZ0ludCA9IF9DYWlyb1VpbnQ1MTIudmFsaWRhdGUoYXJyWzBdKTtcbiAgICAgIHRoaXMubGltYjAgPSBiaWdJbnQgJiBVSU5UXzEyOF9NQVg7XG4gICAgICB0aGlzLmxpbWIxID0gKGJpZ0ludCAmIFVJTlRfMTI4X01BWCA8PCAxMjhuKSA+PiAxMjhuO1xuICAgICAgdGhpcy5saW1iMiA9IChiaWdJbnQgJiBVSU5UXzEyOF9NQVggPDwgMjU2bikgPj4gMjU2bjtcbiAgICAgIHRoaXMubGltYjMgPSBiaWdJbnQgPj4gMzg0bjtcbiAgICB9IGVsc2UgaWYgKGFyci5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNvbnN0IHByb3BzID0gX0NhaXJvVWludDUxMi52YWxpZGF0ZVByb3BzKGFyclswXSwgYXJyWzFdLCBhcnJbMl0sIGFyclszXSk7XG4gICAgICB0aGlzLmxpbWIwID0gcHJvcHMubGltYjA7XG4gICAgICB0aGlzLmxpbWIxID0gcHJvcHMubGltYjE7XG4gICAgICB0aGlzLmxpbWIyID0gcHJvcHMubGltYjI7XG4gICAgICB0aGlzLmxpbWIzID0gcHJvcHMubGltYjM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiSW5jb3JyZWN0IFVpbnQ1MTIgY29uc3RydWN0b3IgcGFyYW1ldGVyc1wiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGlmIEJpZ051bWJlcmlzaCBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgVWludDUxMlxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlKGJpZ051bWJlcmlzaCkge1xuICAgIGNvbnN0IGJpZ0ludCA9IEJpZ0ludChiaWdOdW1iZXJpc2gpO1xuICAgIGlmIChiaWdJbnQgPCBVSU5UXzUxMl9NSU4pXG4gICAgICB0aHJvdyBFcnJvcihcImJpZ051bWJlcmlzaCBpcyBzbWFsbGVyIHRoYW4gVUlOVF81MTJfTUlOLlwiKTtcbiAgICBpZiAoYmlnSW50ID4gVUlOVF81MTJfTUFYKVxuICAgICAgdGhyb3cgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgYmlnZ2VyIHRoYW4gVUlOVF81MTJfTUFYLlwiKTtcbiAgICByZXR1cm4gYmlnSW50O1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBpZiBsaW1icyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgVWludDUxMlxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlUHJvcHMobGltYjAsIGxpbWIxLCBsaW1iMiwgbGltYjMpIHtcbiAgICBjb25zdCBsMCA9IEJpZ0ludChsaW1iMCk7XG4gICAgY29uc3QgbDEgPSBCaWdJbnQobGltYjEpO1xuICAgIGNvbnN0IGwyID0gQmlnSW50KGxpbWIyKTtcbiAgICBjb25zdCBsMyA9IEJpZ0ludChsaW1iMyk7XG4gICAgW2wwLCBsMSwgbDIsIGwzXS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA8IFVJTlRfMTI4X01JTiB8fCB2YWx1ZSA+IFVJTlRfMTI4X01BWCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgbGltYiR7aW5kZXh9IGlzIG5vdCBpbiB0aGUgcmFuZ2Ugb2YgYSB1MTI4IG51bWJlcmApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IGxpbWIwOiBsMCwgbGltYjE6IGwxLCBsaW1iMjogbDIsIGxpbWIzOiBsMyB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBCaWdOdW1iZXJpc2ggY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVpbnQ1MTJcbiAgICovXG4gIHN0YXRpYyBpcyhiaWdOdW1iZXJpc2gpIHtcbiAgICB0cnkge1xuICAgICAgX0NhaXJvVWludDUxMi52YWxpZGF0ZShiaWdOdW1iZXJpc2gpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwcm92aWRlZCBhYmkgdHlwZSBpcyB0aGlzIGRhdGEgdHlwZVxuICAgKi9cbiAgc3RhdGljIGlzQWJpVHlwZShhYmlUeXBlKSB7XG4gICAgcmV0dXJuIGFiaVR5cGUgPT09IF9DYWlyb1VpbnQ1MTIuYWJpU2VsZWN0b3I7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBiaWdpbnQgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIHRvQmlnSW50KCkge1xuICAgIHJldHVybiAodGhpcy5saW1iMyA8PCAzODRuKSArICh0aGlzLmxpbWIyIDw8IDI1Nm4pICsgKHRoaXMubGltYjEgPDwgMTI4bikgKyB0aGlzLmxpbWIwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDUxMiBzdHJ1Y3R1cmUgd2l0aCBIZXhTdHJpbmcgcHJvcHNcbiAgICogbGltYng6IEhleFN0cmluZ1xuICAgKi9cbiAgdG9VaW50NTEySGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW1iMDogYWRkSGV4UHJlZml4KHRoaXMubGltYjAudG9TdHJpbmcoMTYpKSxcbiAgICAgIGxpbWIxOiBhZGRIZXhQcmVmaXgodGhpcy5saW1iMS50b1N0cmluZygxNikpLFxuICAgICAgbGltYjI6IGFkZEhleFByZWZpeCh0aGlzLmxpbWIyLnRvU3RyaW5nKDE2KSksXG4gICAgICBsaW1iMzogYWRkSGV4UHJlZml4KHRoaXMubGltYjMudG9TdHJpbmcoMTYpKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBVaW50NTEyIHN0cnVjdHVyZSB3aXRoIERlY2ltYWxTdHJpbmcgcHJvcHNcbiAgICogbGltYnggRGVjU3RyaW5nXG4gICAqL1xuICB0b1VpbnQ1MTJEZWNpbWFsU3RyaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW1iMDogdGhpcy5saW1iMC50b1N0cmluZygxMCksXG4gICAgICBsaW1iMTogdGhpcy5saW1iMS50b1N0cmluZygxMCksXG4gICAgICBsaW1iMjogdGhpcy5saW1iMi50b1N0cmluZygxMCksXG4gICAgICBsaW1iMzogdGhpcy5saW1iMy50b1N0cmluZygxMClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYXBpIHJlcXVlc3RzIHJlcHJlc2VudGF0aW9uIHdpdGNoIGlzIGZlbHQgYXJyYXlcbiAgICovXG4gIHRvQXBpUmVxdWVzdCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjApLFxuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjEpLFxuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjIpLFxuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjMpXG4gICAgXTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgaXNMZW4gPSAobmFtZSkgPT4gL19sZW4kLy50ZXN0KG5hbWUpO1xudmFyIGlzVHlwZUZlbHQgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJmZWx0XCIgfHwgdHlwZSA9PT0gXCJjb3JlOjpmZWx0MjUyXCI7XG52YXIgaXNUeXBlQXJyYXkgPSAodHlwZSkgPT4gL1xcKi8udGVzdCh0eXBlKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OlwiKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6U3Bhbjo6XCIpO1xudmFyIGlzVHlwZVR1cGxlID0gKHR5cGUpID0+IC9eXFwoLipcXCkkL2kudGVzdCh0eXBlKTtcbnZhciBpc1R5cGVOYW1lZFR1cGxlID0gKHR5cGUpID0+IC9cXCguKlxcKS9pLnRlc3QodHlwZSkgJiYgdHlwZS5pbmNsdWRlcyhcIjpcIik7XG52YXIgaXNUeXBlU3RydWN0ID0gKHR5cGUsIHN0cnVjdHMpID0+IHR5cGUgaW4gc3RydWN0cztcbnZhciBpc1R5cGVFbnVtID0gKHR5cGUsIGVudW1zKSA9PiB0eXBlIGluIGVudW1zO1xudmFyIGlzVHlwZU9wdGlvbiA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpvcHRpb246Ok9wdGlvbjo6XCIpO1xudmFyIGlzVHlwZVJlc3VsdCA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6XCIpO1xudmFyIGlzVHlwZVVpbnQgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhVaW50KS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVVaW50MjU2ID0gKHR5cGUpID0+IENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSk7XG52YXIgaXNUeXBlTGl0ZXJhbCA9ICh0eXBlKSA9PiBPYmplY3QudmFsdWVzKExpdGVyYWwpLmluY2x1ZGVzKHR5cGUpO1xudmFyIGlzVHlwZUJvb2wgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpib29sXCI7XG52YXIgaXNUeXBlQ29udHJhY3RBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xudmFyIGlzVHlwZUV0aEFkZHJlc3MgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjtcbnZhciBpc1R5cGVCeXRlczMxID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6Ynl0ZXNfMzE6OmJ5dGVzMzFcIjtcbnZhciBpc1R5cGVCeXRlQXJyYXkgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpieXRlX2FycmF5OjpCeXRlQXJyYXlcIjtcbnZhciBpc1R5cGVTZWNwMjU2azFQb2ludCA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpzZWNwMjU2azE6OlNlY3AyNTZrMVBvaW50XCI7XG52YXIgaXNDYWlybzFUeXBlID0gKHR5cGUpID0+IHR5cGUuaW5jbHVkZXMoXCI6OlwiKTtcbnZhciBnZXRBcnJheVR5cGUgPSAodHlwZSkgPT4ge1xuICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHR5cGUuc3Vic3RyaW5nKHR5cGUuaW5kZXhPZihcIjxcIikgKyAxLCB0eXBlLmxhc3RJbmRleE9mKFwiPlwiKSk7XG4gIH1cbiAgcmV0dXJuIHR5cGUucmVwbGFjZShcIipcIiwgXCJcIik7XG59O1xuZnVuY3Rpb24gaXNDYWlybzFBYmkoYWJpKSB7XG4gIGNvbnN0IHsgY2Fpcm8gfSA9IGdldEFiaUNvbnRyYWN0VmVyc2lvbihhYmkpO1xuICBpZiAoY2Fpcm8gPT09IHZvaWQgMCkge1xuICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGRldGVybWluZSBDYWlybyB2ZXJzaW9uXCIpO1xuICB9XG4gIHJldHVybiBjYWlybyA9PT0gXCIxXCI7XG59XG5mdW5jdGlvbiBnZXRBYmlDb250cmFjdFZlcnNpb24oYWJpKSB7XG4gIGlmIChhYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogXCIyXCIgfTtcbiAgfVxuICBjb25zdCB0ZXN0RnVuY3Rpb24gPSBhYmkuZmluZChcbiAgICAoaXQpID0+IGl0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiAoaXQuaW5wdXRzLmxlbmd0aCB8fCBpdC5vdXRwdXRzLmxlbmd0aClcbiAgKTtcbiAgaWYgKCF0ZXN0RnVuY3Rpb24pIHtcbiAgICByZXR1cm4geyBjYWlybzogdm9pZCAwLCBjb21waWxlcjogdm9pZCAwIH07XG4gIH1cbiAgY29uc3QgaW8gPSB0ZXN0RnVuY3Rpb24uaW5wdXRzLmxlbmd0aCA/IHRlc3RGdW5jdGlvbi5pbnB1dHMgOiB0ZXN0RnVuY3Rpb24ub3V0cHV0cztcbiAgaWYgKGlzQ2Fpcm8xVHlwZShpb1swXS50eXBlKSkge1xuICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IFwiMVwiIH07XG4gIH1cbiAgcmV0dXJuIHsgY2Fpcm86IFwiMFwiLCBjb21waWxlcjogXCIwXCIgfTtcbn1cbnZhciB1aW50MjU2ID0gKGl0KSA9PiB7XG4gIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KGl0KS50b1VpbnQyNTZEZWNpbWFsU3RyaW5nKCk7XG59O1xudmFyIHVpbnQ1MTIgPSAoaXQpID0+IHtcbiAgcmV0dXJuIG5ldyBDYWlyb1VpbnQ1MTIoaXQpLnRvVWludDUxMkRlY2ltYWxTdHJpbmcoKTtcbn07XG52YXIgdHVwbGUgPSAoLi4uYXJncykgPT4gKHsgLi4uYXJncyB9KTtcbmZ1bmN0aW9uIGZlbHQoaXQpIHtcbiAgcmV0dXJuIENhaXJvRmVsdChpdCk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvQ3VzdG9tRW51bS50c1xudmFyIENhaXJvQ3VzdG9tRW51bSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIGRpcmVjdCByZWFkb25seSBhY2Nlc3MgdG8gdmFyaWFudHMgb2YgdGhlIENhaXJvIEN1c3RvbSBFbnVtLlxuICAgKiBAcmV0dXJucyBhIHZhbHVlIG9mIHR5cGUgYW55XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3Qgc3VjY2Vzc1ZhbHVlID0gbXlDYWlyb0VudW0udmFyaWFudC5TdWNjZXNzO1xuICAgKi9cbiAgdmFyaWFudDtcbiAgLyoqXG4gICAqIEBwYXJhbSBlbnVtQ29udGVudCBhbiBvYmplY3Qgd2l0aCB0aGUgdmFyaWFudHMgYXMga2V5cyBhbmQgdGhlIGNvbnRlbnQgYXMgdmFsdWUuIE9ubHkgb25lIGNvbnRlbnQgc2hhbGwgYmUgZGVmaW5lZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVudW1Db250ZW50KSB7XG4gICAgY29uc3QgdmFyaWFudHNMaXN0ID0gT2JqZWN0LnZhbHVlcyhlbnVtQ29udGVudCk7XG4gICAgaWYgKHZhcmlhbnRzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRW51bSBtdXN0IGhhdmUgYXQgbGVhc3QgMSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBuYkFjdGl2ZVZhcmlhbnRzID0gdmFyaWFudHNMaXN0LmZpbHRlcihcbiAgICAgIChjb250ZW50KSA9PiB0eXBlb2YgY29udGVudCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICkubGVuZ3RoO1xuICAgIGlmIChuYkFjdGl2ZVZhcmlhbnRzICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGV4YWN0bHkgb25lIGFjdGl2ZSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICB0aGlzLnZhcmlhbnQgPSBlbnVtQ29udGVudDtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFudCk7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IHR5cGVvZiBpdGVtWzFdICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVWYXJpYW50WzFdO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIGN1c3RvbSBFbnVtLlxuICAgKi9cbiAgYWN0aXZlVmFyaWFudCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFudCk7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IHR5cGVvZiBpdGVtWzFdICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlVmFyaWFudFswXTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9PcHRpb24udHNcbnZhciBDYWlyb09wdGlvblZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gKChDYWlyb09wdGlvblZhcmlhbnQyKSA9PiB7XG4gIENhaXJvT3B0aW9uVmFyaWFudDJbQ2Fpcm9PcHRpb25WYXJpYW50MltcIlNvbWVcIl0gPSAwXSA9IFwiU29tZVwiO1xuICBDYWlyb09wdGlvblZhcmlhbnQyW0NhaXJvT3B0aW9uVmFyaWFudDJbXCJOb25lXCJdID0gMV0gPSBcIk5vbmVcIjtcbiAgcmV0dXJuIENhaXJvT3B0aW9uVmFyaWFudDI7XG59KShDYWlyb09wdGlvblZhcmlhbnQgfHwge30pO1xudmFyIENhaXJvT3B0aW9uID0gY2xhc3Mge1xuICBTb21lO1xuICBOb25lO1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50LCBzb21lQ29udGVudCkge1xuICAgIGlmICghKHZhcmlhbnQgaW4gQ2Fpcm9PcHRpb25WYXJpYW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdmFyaWFudCA6IHNob3VsZCBiZSBDYWlyb09wdGlvblZhcmlhbnQuU29tZSBvciAuTm9uZS5cIik7XG4gICAgfVxuICAgIGlmICh2YXJpYW50ID09PSAwIC8qIFNvbWUgKi8pIHtcbiAgICAgIGlmICh0eXBlb2Ygc29tZUNvbnRlbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgY3JlYXRpb24gb2YgYSBDYWlybyBPcHRpb24gd2l0aCBcIlNvbWVcIiB2YXJpYW50IG5lZWRzIGEgY29udGVudCBhcyBpbnB1dC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLlNvbWUgPSBzb21lQ29udGVudDtcbiAgICAgIHRoaXMuTm9uZSA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5Tb21lID0gdm9pZCAwO1xuICAgICAgdGhpcy5Ob25lID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gY3VzdG9tIEVudW0uXG4gICAqICBJZiBOb25lLCByZXR1cm5zICd1bmRlZmluZWQnLlxuICAgKi9cbiAgdW53cmFwKCkge1xuICAgIGlmICh0aGlzLk5vbmUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLlNvbWU7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzU29tZScuXG4gICAqL1xuICBpc1NvbWUoKSB7XG4gICAgcmV0dXJuICEodHlwZW9mIHRoaXMuU29tZSA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzTm9uZScuXG4gICAqL1xuICBpc05vbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuTm9uZSA9PT0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9SZXN1bHQudHNcbnZhciBDYWlyb1Jlc3VsdFZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gKChDYWlyb1Jlc3VsdFZhcmlhbnQyKSA9PiB7XG4gIENhaXJvUmVzdWx0VmFyaWFudDJbQ2Fpcm9SZXN1bHRWYXJpYW50MltcIk9rXCJdID0gMF0gPSBcIk9rXCI7XG4gIENhaXJvUmVzdWx0VmFyaWFudDJbQ2Fpcm9SZXN1bHRWYXJpYW50MltcIkVyclwiXSA9IDFdID0gXCJFcnJcIjtcbiAgcmV0dXJuIENhaXJvUmVzdWx0VmFyaWFudDI7XG59KShDYWlyb1Jlc3VsdFZhcmlhbnQgfHwge30pO1xudmFyIENhaXJvUmVzdWx0ID0gY2xhc3Mge1xuICBPaztcbiAgRXJyO1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50LCByZXN1bHRDb250ZW50KSB7XG4gICAgaWYgKCEodmFyaWFudCBpbiBDYWlyb1Jlc3VsdFZhcmlhbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyB2YXJpYW50IDogc2hvdWxkIGJlIENhaXJvUmVzdWx0VmFyaWFudC5PayBvciAuRXJyLlwiKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09IDAgLyogT2sgKi8pIHtcbiAgICAgIHRoaXMuT2sgPSByZXN1bHRDb250ZW50O1xuICAgICAgdGhpcy5FcnIgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuT2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLkVyciA9IHJlc3VsdENvbnRlbnQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIFJlc3VsdC5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuT2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLk9rO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuRXJyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5FcnI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJvdGggUmVzdWx0Lk9rIGFuZCAuRXJyIGFyZSB1bmRlZmluZWQuIE5vdCBhdXRob3JpemVkLlwiKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsaWQgdmFyaWFudCBpcyAnT2snLlxuICAgKi9cbiAgaXNPaygpIHtcbiAgICByZXR1cm4gISh0eXBlb2YgdGhpcy5PayA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzRXJyJy5cbiAgICovXG4gIGlzRXJyKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLkVyciA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9mb3JtYXR0ZXIudHNcbnZhciBndWFyZCA9IHtcbiAgaXNCTjogKGRhdGEsIHR5cGUsIGtleSkgPT4ge1xuICAgIGlmICghaXNCaWdJbnQoZGF0YVtrZXldKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYERhdGEgYW5kIGZvcm1hdHRlciBtaXNtYXRjaCBvbiAke2tleX06JHt0eXBlW2tleV19LCBleHBlY3RlZCByZXNwb25zZSBkYXRhICR7a2V5fToke2RhdGFba2V5XX0gdG8gYmUgQk4gaW5zdGVhZCBpdCBpcyAke3R5cGVvZiBkYXRhW2tleV19YFxuICAgICAgKTtcbiAgfSxcbiAgdW5rbm93bjogKGRhdGEsIHR5cGUsIGtleSkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGZvcm1hdHRlciB0eXBlIG9uICR7a2V5fToke3R5cGVba2V5XX0gZm9yIGRhdGEgJHtrZXl9OiR7ZGF0YVtrZXldfWApO1xuICB9XG59O1xuZnVuY3Rpb24gZm9ybWF0dGVyKGRhdGEsIHR5cGUsIHNhbWVUeXBlKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgZWxUeXBlID0gc2FtZVR5cGUgPz8gdHlwZVtrZXldO1xuICAgIGlmICghKGtleSBpbiB0eXBlKSAmJiAhc2FtZVR5cGUpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBpZiAoZWxUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pKSB7XG4gICAgICAgIGNvbnN0IGFycmF5U3RyID0gZm9ybWF0dGVyKFxuICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICBkYXRhW2tleV0ubWFwKChfKSA9PiBlbFR5cGUpXG4gICAgICAgICk7XG4gICAgICAgIGFjY1trZXldID0gT2JqZWN0LnZhbHVlcyhhcnJheVN0cikuam9pbihcIlwiKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGd1YXJkLmlzQk4oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgIGFjY1trZXldID0gZGVjb2RlU2hvcnRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKGVsVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZ3VhcmQuaXNCTihkYXRhLCB0eXBlLCBrZXkpO1xuICAgICAgYWNjW2tleV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbFR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYWNjW2tleV0gPSBlbFR5cGUodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxUeXBlKSkge1xuICAgICAgY29uc3QgYXJyYXlPYmogPSBmb3JtYXR0ZXIoZGF0YVtrZXldLCBlbFR5cGUsIGVsVHlwZVswXSk7XG4gICAgICBhY2Nba2V5XSA9IE9iamVjdC52YWx1ZXMoYXJyYXlPYmopO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGFjY1trZXldID0gZm9ybWF0dGVyKGRhdGFba2V5XSwgZWxUeXBlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGd1YXJkLnVua25vd24oZGF0YSwgdHlwZSwga2V5KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTAtMS4xLjAudHNcbnZhciBBYmlQYXJzZXIxID0gY2xhc3Mge1xuICBhYmk7XG4gIGNvbnN0cnVjdG9yKGFiaSkge1xuICAgIHRoaXMuYWJpID0gYWJpO1xuICB9XG4gIC8qKlxuICAgKiBhYmkgbWV0aG9kIGlucHV0cyBsZW5ndGggd2l0aG91dCAnX2xlbicgaW5wdXRzXG4gICAqIGNhaXJvIDAgcmVkdWNlclxuICAgKiBAcGFyYW0gYWJpTWV0aG9kIEZ1bmN0aW9uQWJpXG4gICAqIEByZXR1cm5zIG51bWJlclxuICAgKi9cbiAgbWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCkge1xuICAgIHJldHVybiBhYmlNZXRob2QuaW5wdXRzLnJlZHVjZSgoYWNjLCBpbnB1dCkgPT4gIWlzTGVuKGlucHV0Lm5hbWUpID8gYWNjICsgMSA6IGFjYywgMCk7XG4gIH1cbiAgLyoqXG4gICAqIGdldCBtZXRob2QgZGVmaW5pdGlvbiBmcm9tIGFiaVxuICAgKiBAcGFyYW0gbmFtZSBzdHJpbmdcbiAgICogQHJldHVybnMgRnVuY3Rpb25BYmkgfCB1bmRlZmluZWRcbiAgICovXG4gIGdldE1ldGhvZChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJpLmZpbmQoKGl0KSA9PiBpdC5uYW1lID09PSBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IEFiaSBpbiBsZWdhY3kgZm9ybWF0XG4gICAqIEByZXR1cm5zIEFiaVxuICAgKi9cbiAgZ2V0TGVnYWN5Rm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmFiaTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3BhcnNlci9wYXJzZXItMi4wLjAudHNcbnZhciBBYmlQYXJzZXIyID0gY2xhc3Mge1xuICBhYmk7XG4gIGNvbnN0cnVjdG9yKGFiaSkge1xuICAgIHRoaXMuYWJpID0gYWJpO1xuICB9XG4gIC8qKlxuICAgKiBhYmkgbWV0aG9kIGlucHV0cyBsZW5ndGhcbiAgICogQHBhcmFtIGFiaU1ldGhvZCBGdW5jdGlvbkFiaVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIG1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpIHtcbiAgICByZXR1cm4gYWJpTWV0aG9kLmlucHV0cy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIGdldCBtZXRob2QgZGVmaW5pdGlvbiBmcm9tIGFiaVxuICAgKiBAcGFyYW0gbmFtZSBzdHJpbmdcbiAgICogQHJldHVybnMgRnVuY3Rpb25BYmkgfCB1bmRlZmluZWRcbiAgICovXG4gIGdldE1ldGhvZChuYW1lKSB7XG4gICAgY29uc3QgaW50ZiA9IHRoaXMuYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKTtcbiAgICByZXR1cm4gaW50Zi5pdGVtcy5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmkuZmxhdE1hcCgoZSkgPT4ge1xuICAgICAgaWYgKGUudHlwZSA9PT0gXCJpbnRlcmZhY2VcIikge1xuICAgICAgICByZXR1cm4gZS5pdGVtcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL2luZGV4LnRzXG5mdW5jdGlvbiBjcmVhdGVBYmlQYXJzZXIoYWJpKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBnZXRBYmlWZXJzaW9uKGFiaSk7XG4gIGlmICh2ZXJzaW9uID09PSAwIHx8IHZlcnNpb24gPT09IDEpIHtcbiAgICByZXR1cm4gbmV3IEFiaVBhcnNlcjEoYWJpKTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMikge1xuICAgIHJldHVybiBuZXcgQWJpUGFyc2VyMihhYmkpO1xuICB9XG4gIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBBQkkgdmVyc2lvbiAke3ZlcnNpb259YCk7XG59XG5mdW5jdGlvbiBnZXRBYmlWZXJzaW9uKGFiaSkge1xuICBpZiAoYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKSlcbiAgICByZXR1cm4gMjtcbiAgaWYgKGlzQ2Fpcm8xQWJpKGFiaSkpXG4gICAgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzQ2FsbGRhdGEsIGFiaU1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kID09PSBcImNvbnN0cnVjdG9yXCIgJiYgIWFiaU1ldGhvZCAmJiAhYXJnc0NhbGxkYXRhLmxlbmd0aDtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3R1cGxlLnRzXG5mdW5jdGlvbiBwYXJzZU5hbWVkVHVwbGUobmFtZWRUdXBsZSkge1xuICBjb25zdCBuYW1lID0gbmFtZWRUdXBsZS5zdWJzdHJpbmcoMCwgbmFtZWRUdXBsZS5pbmRleE9mKFwiOlwiKSk7XG4gIGNvbnN0IHR5cGUgPSBuYW1lZFR1cGxlLnN1YnN0cmluZyhuYW1lLmxlbmd0aCArIFwiOlwiLmxlbmd0aCk7XG4gIHJldHVybiB7IG5hbWUsIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3ViVHVwbGUocykge1xuICBpZiAoIXMuaW5jbHVkZXMoXCIoXCIpKVxuICAgIHJldHVybiB7IHN1YlR1cGxlOiBbXSwgcmVzdWx0OiBzIH07XG4gIGNvbnN0IHN1YlR1cGxlID0gW107XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICBpZiAoc1tpXSA9PT0gXCIoXCIpIHtcbiAgICAgIGxldCBjb3VudGVyID0gMTtcbiAgICAgIGNvbnN0IGxCcmFja2V0ID0gaTtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjb3VudGVyKSB7XG4gICAgICAgIGlmIChzW2ldID09PSBcIilcIilcbiAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIGlmIChzW2ldID09PSBcIihcIilcbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHN1YlR1cGxlLnB1c2gocy5zdWJzdHJpbmcobEJyYWNrZXQsIGkpKTtcbiAgICAgIHJlc3VsdCArPSBcIiBcIjtcbiAgICAgIGktLTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHNbaV07XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4ge1xuICAgIHN1YlR1cGxlLFxuICAgIHJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdENhaXJvMFR1cGxlKHR5cGUpIHtcbiAgY29uc3QgY2xlYW5UeXBlID0gdHlwZS5yZXBsYWNlKC9cXHMvZywgXCJcIikuc2xpY2UoMSwgLTEpO1xuICBjb25zdCB7IHN1YlR1cGxlLCByZXN1bHQgfSA9IHBhcnNlU3ViVHVwbGUoY2xlYW5UeXBlKTtcbiAgbGV0IHJlY29tcG9zZWQgPSByZXN1bHQuc3BsaXQoXCIsXCIpLm1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gc3ViVHVwbGUubGVuZ3RoID8gaXQucmVwbGFjZShcIiBcIiwgc3ViVHVwbGUuc2hpZnQoKSkgOiBpdDtcbiAgfSk7XG4gIGlmIChpc1R5cGVOYW1lZFR1cGxlKHR5cGUpKSB7XG4gICAgcmVjb21wb3NlZCA9IHJlY29tcG9zZWQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZU5hbWVkVHVwbGUoaXQpKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgcmV0dXJuIHJlY29tcG9zZWQ7XG59XG5mdW5jdGlvbiBnZXRDbG9zdXJlT2Zmc2V0KGlucHV0LCBvcGVuLCBjbG9zZSkge1xuICBmb3IgKGxldCBpID0gMCwgY291bnRlciA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpbnB1dFtpXSA9PT0gb3Blbikge1xuICAgICAgY291bnRlcisrO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPT09IGNsb3NlICYmIC0tY291bnRlciA9PT0gMCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG59XG5mdW5jdGlvbiBleHRyYWN0Q2Fpcm8xVHVwbGUodHlwZSkge1xuICBjb25zdCBpbnB1dCA9IHR5cGUuc2xpY2UoMSwgLTEpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gIGxldCBsaW1pdEluZGV4O1xuICB3aGlsZSAoY3VycmVudEluZGV4IDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIGlucHV0W2N1cnJlbnRJbmRleF0gPT09IFwiKFwiOiB7XG4gICAgICAgIGxpbWl0SW5kZXggPSBjdXJyZW50SW5kZXggKyBnZXRDbG9zdXJlT2Zmc2V0KGlucHV0LnNsaWNlKGN1cnJlbnRJbmRleCksIFwiKFwiLCBcIilcIikgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgKGlucHV0LnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6PFwiLCBjdXJyZW50SW5kZXgpIHx8IGlucHV0LnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OjxcIiwgY3VycmVudEluZGV4KSB8fCBpbnB1dC5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb246OjxcIiwgY3VycmVudEluZGV4KSk6IHtcbiAgICAgICAgbGltaXRJbmRleCA9IGN1cnJlbnRJbmRleCArIGdldENsb3N1cmVPZmZzZXQoaW5wdXQuc2xpY2UoY3VycmVudEluZGV4KSwgXCI8XCIsIFwiPlwiKSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBjb21tYUluZGV4ID0gaW5wdXQuaW5kZXhPZihcIixcIiwgY3VycmVudEluZGV4KTtcbiAgICAgICAgbGltaXRJbmRleCA9IGNvbW1hSW5kZXggIT09IC0xID8gY29tbWFJbmRleCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2goaW5wdXQuc2xpY2UoY3VycmVudEluZGV4LCBsaW1pdEluZGV4KSk7XG4gICAgY3VycmVudEluZGV4ID0gbGltaXRJbmRleCArIDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKHR5cGUpIHtcbiAgaWYgKGlzQ2Fpcm8xVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBleHRyYWN0Q2Fpcm8xVHVwbGUodHlwZSk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhY3RDYWlybzBUdXBsZSh0eXBlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3Byb3BlcnR5T3JkZXIudHNcbmZ1bmN0aW9uIGVycm9yVTI1NihrZXkpIHtcbiAgcmV0dXJuIEVycm9yKFxuICAgIGBZb3VyIG9iamVjdCBpbmNsdWRlcyB0aGUgcHJvcGVydHkgOiAke2tleX0sIGNvbnRhaW5pbmcgYW4gVWludDI1NiBvYmplY3Qgd2l0aG91dCB0aGUgJ2xvdycgYW5kICdoaWdoJyBrZXlzLmBcbiAgKTtcbn1cbmZ1bmN0aW9uIGVycm9yVTUxMihrZXkpIHtcbiAgcmV0dXJuIEVycm9yKFxuICAgIGBZb3VyIG9iamVjdCBpbmNsdWRlcyB0aGUgcHJvcGVydHkgOiAke2tleX0sIGNvbnRhaW5pbmcgYW4gVWludDUxMiBvYmplY3Qgd2l0aG91dCB0aGUgJ2xpbWIwJyB0byAnbGltYjMnIGtleXMuYFxuICApO1xufVxuZnVuY3Rpb24gb3JkZXJQcm9wc0J5QWJpKHVub3JkZXJlZE9iamVjdCwgYWJpT2ZPYmplY3QsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGNvbnN0IG9yZGVySW5wdXQgPSAodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSkgPT4ge1xuICAgIGlmIChpc1R5cGVBcnJheShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyQXJyYXkodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFbnVtKGFiaVR5cGUsIGVudW1zKSkge1xuICAgICAgY29uc3QgYWJpT2JqID0gZW51bXNbYWJpVHlwZV07XG4gICAgICByZXR1cm4gb3JkZXJFbnVtKHVub3JkZXJlZEl0ZW0sIGFiaU9iaik7XG4gICAgfVxuICAgIGlmIChpc1R5cGVUdXBsZShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyVHVwbGUodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFdGhBZGRyZXNzKGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZUJ5dGVBcnJheShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gICAgfVxuICAgIGlmIChpc1R5cGVTZWNwMjU2azFQb2ludChhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gICAgfVxuICAgIGlmIChDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKGFiaVR5cGUpKSB7XG4gICAgICBjb25zdCB1MjU2ID0gdW5vcmRlcmVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgdTI1NiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gdTI1NjtcbiAgICAgIH1cbiAgICAgIGlmICghKFwibG93XCIgaW4gdTI1NiAmJiBcImhpZ2hcIiBpbiB1MjU2KSkge1xuICAgICAgICB0aHJvdyBlcnJvclUyNTYoYWJpVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBsb3c6IHUyNTYubG93LCBoaWdoOiB1MjU2LmhpZ2ggfTtcbiAgICB9XG4gICAgaWYgKENhaXJvVWludDUxMi5pc0FiaVR5cGUoYWJpVHlwZSkpIHtcbiAgICAgIGNvbnN0IHU1MTIgPSB1bm9yZGVyZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiB1NTEyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB1NTEyO1xuICAgICAgfVxuICAgICAgaWYgKCFbXCJsaW1iMFwiLCBcImxpbWIxXCIsIFwibGltYjJcIiwgXCJsaW1iM1wiXS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gdTUxMikpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JVNTEyKGFiaVR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbGltYjA6IHU1MTIubGltYjAsIGxpbWIxOiB1NTEyLmxpbWIxLCBsaW1iMjogdTUxMi5saW1iMiwgbGltYjM6IHU1MTIubGltYjMgfTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVN0cnVjdChhYmlUeXBlLCBzdHJ1Y3RzKSkge1xuICAgICAgY29uc3QgYWJpT2ZTdHJ1Y3QgPSBzdHJ1Y3RzW2FiaVR5cGVdLm1lbWJlcnM7XG4gICAgICByZXR1cm4gb3JkZXJTdHJ1Y3QodW5vcmRlcmVkSXRlbSwgYWJpT2ZTdHJ1Y3QpO1xuICAgIH1cbiAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgfTtcbiAgY29uc3Qgb3JkZXJTdHJ1Y3QgPSAodW5vcmRlcmVkT2JqZWN0MiwgYWJpT2JqZWN0KSA9PiB7XG4gICAgY29uc3Qgb3JkZXJlZE9iamVjdDIgPSBhYmlPYmplY3QucmVkdWNlKChvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbSkgPT4ge1xuICAgICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbS5uYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA/PyB1bm9yZGVyZWRPYmplY3QyW2FiaVBhcmFtLm5hbWVdXG4gICAgICB9KTtcbiAgICAgIGlmICh1bm9yZGVyZWRPYmplY3QyW2FiaVBhcmFtLm5hbWVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChpc0NhaXJvMVR5cGUoYWJpUGFyYW0udHlwZSkgfHwgIWlzTGVuKGFiaVBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYFlvdXIgb2JqZWN0IG5lZWRzIGEgcHJvcGVydHkgd2l0aCBrZXkgOiAke2FiaVBhcmFtLm5hbWV9IC5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0UHJvcGVydHkob3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyW2FiaVBhcmFtLm5hbWVdLCBhYmlQYXJhbS50eXBlKSk7XG4gICAgICByZXR1cm4gb3JkZXJlZE9iamVjdDtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3QyO1xuICB9O1xuICBmdW5jdGlvbiBvcmRlckFycmF5KG15QXJyYXksIGFiaVBhcmFtKSB7XG4gICAgY29uc3QgdHlwZUluQXJyYXkgPSBnZXRBcnJheVR5cGUoYWJpUGFyYW0pO1xuICAgIGlmIChpc1N0cmluZyhteUFycmF5KSkge1xuICAgICAgcmV0dXJuIG15QXJyYXk7XG4gICAgfVxuICAgIHJldHVybiBteUFycmF5Lm1hcCgobXlFbGVtKSA9PiBvcmRlcklucHV0KG15RWxlbSwgdHlwZUluQXJyYXkpKTtcbiAgfVxuICBmdW5jdGlvbiBvcmRlclR1cGxlKHVub3JkZXJlZE9iamVjdDIsIGFiaVBhcmFtKSB7XG4gICAgY29uc3QgdHlwZUxpc3QgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyhhYmlQYXJhbSk7XG4gICAgY29uc3Qgb3JkZXJlZE9iamVjdDIgPSB0eXBlTGlzdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVR5cGVDYWlyb1gsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBteU9iaktleXMgPSBPYmplY3Qua2V5cyh1bm9yZGVyZWRPYmplY3QyKTtcbiAgICAgIGNvbnN0IHNldFByb3BlcnR5ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJlZE9iamVjdCwgaW5kZXgudG9TdHJpbmcoKSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUgPz8gdW5vcmRlcmVkT2JqZWN0MltteU9iaktleXNbaW5kZXhdXVxuICAgICAgfSk7XG4gICAgICBjb25zdCBhYmlUeXBlID0gYWJpVHlwZUNhaXJvWD8udHlwZSA/IGFiaVR5cGVDYWlyb1gudHlwZSA6IGFiaVR5cGVDYWlyb1g7XG4gICAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDJbbXlPYmpLZXlzW2luZGV4XV0sIGFiaVR5cGUpKTtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gb3JkZXJlZE9iamVjdDI7XG4gIH1cbiAgY29uc3Qgb3JkZXJFbnVtID0gKHVub3JkZXJlZE9iamVjdDIsIGFiaU9iamVjdCkgPT4ge1xuICAgIGlmIChpc1R5cGVSZXN1bHQoYWJpT2JqZWN0Lm5hbWUpKSB7XG4gICAgICBjb25zdCB1bm9yZGVyZWRSZXN1bHQgPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgICAgY29uc3QgcmVzdWx0T2tUeXBlID0gYWJpT2JqZWN0Lm5hbWUuc3Vic3RyaW5nKFxuICAgICAgICBhYmlPYmplY3QubmFtZS5pbmRleE9mKFwiPFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmxhc3RJbmRleE9mKFwiLFwiKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3VsdEVyclR5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCIsXCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHVub3JkZXJlZFJlc3VsdC5pc09rKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWlyb1Jlc3VsdChcbiAgICAgICAgICAwIC8qIE9rICovLFxuICAgICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0Mi51bndyYXAoKSwgcmVzdWx0T2tUeXBlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDYWlyb1Jlc3VsdChcbiAgICAgICAgMSAvKiBFcnIgKi8sXG4gICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0Mi51bndyYXAoKSwgcmVzdWx0RXJyVHlwZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVPcHRpb24oYWJpT2JqZWN0Lm5hbWUpKSB7XG4gICAgICBjb25zdCB1bm9yZGVyZWRPcHRpb24gPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgICAgY29uc3QgcmVzdWx0U29tZVR5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHVub3JkZXJlZE9wdGlvbi5pc1NvbWUoKSkge1xuICAgICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKFxuICAgICAgICAgIDAgLyogU29tZSAqLyxcbiAgICAgICAgICBvcmRlcklucHV0KHVub3JkZXJlZE9wdGlvbi51bndyYXAoKSwgcmVzdWx0U29tZVR5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKDEgLyogTm9uZSAqLywge30pO1xuICAgIH1cbiAgICBjb25zdCB1bm9yZGVyZWRDdXN0b21FbnVtID0gdW5vcmRlcmVkT2JqZWN0MjtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHVub3JkZXJlZEN1c3RvbUVudW0udmFyaWFudCk7XG4gICAgY29uc3QgbmV3RW50cmllcyA9IHZhcmlhbnRzLm1hcCgodmFyaWFudCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YXJpYW50WzFdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50O1xuICAgICAgfVxuICAgICAgY29uc3QgdmFyaWFudFR5cGUgPSBhYmlPYmplY3QudHlwZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC50eXBlLmxhc3RJbmRleE9mKFwiPFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC50eXBlLmxhc3RJbmRleE9mKFwiPlwiKVxuICAgICAgKTtcbiAgICAgIGlmICh2YXJpYW50VHlwZSA9PT0gXCIoKVwiKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt2YXJpYW50WzBdLCBvcmRlcklucHV0KHVub3JkZXJlZEN1c3RvbUVudW0udW53cmFwKCksIHZhcmlhbnRUeXBlKV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBDYWlyb0N1c3RvbUVudW0oT2JqZWN0LmZyb21FbnRyaWVzKG5ld0VudHJpZXMpKTtcbiAgfTtcbiAgY29uc3QgZmluYWxPcmRlcmVkT2JqZWN0ID0gYWJpT2ZPYmplY3QucmVkdWNlKChvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbSkgPT4ge1xuICAgIGNvbnN0IHNldFByb3BlcnR5ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0ubmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgaWYgKGlzTGVuKGFiaVBhcmFtLm5hbWUpICYmICFpc0NhaXJvMVR5cGUoYWJpUGFyYW0udHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH1cbiAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdFthYmlQYXJhbS5uYW1lXSwgYWJpUGFyYW0udHlwZSkpO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICB9LCB7fSk7XG4gIHJldHVybiBmaW5hbE9yZGVyZWRPYmplY3Q7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXF1ZXN0UGFyc2VyLnRzXG5mdW5jdGlvbiBwYXJzZUJhc2VUeXBlcyh0eXBlLCB2YWwpIHtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpOlxuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYodmFsKS50b0FwaVJlcXVlc3QoKTtcbiAgICBjYXNlIENhaXJvVWludDUxMi5pc0FiaVR5cGUodHlwZSk6XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDUxMih2YWwpLnRvQXBpUmVxdWVzdCgpO1xuICAgIGNhc2UgaXNUeXBlQnl0ZXMzMSh0eXBlKTpcbiAgICAgIHJldHVybiBlbmNvZGVTaG9ydFN0cmluZyh2YWwudG9TdHJpbmcoKSk7XG4gICAgY2FzZSBpc1R5cGVTZWNwMjU2azFQb2ludCh0eXBlKToge1xuICAgICAgY29uc3QgcHViS2V5RVRIID0gcmVtb3ZlSGV4UHJlZml4KHRvSGV4KHZhbCkpLnBhZFN0YXJ0KDEyOCwgXCIwXCIpO1xuICAgICAgY29uc3QgcHViS2V5RVRIeSA9IHVpbnQyNTYoYWRkSGV4UHJlZml4KHB1YktleUVUSC5zbGljZSgtNjQpKSk7XG4gICAgICBjb25zdCBwdWJLZXlFVEh4ID0gdWludDI1NihhZGRIZXhQcmVmaXgocHViS2V5RVRILnNsaWNlKDAsIC02NCkpKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGZlbHQocHViS2V5RVRIeC5sb3cpLFxuICAgICAgICBmZWx0KHB1YktleUVUSHguaGlnaCksXG4gICAgICAgIGZlbHQocHViS2V5RVRIeS5sb3cpLFxuICAgICAgICBmZWx0KHB1YktleUVUSHkuaGlnaClcbiAgICAgIF07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmVsdCh2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVR1cGxlKGVsZW1lbnQsIHR5cGVTdHIpIHtcbiAgY29uc3QgbWVtYmVyVHlwZXMgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyh0eXBlU3RyKTtcbiAgY29uc3QgZWxlbWVudHMgPSBPYmplY3QudmFsdWVzKGVsZW1lbnQpO1xuICBpZiAoZWxlbWVudHMubGVuZ3RoICE9PSBtZW1iZXJUeXBlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGBQYXJzZVR1cGxlOiBwcm92aWRlZCBhbmQgZXhwZWN0ZWQgYWJpIHR1cGxlIHNpemUgZG8gbm90IG1hdGNoLlxuICAgICAgcHJvdmlkZWQ6ICR7ZWxlbWVudHN9IFxuICAgICAgZXhwZWN0ZWQ6ICR7bWVtYmVyVHlwZXN9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1lbWJlclR5cGVzLm1hcCgoaXQsIGR4KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnRzW2R4XSxcbiAgICAgIHR5cGU6IGl0LnR5cGUgPz8gaXRcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQnl0ZUFycmF5KGVsZW1lbnQpIHtcbiAgY29uc3QgbXlCeXRlQXJyYXkgPSBieXRlQXJyYXlGcm9tU3RyaW5nKGVsZW1lbnQpO1xuICByZXR1cm4gW1xuICAgIG15Qnl0ZUFycmF5LmRhdGEubGVuZ3RoLnRvU3RyaW5nKCksXG4gICAgLi4ubXlCeXRlQXJyYXkuZGF0YS5tYXAoKGJuKSA9PiBibi50b1N0cmluZygpKSxcbiAgICBteUJ5dGVBcnJheS5wZW5kaW5nX3dvcmQudG9TdHJpbmcoKSxcbiAgICBteUJ5dGVBcnJheS5wZW5kaW5nX3dvcmRfbGVuLnRvU3RyaW5nKClcbiAgXTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbGRhdGFWYWx1ZShlbGVtZW50LCB0eXBlLCBzdHJ1Y3RzLCBlbnVtcykge1xuICBpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgRXJyb3IoYE1pc3NpbmcgcGFyYW1ldGVyIGZvciB0eXBlICR7dHlwZX1gKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5wdXNoKGZlbHQoZWxlbWVudC5sZW5ndGgpKTtcbiAgICBjb25zdCBhcnJheVR5cGUgPSBnZXRBcnJheVR5cGUodHlwZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhVmFsdWUoaXQsIGFycmF5VHlwZSwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9LCByZXN1bHQpO1xuICB9XG4gIGlmIChzdHJ1Y3RzW3R5cGVdICYmIHN0cnVjdHNbdHlwZV0ubWVtYmVycy5sZW5ndGgpIHtcbiAgICBpZiAoQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYoZWxlbWVudCkudG9BcGlSZXF1ZXN0KCk7XG4gICAgfVxuICAgIGlmIChDYWlyb1VpbnQ1MTIuaXNBYmlUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDUxMihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCIpXG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgZWxlbWVudCk7XG4gICAgaWYgKHR5cGUgPT09IFwiY29yZTo6Ynl0ZV9hcnJheTo6Qnl0ZUFycmF5XCIpXG4gICAgICByZXR1cm4gcGFyc2VCeXRlQXJyYXkoZWxlbWVudCk7XG4gICAgY29uc3QgeyBtZW1iZXJzIH0gPSBzdHJ1Y3RzW3R5cGVdO1xuICAgIGNvbnN0IHN1YkVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHJldHVybiBtZW1iZXJzLnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VDYWxsZGF0YVZhbHVlKHN1YkVsZW1lbnRbaXQubmFtZV0sIGl0LnR5cGUsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfSwgW10pO1xuICB9XG4gIGlmIChpc1R5cGVUdXBsZSh0eXBlKSkge1xuICAgIGNvbnN0IHR1cGxlZCA9IHBhcnNlVHVwbGUoZWxlbWVudCwgdHlwZSk7XG4gICAgcmV0dXJuIHR1cGxlZC5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBwYXJzZUNhbGxkYXRhVmFsdWUoaXQuZWxlbWVudCwgaXQudHlwZSwgc3RydWN0cywgZW51bXMpO1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VkRGF0YSk7XG4gICAgfSwgW10pO1xuICB9XG4gIGlmIChDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYoZWxlbWVudCkudG9BcGlSZXF1ZXN0KCk7XG4gIH1cbiAgaWYgKENhaXJvVWludDUxMi5pc0FiaVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gbmV3IENhaXJvVWludDUxMihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgfVxuICBpZiAoaXNUeXBlRW51bSh0eXBlLCBlbnVtcykpIHtcbiAgICBjb25zdCB7IHZhcmlhbnRzIH0gPSBlbnVtc1t0eXBlXTtcbiAgICBpZiAoaXNUeXBlT3B0aW9uKHR5cGUpKSB7XG4gICAgICBjb25zdCBteU9wdGlvbiA9IGVsZW1lbnQ7XG4gICAgICBpZiAobXlPcHRpb24uaXNTb21lKCkpIHtcbiAgICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MiA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJTb21lXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogT3B0aW9uIGhhcyBubyAnU29tZScgdmFyaWFudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlVmFyaWFudFNvbWUgPSBsaXN0VHlwZVZhcmlhbnQyLnR5cGU7XG4gICAgICAgIGlmICh0eXBlVmFyaWFudFNvbWUgPT09IFwiKClcIikge1xuICAgICAgICAgIHJldHVybiAwIC8qIFNvbWUgKi8udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIyID0gcGFyc2VDYWxsZGF0YVZhbHVlKFxuICAgICAgICAgIG15T3B0aW9uLnVud3JhcCgpLFxuICAgICAgICAgIHR5cGVWYXJpYW50U29tZSxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcjIpKSB7XG4gICAgICAgICAgcmV0dXJuIFswIC8qIFNvbWUgKi8udG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswIC8qIFNvbWUgKi8udG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gMSAvKiBOb25lICovLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVSZXN1bHQodHlwZSkpIHtcbiAgICAgIGNvbnN0IG15UmVzdWx0ID0gZWxlbWVudDtcbiAgICAgIGlmIChteVJlc3VsdC5pc09rKCkpIHtcbiAgICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MyA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJPa1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IFJlc3VsdCBoYXMgbm8gJ09rJyB2YXJpYW50LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVWYXJpYW50T2sgPSBsaXN0VHlwZVZhcmlhbnQzLnR5cGU7XG4gICAgICAgIGlmICh0eXBlVmFyaWFudE9rID09PSBcIigpXCIpIHtcbiAgICAgICAgICByZXR1cm4gMCAvKiBPayAqLy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjMgPSBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgICAgbXlSZXN1bHQudW53cmFwKCksXG4gICAgICAgICAgdHlwZVZhcmlhbnRPayxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcjMpKSB7XG4gICAgICAgICAgcmV0dXJuIFswIC8qIE9rICovLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCAvKiBPayAqLy50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXIzXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudDIgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IFwiRXJyXCIpO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFcnJvciBpbiBhYmkgOiBSZXN1bHQgaGFzIG5vICdFcnInIHZhcmlhbnQuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlVmFyaWFudEVyciA9IGxpc3RUeXBlVmFyaWFudDIudHlwZTtcbiAgICAgIGlmICh0eXBlVmFyaWFudEVyciA9PT0gXCIoKVwiKSB7XG4gICAgICAgIHJldHVybiAxIC8qIEVyciAqLy50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyMiA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShteVJlc3VsdC51bndyYXAoKSwgdHlwZVZhcmlhbnRFcnIsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcjIpKSB7XG4gICAgICAgIHJldHVybiBbMSAvKiBFcnIgKi8udG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gWzEgLyogRXJyICovLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjJdO1xuICAgIH1cbiAgICBjb25zdCBteUVudW0gPSBlbGVtZW50O1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSBteUVudW0uYWN0aXZlVmFyaWFudCgpO1xuICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gYWN0aXZlVmFyaWFudCk7XG4gICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IEVycm9yKGBOb3QgZmluZCBpbiBhYmkgOiBFbnVtIGhhcyBubyAnJHthY3RpdmVWYXJpYW50fScgdmFyaWFudC5gKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZUFjdGl2ZVZhcmlhbnQgPSBsaXN0VHlwZVZhcmlhbnQudHlwZTtcbiAgICBjb25zdCBudW1BY3RpdmVWYXJpYW50ID0gdmFyaWFudHMuZmluZEluZGV4KCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IGFjdGl2ZVZhcmlhbnQpO1xuICAgIGlmICh0eXBlQWN0aXZlVmFyaWFudCA9PT0gXCIoKVwiKSB7XG4gICAgICByZXR1cm4gbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIgPSBwYXJzZUNhbGxkYXRhVmFsdWUobXlFbnVtLnVud3JhcCgpLCB0eXBlQWN0aXZlVmFyaWFudCwgc3RydWN0cywgZW51bXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcikpIHtcbiAgICAgIHJldHVybiBbbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXJdO1xuICAgIH1cbiAgICByZXR1cm4gW251bUFjdGl2ZVZhcmlhbnQudG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyXTtcbiAgfVxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFyYW1ldGVyICR7ZWxlbWVudH0gZG8gbm90IGFsaWduIHdpdGggYWJpIHBhcmFtZXRlciAke3R5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gcGFyc2VDYWxsZGF0YUZpZWxkKGFyZ3NJdGVyYXRvciwgaW5wdXQsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gaW5wdXQ7XG4gIGxldCB7IHZhbHVlIH0gPSBhcmdzSXRlcmF0b3IubmV4dCgpO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUFycmF5KHR5cGUpOlxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAhaXNUZXh0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgQUJJIGV4cGVjdGVkIHBhcmFtZXRlciAke25hbWV9IHRvIGJlIGFycmF5IG9yIGxvbmcgc3RyaW5nLCBnb3QgJHt2YWx1ZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBzcGxpdExvbmdTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZSh2YWx1ZSwgaW5wdXQudHlwZSwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCB2YWx1ZSk7XG4gICAgY2FzZSAoaXNUeXBlU3RydWN0KHR5cGUsIHN0cnVjdHMpIHx8IGlzVHlwZVR1cGxlKHR5cGUpIHx8IENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSkgfHwgQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZSh0eXBlKSk6XG4gICAgICByZXR1cm4gcGFyc2VDYWxsZGF0YVZhbHVlKHZhbHVlLCB0eXBlLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgY2FzZSBpc1R5cGVFbnVtKHR5cGUsIGVudW1zKTpcbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICBlbnVtc1xuICAgICAgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbHVlKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcmVzcG9uc2VQYXJzZXIudHNcbmZ1bmN0aW9uIHBhcnNlQmFzZVR5cGVzMih0eXBlLCBpdCkge1xuICBsZXQgdGVtcDtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVCb29sKHR5cGUpOlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCb29sZWFuKEJpZ0ludCh0ZW1wKSk7XG4gICAgY2FzZSBDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpOlxuICAgICAgY29uc3QgbG93ID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgaGlnaCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KGxvdywgaGlnaCkudG9CaWdJbnQoKTtcbiAgICBjYXNlIENhaXJvVWludDUxMi5pc0FiaVR5cGUodHlwZSk6XG4gICAgICBjb25zdCBsaW1iMCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IGxpbWIxID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgbGltYjIgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBsaW1iMyA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGxpbWIwLCBsaW1iMSwgbGltYjIsIGxpbWIzKS50b0JpZ0ludCgpO1xuICAgIGNhc2UgdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjpcbiAgICAgIHRlbXAgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQmlnSW50KHRlbXApO1xuICAgIGNhc2UgdHlwZSA9PT0gXCJjb3JlOjpieXRlc18zMTo6Ynl0ZXMzMVwiOlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBkZWNvZGVTaG9ydFN0cmluZyh0ZW1wKTtcbiAgICBjYXNlIGlzVHlwZVNlY3AyNTZrMVBvaW50KHR5cGUpOlxuICAgICAgY29uc3QgeExvdyA9IHJlbW92ZUhleFByZWZpeChpdC5uZXh0KCkudmFsdWUpLnBhZFN0YXJ0KDMyLCBcIjBcIik7XG4gICAgICBjb25zdCB4SGlnaCA9IHJlbW92ZUhleFByZWZpeChpdC5uZXh0KCkudmFsdWUpLnBhZFN0YXJ0KDMyLCBcIjBcIik7XG4gICAgICBjb25zdCB5TG93ID0gcmVtb3ZlSGV4UHJlZml4KGl0Lm5leHQoKS52YWx1ZSkucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgIGNvbnN0IHlIaWdoID0gcmVtb3ZlSGV4UHJlZml4KGl0Lm5leHQoKS52YWx1ZSkucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgIGNvbnN0IHB1YksgPSBCaWdJbnQoYWRkSGV4UHJlZml4KHhIaWdoICsgeExvdyArIHlIaWdoICsgeUxvdykpO1xuICAgICAgcmV0dXJuIHB1Yks7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRlbXAgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQmlnSW50KHRlbXApO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWxlbWVudCwgc3RydWN0cywgZW51bXMpIHtcbiAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCIoKVwiKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmIChDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBsb3cgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICBjb25zdCBoaWdoID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYobG93LCBoaWdoKS50b0JpZ0ludCgpO1xuICB9XG4gIGlmIChDYWlyb1VpbnQ1MTIuaXNBYmlUeXBlKGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBsaW1iMCA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIGNvbnN0IGxpbWIxID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgY29uc3QgbGltYjIgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICBjb25zdCBsaW1iMyA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGxpbWIwLCBsaW1iMSwgbGltYjIsIGxpbWIzKS50b0JpZ0ludCgpO1xuICB9XG4gIGlmIChpc1R5cGVCeXRlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZEJ5dGVzMzFBcnIgPSBbXTtcbiAgICBjb25zdCBieXRlczMxQXJyTGVuID0gQmlnSW50KHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICB3aGlsZSAocGFyc2VkQnl0ZXMzMUFyci5sZW5ndGggPCBieXRlczMxQXJyTGVuKSB7XG4gICAgICBwYXJzZWRCeXRlczMxQXJyLnB1c2godG9IZXgocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZ193b3JkID0gdG9IZXgocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIGNvbnN0IHBlbmRpbmdfd29yZF9sZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIGNvbnN0IG15Qnl0ZUFycmF5ID0ge1xuICAgICAgZGF0YTogcGFyc2VkQnl0ZXMzMUFycixcbiAgICAgIHBlbmRpbmdfd29yZCxcbiAgICAgIHBlbmRpbmdfd29yZF9sZW5cbiAgICB9O1xuICAgIHJldHVybiBzdHJpbmdGcm9tQnl0ZUFycmF5KG15Qnl0ZUFycmF5KTtcbiAgfVxuICBpZiAoaXNUeXBlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICBjb25zdCBlbCA9IHsgbmFtZTogXCJcIiwgdHlwZTogZ2V0QXJyYXlUeXBlKGVsZW1lbnQudHlwZSkgfTtcbiAgICBjb25zdCBsZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGxlbikge1xuICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gIH1cbiAgaWYgKHN0cnVjdHMgJiYgZWxlbWVudC50eXBlIGluIHN0cnVjdHMgJiYgc3RydWN0c1tlbGVtZW50LnR5cGVdKSB7XG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIikge1xuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzMihlbGVtZW50LnR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0c1tlbGVtZW50LnR5cGVdLm1lbWJlcnMucmVkdWNlKChhY2MsIGVsKSA9PiB7XG4gICAgICBhY2NbZWwubmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG4gIGlmIChlbnVtcyAmJiBlbGVtZW50LnR5cGUgaW4gZW51bXMgJiYgZW51bXNbZWxlbWVudC50eXBlXSkge1xuICAgIGNvbnN0IHZhcmlhbnROdW0gPSBOdW1iZXIocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIGNvbnN0IHJhd0VudW0gPSBlbnVtc1tlbGVtZW50LnR5cGVdLnZhcmlhbnRzLnJlZHVjZSgoYWNjLCB2YXJpYW50LCBudW0pID0+IHtcbiAgICAgIGlmIChudW0gPT09IHZhcmlhbnROdW0pIHtcbiAgICAgICAgYWNjW3ZhcmlhbnQubmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUoXG4gICAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgICB7IG5hbWU6IFwiXCIsIHR5cGU6IHZhcmlhbnQudHlwZSB9LFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGFjY1t2YXJpYW50Lm5hbWVdID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb25cIikpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB2YXJpYW50TnVtID09PSAwIC8qIFNvbWUgKi8gPyByYXdFbnVtLlNvbWUgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKHZhcmlhbnROdW0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC50eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdFwiKSkge1xuICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICBpZiAodmFyaWFudE51bSA9PT0gMCAvKiBPayAqLykge1xuICAgICAgICBjb250ZW50ID0gcmF3RW51bS5PaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgPSByYXdFbnVtLkVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9SZXN1bHQodmFyaWFudE51bSwgY29udGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGN1c3RvbUVudW0gPSBuZXcgQ2Fpcm9DdXN0b21FbnVtKHJhd0VudW0pO1xuICAgIHJldHVybiBjdXN0b21FbnVtO1xuICB9XG4gIGlmIChpc1R5cGVUdXBsZShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgbWVtYmVyVHlwZXMgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyhlbGVtZW50LnR5cGUpO1xuICAgIHJldHVybiBtZW1iZXJUeXBlcy5yZWR1Y2UoKGFjYywgaXQsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGl0Py5uYW1lID8gaXQubmFtZSA6IGlkeDtcbiAgICAgIGNvbnN0IHR5cGUgPSBpdD8udHlwZSA/IGl0LnR5cGUgOiBpdDtcbiAgICAgIGNvbnN0IGVsID0geyBuYW1lLCB0eXBlIH07XG4gICAgICBhY2NbbmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG4gIGlmIChpc1R5cGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgIGNvbnN0IGVsID0geyBuYW1lOiBcIlwiLCB0eXBlOiBnZXRBcnJheVR5cGUoZWxlbWVudC50eXBlKSB9O1xuICAgIGNvbnN0IGxlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICBwYXJzZWREYXRhQXJyLnB1c2gocGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgfVxuICByZXR1cm4gcGFyc2VCYXNlVHlwZXMyKGVsZW1lbnQudHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG59XG5mdW5jdGlvbiByZXNwb25zZVBhcnNlcihyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zLCBwYXJzZWRSZXN1bHQpIHtcbiAgY29uc3QgeyBuYW1lLCB0eXBlIH0gPSBvdXRwdXQ7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzTGVuKG5hbWUpOlxuICAgICAgdGVtcCA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJpZ0ludCh0ZW1wKTtcbiAgICBjYXNlIChzdHJ1Y3RzICYmIHR5cGUgaW4gc3RydWN0cyB8fCBpc1R5cGVUdXBsZSh0eXBlKSk6XG4gICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgKGVudW1zICYmIGlzVHlwZUVudW0odHlwZSwgZW51bXMpKTpcbiAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgY2FzZSBpc1R5cGVBcnJheSh0eXBlKTpcbiAgICAgIGlmIChpc0NhaXJvMVR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICAgIGlmIChwYXJzZWRSZXN1bHQgJiYgcGFyc2VkUmVzdWx0W2Ake25hbWV9X2xlbmBdKSB7XG4gICAgICAgIGNvbnN0IGFyckxlbiA9IHBhcnNlZFJlc3VsdFtgJHtuYW1lfV9sZW5gXTtcbiAgICAgICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgYXJyTGVuKSB7XG4gICAgICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKFxuICAgICAgICAgICAgcGFyc2VSZXNwb25zZVZhbHVlKFxuICAgICAgICAgICAgICByZXNwb25zZUl0ZXJhdG9yLFxuICAgICAgICAgICAgICB7IG5hbWUsIHR5cGU6IG91dHB1dC50eXBlLnJlcGxhY2UoXCIqXCIsIFwiXCIpIH0sXG4gICAgICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgICAgIGVudW1zXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIodHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3ZhbGlkYXRlLnRzXG52YXIgdmFsaWRhdGVGZWx0ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIGlzU3RyaW5nKHBhcmFtZXRlcikgfHwgaXNOdW1iZXIocGFyYW1ldGVyKSB8fCBpc0JpZ0ludChwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgZmVsdCB0eXBlZCBhcyAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KWBcbiAgKTtcbiAgaWYgKGlzU3RyaW5nKHBhcmFtZXRlcikgJiYgIWlzSGV4KHBhcmFtZXRlcikpXG4gICAgcmV0dXJuO1xuICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgYXNzZXJ0KFxuICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjY2XG4gICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZUJ5dGVzMzEgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoaXNTdHJpbmcocGFyYW1ldGVyKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYSBzdHJpbmcuYCk7XG4gIGFzc2VydChcbiAgICBwYXJhbWV0ZXIubGVuZ3RoIDwgMzIsXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBhIHN0cmluZyBvZiBsZXNzIHRoYW4gMzIgY2hhcmFjdGVycy5gXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQnl0ZUFycmF5ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KGlzU3RyaW5nKHBhcmFtZXRlciksIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgc3RyaW5nLmApO1xufTtcbnZhciB2YWxpZGF0ZVVpbnQgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBpZiAoaXNOdW1iZXIocGFyYW1ldGVyKSkge1xuICAgIGFzc2VydChcbiAgICAgIHBhcmFtZXRlciA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgIGBWYWxpZGF0aW9uOiBQYXJhbWV0ZXIgaXMgdG8gbGFyZ2UgdG8gYmUgdHlwZWQgYXMgTnVtYmVyIHVzZSAoQmlnSW50IG9yIFN0cmluZylgXG4gICAgKTtcbiAgfVxuICBhc3NlcnQoXG4gICAgaXNTdHJpbmcocGFyYW1ldGVyKSB8fCBpc051bWJlcihwYXJhbWV0ZXIpIHx8IGlzQmlnSW50KHBhcmFtZXRlcikgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiBcImxvd1wiIGluIHBhcmFtZXRlciAmJiBcImhpZ2hcIiBpbiBwYXJhbWV0ZXIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiBbXCJsaW1iMFwiLCBcImxpbWIxXCIsIFwibGltYjJcIiwgXCJsaW1iM1wiXS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gcGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IG9mIGNhaXJvIHR5cGUgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgdHlwZSAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KSwgYnV0IGlzICR7dHlwZW9mIHBhcmFtZXRlcn0gJHtwYXJhbWV0ZXJ9LmBcbiAgKTtcbiAgbGV0IHBhcmFtO1xuICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiIC8qIHUyNTYgKi86XG4gICAgICBwYXJhbSA9IG5ldyBDYWlyb1VpbnQyNTYocGFyYW1ldGVyKS50b0JpZ0ludCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU1MTJcIiAvKiB1NTEyICovOlxuICAgICAgcGFyYW0gPSBuZXcgQ2Fpcm9VaW50NTEyKHBhcmFtZXRlcikudG9CaWdJbnQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwYXJhbSA9IHRvQmlnSW50KHBhcmFtZXRlcik7XG4gIH1cbiAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU4XCIgLyogdTggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDI1NW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAgLSAyNTVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MTZcIiAvKiB1MTYgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDY1NTM1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgNjU1MzVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MzJcIiAvKiB1MzIgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDQyOTQ5NjcyOTVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCA0Mjk0OTY3Mjk1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTY0XCIgLyogdTY0ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiA2NG4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl42NC0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiIC8qIHUxMjggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDEyOG4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xMjgtMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUyNTZcIiAvKiB1MjU2ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTZuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgJHtpbnB1dC50eXBlfSAwIC0gMl4yNTYtMWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTUxMlwiIC8qIHU1MTIgKi86XG4gICAgICBhc3NlcnQoQ2Fpcm9VaW50NTEyLmlzKHBhcmFtKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyAke2lucHV0LnR5cGV9IDAgLSAyXjUxMi0xYCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OmNsYXNzX2hhc2g6OkNsYXNzSGFzaFwiIC8qIENsYXNzSGFzaCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDE2NzBcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiIC8qIENvbnRyYWN0QWRkcmVzcyAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDEyNDVcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OnNlY3AyNTZrMTo6U2VjcDI1NmsxUG9pbnRcIiAvKiBTZWNwMjU2azFQb2ludCAqLzoge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiA1MTJuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gbXVzdCBiZSAke2lucHV0LnR5cGV9IDogYSA1MTIgYml0cyBudW1iZXIuYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVCb29sID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIGlzQm9vbGVhbihwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gb2YgY2Fpcm8gdHlwZSAke2lucHV0LnR5cGV9IHNob3VsZCBiZSB0eXBlIChCb29sZWFuKWBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVTdHJ1Y3QgPSAocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cykgPT4ge1xuICBpZiAoaW5wdXQudHlwZSA9PT0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCIgLyogdTI1NiAqLyB8fCBpbnB1dC50eXBlID09PSBcImNvcmU6OmludGVnZXI6OnU1MTJcIiAvKiB1NTEyICovKSB7XG4gICAgdmFsaWRhdGVVaW50KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5wdXQudHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIikge1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiBwYXJhbWV0ZXIgIT09IFwib2JqZWN0XCIsXG4gICAgICBgRXRoQWRkcmVzcyB0eXBlIGlzIHdhaXRpbmcgYSBCaWdOdW1iZXJpc2guIEdvdCAke3BhcmFtZXRlcn1gXG4gICAgKTtcbiAgICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgICBhc3NlcnQoXG4gICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI1OVxuICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMTYwbiAtIDFuLFxuICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xNjAtMV1gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzIGNhaXJvIHR5cGUgc3RydWN0ICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgc3RydWN0c1tpbnB1dC50eXBlXS5tZW1iZXJzLmZvckVhY2goKHsgbmFtZSB9KSA9PiB7XG4gICAgYXNzZXJ0KFxuICAgICAgT2JqZWN0LmtleXMocGFyYW1ldGVyKS5pbmNsdWRlcyhuYW1lKSxcbiAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGhhdmUgYSBwcm9wZXJ0eSAke25hbWV9YFxuICAgICk7XG4gIH0pO1xufTtcbnZhciB2YWxpZGF0ZUVudW0gPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgY2Fpcm8gdHlwZSBFbnVtICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgY29uc3QgbWV0aG9kc0tleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyYW1ldGVyKSk7XG4gIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyYW1ldGVyKSwgLi4ubWV0aG9kc0tleXNdO1xuICBpZiAoaXNUeXBlT3B0aW9uKGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNUeXBlUmVzdWx0KGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc09rXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc0VyclwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5cy5pbmNsdWRlcyhcInZhcmlhbnRcIikgJiYga2V5cy5pbmNsdWRlcyhcImFjdGl2ZVZhcmlhbnRcIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBWYWxpZGF0ZSBFbnVtOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlIHJlY2VpdmVkICR7cGFyYW1ldGVyfSwgaXMgbm90IGFuIEVudW0uYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVR1cGxlID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIHR1cGxlIChkZWZpbmVkIGFzIG9iamVjdClgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQXJyYXkgPSAocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cywgZW51bXMpID0+IHtcbiAgY29uc3QgYmFzZVR5cGUgPSBnZXRBcnJheVR5cGUoaW5wdXQudHlwZSk7XG4gIGlmIChpc1R5cGVGZWx0KGJhc2VUeXBlKSAmJiBpc0xvbmdUZXh0KHBhcmFtZXRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYW4gQXJyYXlgKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVGZWx0KGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVGZWx0KHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVUdXBsZShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlVHVwbGUoaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVBcnJheShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaChcbiAgICAgICAgKHBhcmFtKSA9PiB2YWxpZGF0ZUFycmF5KHBhcmFtLCB7IG5hbWU6IFwiXCIsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMsIGVudW1zKVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlU3RydWN0KGJhc2VUeXBlLCBzdHJ1Y3RzKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKFxuICAgICAgICAoaXQpID0+IHZhbGlkYXRlU3RydWN0KGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVFbnVtKGJhc2VUeXBlLCBlbnVtcyk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlRW51bShpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIChpc1R5cGVVaW50KGJhc2VUeXBlKSB8fCBpc1R5cGVMaXRlcmFsKGJhc2VUeXBlKSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgocGFyYW0pID0+IHZhbGlkYXRlVWludChwYXJhbSwgeyBuYW1lOiBcIlwiLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUJvb2woYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZUJvb2wocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKChhY2MsIGlucHV0KSA9PiB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gYXJnc1thY2NdO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBpc0xlbihpbnB1dC5uYW1lKTpcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIGNhc2UgaXNUeXBlRmVsdChpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVGZWx0KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlQnl0ZXMzMShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVCeXRlczMxKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgKGlzVHlwZVVpbnQoaW5wdXQudHlwZSkgfHwgaXNUeXBlTGl0ZXJhbChpbnB1dC50eXBlKSk6XG4gICAgICAgIHZhbGlkYXRlVWludChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUJvb2woaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQm9vbChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUJ5dGVBcnJheShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVCeXRlQXJyYXkocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVBcnJheShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVBcnJheShwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVTdHJ1Y3QoaW5wdXQudHlwZSwgc3RydWN0cyk6XG4gICAgICAgIHZhbGlkYXRlU3RydWN0KHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlRW51bShpbnB1dC50eXBlLCBlbnVtcyk6XG4gICAgICAgIHZhbGlkYXRlRW51bShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZVR1cGxlKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZVR1cGxlKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYyArIDE7XG4gIH0sIDApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvaW5kZXgudHNcbnZhciBDYWxsRGF0YSA9IGNsYXNzIF9DYWxsRGF0YSB7XG4gIGFiaTtcbiAgcGFyc2VyO1xuICBzdHJ1Y3RzO1xuICBlbnVtcztcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5zdHJ1Y3RzID0gX0NhbGxEYXRhLmdldEFiaVN0cnVjdChhYmkpO1xuICAgIHRoaXMuZW51bXMgPSBfQ2FsbERhdGEuZ2V0QWJpRW51bShhYmkpO1xuICAgIHRoaXMucGFyc2VyID0gY3JlYXRlQWJpUGFyc2VyKGFiaSk7XG4gICAgdGhpcy5hYmkgPSB0aGlzLnBhcnNlci5nZXRMZWdhY3lGb3JtYXQoKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kIGFzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9uZXMgaW4gdGhlIGFiaVxuICAgKiBAcGFyYW0gdHlwZSBWYWxpZGF0ZVR5cGUgLSB0eXBlIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBuYW1lIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIGFyZ3MgQXJnc09yQ2FsbGRhdGEgLSBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICovXG4gIHZhbGlkYXRlKHR5cGUsIG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgaWYgKHR5cGUgIT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovKSB7XG4gICAgICBjb25zdCBpbnZvY2FibGVGdW5jdGlvbk5hbWVzID0gdGhpcy5hYmkuZmlsdGVyKChhYmkpID0+IHtcbiAgICAgICAgaWYgKGFiaS50eXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpc1ZpZXcgPSBhYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBhYmkuc3RhdGVfbXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCI7XG4gICAgICAgIHJldHVybiB0eXBlID09PSBcIklOVk9LRVwiIC8qIElOVk9LRSAqLyA/ICFpc1ZpZXcgOiBpc1ZpZXc7XG4gICAgICB9KS5tYXAoKGFiaSkgPT4gYWJpLm5hbWUpO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBpbnZvY2FibGVGdW5jdGlvbk5hbWVzLmluY2x1ZGVzKG1ldGhvZCksXG4gICAgICAgIGAke3R5cGUgPT09IFwiSU5WT0tFXCIgLyogSU5WT0tFICovID8gXCJpbnZvY2FibGVcIiA6IFwidmlld2FibGVcIn0gbWV0aG9kIG5vdCBmb3VuZCBpbiBhYmlgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBhYmlNZXRob2QgPSB0aGlzLmFiaS5maW5kKFxuICAgICAgKGFiaSkgPT4gdHlwZSA9PT0gXCJERVBMT1lcIiAvKiBERVBMT1kgKi8gPyBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImNvbnN0cnVjdG9yXCIgOiBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImZ1bmN0aW9uXCJcbiAgICApO1xuICAgIGlmIChpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3MsIGFiaU1ldGhvZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRzTGVuZ3RoID0gdGhpcy5wYXJzZXIubWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBpbnB1dHNMZW5ndGgpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzLCBleHBlY3RlZCAke2lucHV0c0xlbmd0aH0gYXJndW1lbnRzLCBidXQgZ290ICR7YXJncy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpO1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlIGNvbnRyYWN0IGNhbGxEYXRhIHdpdGggYWJpXG4gICAqIFBhcnNlIHRoZSBjYWxsZGF0YSBieSB1c2luZyBpbnB1dCBmaWVsZHMgZnJvbSB0aGUgYWJpIGZvciB0aGF0IG1ldGhvZFxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzIFJhd0FyZ3MgLSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBtZXRob2QuIENhbiBiZSBhbiBhcnJheSBvZiBhcmd1bWVudHMgKGluIHRoZSBvcmRlciBvZiBhYmkgZGVmaW5pdGlvbiksIG9yIGFuIG9iamVjdCBjb25zdHJ1Y3RlZCBpbiBjb25mb3JtaXR5IHdpdGggYWJpIChpbiB0aGlzIGNhc2UsIHRoZSBwYXJhbWV0ZXIgY2FuIGJlIGluIGEgd3Jvbmcgb3JkZXIpLlxuICAgKiBAcmV0dXJuIENhbGxkYXRhIC0gcGFyc2VkIGFyZ3VtZW50cyBpbiBmb3JtYXQgdGhhdCBjb250cmFjdCBpcyBleHBlY3RpbmdcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBjYWxsZGF0YSA9IG15Q2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIFtcIjB4MzRhXCIsIFsxLCAzbl1dKTtcbiAgICogYGBgXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY2FsbGRhdGEyID0gbXlDYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwge2xpc3Q6WzEsIDNuXSwgYmFsYW5jZTpcIjB4MzRcIn0pOyAvLyB3cm9uZyBvcmRlciBpcyB2YWxpZFxuICAgKiBgYGBcbiAgICovXG4gIGNvbXBpbGUobWV0aG9kLCBhcmdzQ2FsbGRhdGEpIHtcbiAgICBjb25zdCBhYmlNZXRob2QgPSB0aGlzLmFiaS5maW5kKChhYmlGdW5jdGlvbikgPT4gYWJpRnVuY3Rpb24ubmFtZSA9PT0gbWV0aG9kKTtcbiAgICBpZiAoaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzQ2FsbGRhdGEsIGFiaU1ldGhvZCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGFyZ3M7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc0NhbGxkYXRhKSkge1xuICAgICAgYXJncyA9IGFyZ3NDYWxsZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JkZXJlZE9iamVjdCA9IG9yZGVyUHJvcHNCeUFiaShcbiAgICAgICAgYXJnc0NhbGxkYXRhLFxuICAgICAgICBhYmlNZXRob2QuaW5wdXRzLFxuICAgICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICAgIHRoaXMuZW51bXNcbiAgICAgICk7XG4gICAgICBhcmdzID0gT2JqZWN0LnZhbHVlcyhvcmRlcmVkT2JqZWN0KTtcbiAgICAgIHZhbGlkYXRlRmllbGRzKGFiaU1ldGhvZCwgYXJncywgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zKTtcbiAgICB9XG4gICAgY29uc3QgYXJnc0l0ZXJhdG9yID0gYXJnc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgY2FsbEFycmF5ID0gYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoXG4gICAgICAoYWNjLCBpbnB1dCkgPT4gaXNMZW4oaW5wdXQubmFtZSkgJiYgIWlzQ2Fpcm8xVHlwZShpbnB1dC50eXBlKSA/IGFjYyA6IGFjYy5jb25jYXQocGFyc2VDYWxsZGF0YUZpZWxkKGFyZ3NJdGVyYXRvciwgaW5wdXQsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcykpLFxuICAgICAgW11cbiAgICApO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWxsQXJyYXksIFwiX19jb21waWxlZF9fXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbEFycmF5O1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlIGNvbnRyYWN0IGNhbGxEYXRhIHdpdGhvdXQgYWJpXG4gICAqIEBwYXJhbSByYXdBcmdzIFJhd0FyZ3MgcmVwcmVzZW50aW5nIGNhaXJvIG1ldGhvZCBhcmd1bWVudHMgb3Igc3RyaW5nIGFycmF5IG9mIGNvbXBpbGVkIGRhdGFcbiAgICogQHJldHVybnMgQ2FsbGRhdGFcbiAgICovXG4gIHN0YXRpYyBjb21waWxlKHJhd0FyZ3MpIHtcbiAgICBjb25zdCBjcmVhdGVUcmVlID0gKG9iaikgPT4ge1xuICAgICAgY29uc3QgZ2V0RW50cmllcyA9IChvLCBwcmVmaXggPSBcIi5cIikgPT4ge1xuICAgICAgICBjb25zdCBvZSA9IEFycmF5LmlzQXJyYXkobykgPyBbby5sZW5ndGgudG9TdHJpbmcoKSwgLi4ub10gOiBvO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2UpLmZsYXRNYXAoKFtrLCB2XSkgPT4ge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHY7XG4gICAgICAgICAgaWYgKGsgPT09IFwiZW50cnlwb2ludFwiKVxuICAgICAgICAgICAgdmFsdWUgPSBnZXRTZWxlY3RvckZyb21OYW1lKHZhbHVlKTtcbiAgICAgICAgICBlbHNlIGlmIChpc0xvbmdUZXh0KHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gYnl0ZUFycmF5RnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgY29uc3Qga2sgPSBBcnJheS5pc0FycmF5KG9lKSAmJiBrID09PSBcIjBcIiA/IFwiJCRsZW5cIiA6IGs7XG4gICAgICAgICAgaWYgKGlzQmlnSW50KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFsdWUpXV07XG4gICAgICAgICAgaWYgKE9iamVjdCh2YWx1ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2RzS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSksIC4uLm1ldGhvZHNLZXlzXTtcbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwiaXNTb21lXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc05vbmVcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlPcHRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE5iID0gbXlPcHRpb24uaXNTb21lKCkgPyAwIC8qIFNvbWUgKi8gOiAxIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgIGlmIChteU9wdGlvbi5pc1NvbWUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IHZhcmlhbnROYiwgMTogbXlPcHRpb24udW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhcmlhbnROYildXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwiaXNPa1wiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNFcnJcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlSZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE5iID0gbXlSZXN1bHQuaXNPaygpID8gMCAvKiBPayAqLyA6IDEgLyogRXJyICovO1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IHZhcmlhbnROYiwgMTogbXlSZXN1bHQudW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJ2YXJpYW50XCIpICYmIGtleXMuaW5jbHVkZXMoXCJhY3RpdmVWYXJpYW50XCIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG15RW51bSA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVWYXJpYW50ID0gbXlFbnVtLmFjdGl2ZVZhcmlhbnQoKTtcbiAgICAgICAgICAgICAgY29uc3QgbGlzdFZhcmlhbnRzID0gT2JqZWN0LmtleXMobXlFbnVtLnZhcmlhbnQpO1xuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVWYXJpYW50TmIgPSBsaXN0VmFyaWFudHMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICh2YXJpYW50KSA9PiB2YXJpYW50ID09PSBhY3RpdmVWYXJpYW50XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbXlFbnVtLnVud3JhcCgpID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKG15RW51bS51bndyYXAoKSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdChhY3RpdmVWYXJpYW50TmIpXV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXMoeyAwOiBhY3RpdmVWYXJpYW50TmIsIDE6IG15RW51bS51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh2YWx1ZSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhbHVlKV1dO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2V0RW50cmllcyhvYmopKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBsZXQgY2FsbFRyZWVBcnJheTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3QXJncykpIHtcbiAgICAgIGNvbnN0IGNhbGxUcmVlID0gY3JlYXRlVHJlZShyYXdBcmdzKTtcbiAgICAgIGNhbGxUcmVlQXJyYXkgPSBPYmplY3QudmFsdWVzKGNhbGxUcmVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2FsbE9iaiA9IHsgLi4ucmF3QXJncyB9O1xuICAgICAgY29uc3QgY2FsbFRyZWUgPSBjcmVhdGVUcmVlKGNhbGxPYmopO1xuICAgICAgY2FsbFRyZWVBcnJheSA9IE9iamVjdC52YWx1ZXMoY2FsbFRyZWUpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FsbFRyZWVBcnJheSwgXCJfX2NvbXBpbGVkX19cIiwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBjYWxsVHJlZUFycmF5O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBlbGVtZW50cyBvZiB0aGUgcmVzcG9uc2UgYXJyYXkgYW5kIHN0cnVjdHVyaW5nIHRoZW0gaW50byByZXNwb25zZSBvYmplY3RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSByZXNwb25zZSBmcm9tIHRoZSBtZXRob2RcbiAgICogQHJldHVybiBSZXN1bHQgLSBwYXJzZWQgcmVzcG9uc2UgY29ycmVzcG9uZGluZyB0byB0aGUgYWJpXG4gICAqL1xuICBwYXJzZShtZXRob2QsIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgeyBvdXRwdXRzIH0gPSB0aGlzLmFiaS5maW5kKChhYmkpID0+IGFiaS5uYW1lID09PSBtZXRob2QpO1xuICAgIGNvbnN0IHJlc3BvbnNlSXRlcmF0b3IgPSByZXNwb25zZS5mbGF0KClbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IHBhcnNlZCA9IG91dHB1dHMuZmxhdCgpLnJlZHVjZSgoYWNjLCBvdXRwdXQsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgcHJvcE5hbWUgPSBvdXRwdXQubmFtZSA/PyBpZHg7XG4gICAgICBhY2NbcHJvcE5hbWVdID0gcmVzcG9uc2VQYXJzZXIocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMsIGFjYyk7XG4gICAgICBpZiAoYWNjW3Byb3BOYW1lXSAmJiBhY2NbYCR7cHJvcE5hbWV9X2xlbmBdKSB7XG4gICAgICAgIGRlbGV0ZSBhY2NbYCR7cHJvcE5hbWV9X2xlbmBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoID09PSAxICYmIDAgaW4gcGFyc2VkID8gcGFyc2VkWzBdIDogcGFyc2VkO1xuICB9XG4gIC8qKlxuICAgKiBGb3JtYXQgY2Fpcm8gbWV0aG9kIHJlc3BvbnNlIGRhdGEgdG8gbmF0aXZlIGpzIHZhbHVlcyBiYXNlZCBvbiBwcm92aWRlZCBmb3JtYXQgc2NoZW1hXG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gY2Fpcm8gbWV0aG9kIG5hbWVcbiAgICogQHBhcmFtIHJlc3BvbnNlIHN0cmluZ1tdIC0gY2Fpcm8gbWV0aG9kIHJlc3BvbnNlXG4gICAqIEBwYXJhbSBmb3JtYXQgb2JqZWN0IC0gZm9ybWF0dGVyIG9iamVjdCBzY2hlbWFcbiAgICogQHJldHVybnMgUmVzdWx0IC0gcGFyc2VkIGFuZCBmb3JtYXR0ZWQgcmVzcG9uc2Ugb2JqZWN0XG4gICAqL1xuICBmb3JtYXQobWV0aG9kLCByZXNwb25zZSwgZm9ybWF0KSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZShtZXRob2QsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyKHBhcnNlZCwgZm9ybWF0KTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIHRvIGV4dHJhY3Qgc3RydWN0cyBmcm9tIGFiaVxuICAgKiBAcGFyYW0gYWJpIEFiaVxuICAgKiBAcmV0dXJucyBBYmlTdHJ1Y3RzIC0gc3RydWN0cyBmcm9tIGFiaVxuICAgKi9cbiAgc3RhdGljIGdldEFiaVN0cnVjdChhYmkpIHtcbiAgICByZXR1cm4gYWJpLmZpbHRlcigoYWJpRW50cnkpID0+IGFiaUVudHJ5LnR5cGUgPT09IFwic3RydWN0XCIpLnJlZHVjZShcbiAgICAgIChhY2MsIGFiaUVudHJ5KSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFthYmlFbnRyeS5uYW1lXTogYWJpRW50cnlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBlbnVtcyBmcm9tIGFiaVxuICAgKiBAcGFyYW0gYWJpIEFiaVxuICAgKiBAcmV0dXJucyBBYmlFbnVtcyAtIGVudW1zIGZyb20gYWJpXG4gICAqL1xuICBzdGF0aWMgZ2V0QWJpRW51bShhYmkpIHtcbiAgICBjb25zdCBmdWxsRW51bUxpc3QgPSBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJlbnVtXCIpLnJlZHVjZShcbiAgICAgIChhY2MsIGFiaUVudHJ5KSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFthYmlFbnRyeS5uYW1lXTogYWJpRW50cnlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICAgIGRlbGV0ZSBmdWxsRW51bUxpc3RbXCJjb3JlOjpib29sXCJdO1xuICAgIHJldHVybiBmdWxsRW51bUxpc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlcjogQ29tcGlsZSBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcGFyYW0gcmF3Q2FsbGRhdGEgSGV4Q2FsbGRhdGEgfCBSYXdDYWxsZGF0YSB8IFJhd0FyZ3NcbiAgICogQHJldHVybnMgQ2FsbGRhdGFcbiAgICovXG4gIHN0YXRpYyB0b0NhbGxkYXRhKHJhd0NhbGxkYXRhID0gW10pIHtcbiAgICByZXR1cm4gX0NhbGxEYXRhLmNvbXBpbGUocmF3Q2FsbGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXI6IENvbnZlcnQgcmF3IHRvIEhleENhbGxkYXRhXG4gICAqIEBwYXJhbSByYXcgSGV4Q2FsbGRhdGEgfCBSYXdDYWxsZGF0YSB8IFJhd0FyZ3NcbiAgICogQHJldHVybnMgSGV4Q2FsbGRhdGFcbiAgICovXG4gIHN0YXRpYyB0b0hleChyYXcgPSBbXSkge1xuICAgIGNvbnN0IGNhbGxkYXRhID0gX0NhbGxEYXRhLmNvbXBpbGUocmF3KTtcbiAgICByZXR1cm4gY2FsbGRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgY29udHJhY3QgcmVzcG9uc2UgYW5kIHN0cnVjdHVyZSB0aGVtIGludG8gb25lIG9yIHNldmVyYWwgUmVzdWx0LlxuICAgKiBJbiBDYWlybyAwLCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqIEBwYXJhbSB0eXBlQ2Fpcm8gc3RyaW5nIG9yIHN0cmluZ1tdIC0gQ2Fpcm8gdHlwZSBuYW1lLCBleCA6IFwiaGVsbG86OmhlbGxvOjpVc2VyRGF0YVwiXG4gICAqIEBwYXJhbSByZXNwb25zZSBzdHJpbmdbXSAtIHNlcmlhbGl6ZWQgZGF0YSBjb3JyZXNwb25kaW5nIHRvIHR5cGVDYWlyby5cbiAgICogQHJldHVybiBSZXN1bHQgb3IgUmVzdWx0W10gLSBwYXJzZWQgcmVzcG9uc2UgY29ycmVzcG9uZGluZyB0byB0eXBlRGF0YS5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVzMj1oZWxsb0NhbGxEYXRhLmRlY29kZVBhcmFtZXRlcnMoXCJoZWxsbzo6aGVsbG86OlVzZXJEYXRhXCIsW1wiMHgxMjM0NTZcIixcIjB4MVwiXSk7XG4gICAqIHJlc3VsdCA9IHsgYWRkcmVzczogMTE5MzA0Nm4sIGlzX2NsYWltZWQ6IHRydWUgfVxuICAgKi9cbiAgZGVjb2RlUGFyYW1ldGVycyh0eXBlQ2Fpcm8sIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgdHlwZUNhaXJvQXJyYXkgPSBBcnJheS5pc0FycmF5KHR5cGVDYWlybykgPyB0eXBlQ2Fpcm8gOiBbdHlwZUNhaXJvXTtcbiAgICBjb25zdCByZXNwb25zZUl0ZXJhdG9yID0gcmVzcG9uc2UuZmxhdCgpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBkZWNvZGVkQXJyYXkgPSB0eXBlQ2Fpcm9BcnJheS5tYXAoXG4gICAgICAodHlwZVBhcmFtKSA9PiByZXNwb25zZVBhcnNlcihcbiAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgeyBuYW1lOiBcIlwiLCB0eXBlOiB0eXBlUGFyYW0gfSxcbiAgICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgICB0aGlzLmVudW1zXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZEFycmF5Lmxlbmd0aCA9PT0gMSA/IGRlY29kZWRBcnJheVswXSA6IGRlY29kZWRBcnJheTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2hhc2gvaW5kZXgudHNcbnZhciBoYXNoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGhhc2hfZXhwb3J0cywge1xuICBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaDogKCkgPT4gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2gsXG4gIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzLFxuICBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyxcbiAgY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyLFxuICBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVDb21waWxlZENsYXNzSGFzaCxcbiAgY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2gsXG4gIGNvbXB1dGVIYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMixcbiAgY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2gsXG4gIGNvbXB1dGVQZWRlcnNlbkhhc2g6ICgpID0+IGNvbXB1dGVQZWRlcnNlbkhhc2gsXG4gIGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlUGVkZXJzZW5IYXNoT25FbGVtZW50cyxcbiAgY29tcHV0ZVBvc2VpZG9uSGFzaDogKCkgPT4gY29tcHV0ZVBvc2VpZG9uSGFzaCxcbiAgY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHM6ICgpID0+IGNvbXB1dGVQb3NlaWRvbkhhc2hPbkVsZW1lbnRzLFxuICBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaCxcbiAgZm9ybWF0U3BhY2VzOiAoKSA9PiBmb3JtYXRTcGFjZXMsXG4gIGdldFNlbGVjdG9yOiAoKSA9PiBnZXRTZWxlY3RvcixcbiAgZ2V0U2VsZWN0b3JGcm9tTmFtZTogKCkgPT4gZ2V0U2VsZWN0b3JGcm9tTmFtZSxcbiAgaGFzaEJ5dGVDb2RlU2VnbWVudHM6ICgpID0+IGhhc2hCeXRlQ29kZVNlZ21lbnRzLFxuICBrZWNjYWtCbjogKCkgPT4ga2VjY2FrQm4sXG4gIHBvc2VpZG9uOiAoKSA9PiBwb3NlaWRvbixcbiAgc3RhcmtuZXRLZWNjYWs6ICgpID0+IHN0YXJrbmV0S2VjY2FrXG59KTtcbmltcG9ydCAqIGFzIHBvc2VpZG9uIGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uXCI7XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC92Mi50c1xudmFyIHYyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHYyX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2gsXG4gIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjogKCkgPT4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uLFxuICBjb21wdXRlSGFzaE9uRWxlbWVudHM6ICgpID0+IGNvbXB1dGVIYXNoT25FbGVtZW50c1xufSk7XG5cbi8vIHNyYy91dGlscy9lYy50c1xudmFyIGVjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVjX2V4cG9ydHMsIHtcbiAgc3RhcmtDdXJ2ZTogKCkgPT4gc3RhcmtDdXJ2ZSxcbiAgd2VpZXJzdHJhc3M6ICgpID0+IHdlaWVyc3RyYXNzXG59KTtcbmltcG9ydCAqIGFzIHN0YXJrQ3VydmUgZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuaW1wb3J0ICogYXMgd2VpZXJzdHJhc3MgZnJvbSBcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3NcIjtcblxuLy8gc3JjL3V0aWxzL2hhc2gvdHJhbnNhY3Rpb25IYXNoL3YyLnRzXG5mdW5jdGlvbiBjb21wdXRlSGFzaE9uRWxlbWVudHMoZGF0YSkge1xuICByZXR1cm4gWy4uLmRhdGEsIGRhdGEubGVuZ3RoXS5yZWR1Y2UoKHgsIHkpID0+IHN0YXJrQ3VydmUucGVkZXJzZW4odG9CaWdJbnQoeCksIHRvQmlnSW50KHkpKSwgMCkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbih0eEhhc2hQcmVmaXgsIHZlcnNpb24sIGNvbnRyYWN0QWRkcmVzcywgZW50cnlQb2ludFNlbGVjdG9yLCBjYWxsZGF0YSwgbWF4RmVlLCBjaGFpbklkLCBhZGRpdGlvbmFsRGF0YSA9IFtdKSB7XG4gIGNvbnN0IGNhbGxkYXRhSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhjYWxsZGF0YSk7XG4gIGNvbnN0IGRhdGFUb0hhc2ggPSBbXG4gICAgdHhIYXNoUHJlZml4LFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGVudHJ5UG9pbnRTZWxlY3RvcixcbiAgICBjYWxsZGF0YUhhc2gsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgLi4uYWRkaXRpb25hbERhdGFcbiAgXTtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50cyhkYXRhVG9IYXNoKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2goY2xhc3NIYXNoLCBzZW5kZXJBZGRyZXNzLCB2ZXJzaW9uLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlLCBjb21waWxlZENsYXNzSGFzaCkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKFxuICAgIFwiMHg2NDY1NjM2YzYxNzI2NVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIDAsXG4gICAgW2NsYXNzSGFzaF0sXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlLCAuLi5jb21waWxlZENsYXNzSGFzaCA/IFtjb21waWxlZENsYXNzSGFzaF0gOiBbXV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2goY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNhbHQsIHZlcnNpb24sIG1heEZlZSwgY2hhaW5JZCwgbm9uY2UpIHtcbiAgY29uc3QgY2FsbGRhdGEgPSBbY2xhc3NIYXNoLCBzYWx0LCAuLi5jb25zdHJ1Y3RvckNhbGxkYXRhXTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4NjQ2NTcwNmM2Zjc5NWY2MTYzNjM2Zjc1NmU3NFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIDAsXG4gICAgY2FsbGRhdGEsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgdmVyc2lvbiwgY2FsbGRhdGEsIG1heEZlZSwgY2hhaW5JZCwgbm9uY2UpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4Njk2ZTc2NmY2YjY1XCIgLyogSU5WT0tFICovLFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIDAsXG4gICAgY2FsbGRhdGEsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlXVxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvaGFzaC90cmFuc2FjdGlvbkhhc2gvdjMudHNcbnZhciB2M19leHBvcnRzID0ge307XG5fX2V4cG9ydCh2M19leHBvcnRzLCB7XG4gIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gyLFxuICBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMixcbiAgY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gsXG4gIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjogKCkgPT4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uMixcbiAgaGFzaERBTW9kZTogKCkgPT4gaGFzaERBTW9kZSxcbiAgaGFzaEZlZUZpZWxkOiAoKSA9PiBoYXNoRmVlRmllbGRcbn0pO1xuaW1wb3J0IHsgcG9zZWlkb25IYXNoTWFueSB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbnZhciBBVG9CSSA9IChhcnJheSkgPT4gYXJyYXkubWFwKChpdCkgPT4gQmlnSW50KGl0KSk7XG52YXIgREFUQV9BVkFJTEFCSUxJVFlfTU9ERV9CSVRTID0gMzJuO1xudmFyIE1BWF9BTU9VTlRfQklUUyA9IDY0bjtcbnZhciBNQVhfUFJJQ0VfUEVSX1VOSVRfQklUUyA9IDEyOG47XG52YXIgUkVTT1VSQ0VfVkFMVUVfT0ZGU0VUID0gTUFYX0FNT1VOVF9CSVRTICsgTUFYX1BSSUNFX1BFUl9VTklUX0JJVFM7XG52YXIgTDFfR0FTX05BTUUgPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoXCJMMV9HQVNcIikpO1xudmFyIEwyX0dBU19OQU1FID0gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKFwiTDJfR0FTXCIpKTtcbmZ1bmN0aW9uIGhhc2hEQU1vZGUobm9uY2VEQU1vZGUsIGZlZURBTW9kZSkge1xuICByZXR1cm4gKEJpZ0ludChub25jZURBTW9kZSkgPDwgREFUQV9BVkFJTEFCSUxJVFlfTU9ERV9CSVRTKSArIEJpZ0ludChmZWVEQU1vZGUpO1xufVxuZnVuY3Rpb24gaGFzaEZlZUZpZWxkKHRpcCwgYm91bmRzKSB7XG4gIGNvbnN0IEwxQm91bmQgPSAoTDFfR0FTX05BTUUgPDwgUkVTT1VSQ0VfVkFMVUVfT0ZGU0VUKSArIChCaWdJbnQoYm91bmRzLmwxX2dhcy5tYXhfYW1vdW50KSA8PCBNQVhfUFJJQ0VfUEVSX1VOSVRfQklUUykgKyBCaWdJbnQoYm91bmRzLmwxX2dhcy5tYXhfcHJpY2VfcGVyX3VuaXQpO1xuICBjb25zdCBMMkJvdW5kID0gKEwyX0dBU19OQU1FIDw8IFJFU09VUkNFX1ZBTFVFX09GRlNFVCkgKyAoQmlnSW50KGJvdW5kcy5sMl9nYXMubWF4X2Ftb3VudCkgPDwgTUFYX1BSSUNFX1BFUl9VTklUX0JJVFMpICsgQmlnSW50KGJvdW5kcy5sMl9nYXMubWF4X3ByaWNlX3Blcl91bml0KTtcbiAgcmV0dXJuIHBvc2VpZG9uSGFzaE1hbnkoW0JpZ0ludCh0aXApLCBMMUJvdW5kLCBMMkJvdW5kXSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yKHR4SGFzaFByZWZpeCwgdmVyc2lvbiwgc2VuZGVyQWRkcmVzcywgY2hhaW5JZCwgbm9uY2UsIHRpcCwgcGF5bWFzdGVyRGF0YSwgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSwgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIHJlc291cmNlQm91bmRzLCBhZGRpdGlvbmFsRGF0YSA9IFtdKSB7XG4gIGNvbnN0IGZlZUZpZWxkSGFzaCA9IGhhc2hGZWVGaWVsZCh0aXAsIHJlc291cmNlQm91bmRzKTtcbiAgY29uc3QgZEFNb2RlSGFzaCA9IGhhc2hEQU1vZGUobm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSwgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpO1xuICBjb25zdCBkYXRhVG9IYXNoID0gQVRvQkkoW1xuICAgIHR4SGFzaFByZWZpeCxcbiAgICB2ZXJzaW9uLFxuICAgIHNlbmRlckFkZHJlc3MsXG4gICAgZmVlRmllbGRIYXNoLFxuICAgIHBvc2VpZG9uSGFzaE1hbnkoQVRvQkkocGF5bWFzdGVyRGF0YSkpLFxuICAgIGNoYWluSWQsXG4gICAgbm9uY2UsXG4gICAgZEFNb2RlSGFzaCxcbiAgICAuLi5BVG9CSShhZGRpdGlvbmFsRGF0YSlcbiAgXSk7XG4gIHJldHVybiB0b0hleChwb3NlaWRvbkhhc2hNYW55KGRhdGFUb0hhc2gpKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gyKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsIHNhbHQsIHZlcnNpb24sIGNoYWluSWQsIG5vbmNlLCBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSwgcmVzb3VyY2VCb3VuZHMsIHRpcCwgcGF5bWFzdGVyRGF0YSkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uMihcbiAgICBcIjB4NjQ2NTcwNmM2Zjc5NWY2MTYzNjM2Zjc1NmU3NFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGNoYWluSWQsXG4gICAgbm9uY2UsXG4gICAgdGlwLFxuICAgIHBheW1hc3RlckRhdGEsXG4gICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICByZXNvdXJjZUJvdW5kcyxcbiAgICBbcG9zZWlkb25IYXNoTWFueShBVG9CSShjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEpKSwgY2xhc3NIYXNoLCBzYWx0XVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDIoY2xhc3NIYXNoLCBjb21waWxlZENsYXNzSGFzaCwgc2VuZGVyQWRkcmVzcywgdmVyc2lvbiwgY2hhaW5JZCwgbm9uY2UsIGFjY291bnREZXBsb3ltZW50RGF0YSwgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSwgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIHJlc291cmNlQm91bmRzLCB0aXAsIHBheW1hc3RlckRhdGEpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjIoXG4gICAgXCIweDY0NjU2MzZjNjE3MjY1XCIgLyogREVDTEFSRSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIHNlbmRlckFkZHJlc3MsXG4gICAgY2hhaW5JZCxcbiAgICBub25jZSxcbiAgICB0aXAsXG4gICAgQVRvQkkocGF5bWFzdGVyRGF0YSksXG4gICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICByZXNvdXJjZUJvdW5kcyxcbiAgICBbcG9zZWlkb25IYXNoTWFueShBVG9CSShhY2NvdW50RGVwbG95bWVudERhdGEpKSwgY2xhc3NIYXNoLCBjb21waWxlZENsYXNzSGFzaF1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaChzZW5kZXJBZGRyZXNzLCB2ZXJzaW9uLCBjb21waWxlZENhbGxkYXRhLCBjaGFpbklkLCBub25jZSwgYWNjb3VudERlcGxveW1lbnREYXRhLCBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSwgcmVzb3VyY2VCb3VuZHMsIHRpcCwgcGF5bWFzdGVyRGF0YSkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uMihcbiAgICBcIjB4Njk2ZTc2NmY2YjY1XCIgLyogSU5WT0tFICovLFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICBjaGFpbklkLFxuICAgIG5vbmNlLFxuICAgIHRpcCxcbiAgICBwYXltYXN0ZXJEYXRhLFxuICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgcmVzb3VyY2VCb3VuZHMsXG4gICAgW3Bvc2VpZG9uSGFzaE1hbnkoQVRvQkkoYWNjb3VudERlcGxveW1lbnREYXRhKSksIHBvc2VpZG9uSGFzaE1hbnkoQVRvQkkoY29tcGlsZWRDYWxsZGF0YSkpXVxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvaGFzaC90cmFuc2FjdGlvbkhhc2gvaW5kZXgudHNcbmZ1bmN0aW9uIGlzVjNJbnZva2VUeChhcmdzKSB7XG4gIHJldHVybiBbYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMywgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GM10uaW5jbHVkZXMoXG4gICAgYXJncy52ZXJzaW9uXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyKGFyZ3MpIHtcbiAgaWYgKGlzVjNJbnZva2VUeChhcmdzKSkge1xuICAgIHJldHVybiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2goXG4gICAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgICBhcmdzLnZlcnNpb24sXG4gICAgICBhcmdzLmNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICBhcmdzLmNoYWluSWQsXG4gICAgICBhcmdzLm5vbmNlLFxuICAgICAgYXJncy5hY2NvdW50RGVwbG95bWVudERhdGEsXG4gICAgICBhcmdzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIGFyZ3MudGlwLFxuICAgICAgYXJncy5wYXltYXN0ZXJEYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoKFxuICAgIGFyZ3Muc2VuZGVyQWRkcmVzcyxcbiAgICBhcmdzLnZlcnNpb24sXG4gICAgYXJncy5jb21waWxlZENhbGxkYXRhLFxuICAgIGFyZ3MubWF4RmVlLFxuICAgIGFyZ3MuY2hhaW5JZCxcbiAgICBhcmdzLm5vbmNlXG4gICk7XG59XG5mdW5jdGlvbiBpc1YzRGVjbGFyZVR4KGFyZ3MpIHtcbiAgcmV0dXJuIFthcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzXS5pbmNsdWRlcyhcbiAgICBhcmdzLnZlcnNpb25cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKGFyZ3MpIHtcbiAgaWYgKGlzVjNEZWNsYXJlVHgoYXJncykpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDIoXG4gICAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICAgIGFyZ3MuY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgICBhcmdzLnZlcnNpb24sXG4gICAgICBhcmdzLmNoYWluSWQsXG4gICAgICBhcmdzLm5vbmNlLFxuICAgICAgYXJncy5hY2NvdW50RGVwbG95bWVudERhdGEsXG4gICAgICBhcmdzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIGFyZ3MudGlwLFxuICAgICAgYXJncy5wYXltYXN0ZXJEYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaChcbiAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgYXJncy52ZXJzaW9uLFxuICAgIGFyZ3MubWF4RmVlLFxuICAgIGFyZ3MuY2hhaW5JZCxcbiAgICBhcmdzLm5vbmNlLFxuICAgIGFyZ3MuY29tcGlsZWRDbGFzc0hhc2hcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVjNEZXBsb3lBY2NvdW50VHgoYXJncykge1xuICByZXR1cm4gW2FwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjNdLmluY2x1ZGVzKFxuICAgIGFyZ3MudmVyc2lvblxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoYXJncykge1xuICBpZiAoaXNWM0RlcGxveUFjY291bnRUeChhcmdzKSkge1xuICAgIHJldHVybiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMihcbiAgICAgIGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgICAgYXJncy5jbGFzc0hhc2gsXG4gICAgICBhcmdzLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgIGFyZ3Muc2FsdCxcbiAgICAgIGFyZ3MudmVyc2lvbixcbiAgICAgIGFyZ3MuY2hhaW5JZCxcbiAgICAgIGFyZ3Mubm9uY2UsXG4gICAgICBhcmdzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIGFyZ3MudGlwLFxuICAgICAgYXJncy5wYXltYXN0ZXJEYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaChcbiAgICBhcmdzLmNvbnRyYWN0QWRkcmVzcyxcbiAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICBhcmdzLmNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgYXJncy5zYWx0LFxuICAgIGFyZ3MudmVyc2lvbixcbiAgICBhcmdzLm1heEZlZSxcbiAgICBhcmdzLmNoYWluSWQsXG4gICAgYXJncy5ub25jZVxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvaGFzaC9jbGFzc0hhc2gudHNcbmltcG9ydCB7IHBvc2VpZG9uSGFzaE1hbnkgYXMgcG9zZWlkb25IYXNoTWFueTIgfSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5cbi8vIHNyYy91dGlscy9qc29uLnRzXG52YXIganNvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChqc29uX2V4cG9ydHMsIHtcbiAgcGFyc2U6ICgpID0+IHBhcnNlMixcbiAgcGFyc2VBbHdheXNBc0JpZzogKCkgPT4gcGFyc2VBbHdheXNBc0JpZyxcbiAgc3RyaW5naWZ5OiAoKSA9PiBzdHJpbmdpZnkyLFxuICBzdHJpbmdpZnlBbHdheXNBc0JpZzogKCkgPT4gc3RyaW5naWZ5QWx3YXlzQXNCaWdcbn0pO1xuaW1wb3J0ICogYXMganNvbiBmcm9tIFwibG9zc2xlc3MtanNvblwiO1xudmFyIHBhcnNlSW50QXNOdW1iZXJPckJpZ0ludCA9ICh4KSA9PiB7XG4gIGlmICghanNvbi5pc0ludGVnZXIoeCkpXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoeCk7XG4gIGNvbnN0IHYgPSBwYXJzZUludCh4LCAxMCk7XG4gIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2KSA/IHYgOiBCaWdJbnQoeCk7XG59O1xudmFyIHBhcnNlMiA9ICh4KSA9PiBqc29uLnBhcnNlKFN0cmluZyh4KSwgdm9pZCAwLCBwYXJzZUludEFzTnVtYmVyT3JCaWdJbnQpO1xudmFyIHBhcnNlQWx3YXlzQXNCaWcgPSAoeCkgPT4ganNvbi5wYXJzZShTdHJpbmcoeCksIHZvaWQgMCwganNvbi5wYXJzZU51bWJlckFuZEJpZ0ludCk7XG52YXIgc3RyaW5naWZ5MiA9ICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBudW1iZXJTdHJpbmdpZmllcnMpID0+IGpzb24uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UsIG51bWJlclN0cmluZ2lmaWVycyk7XG52YXIgc3RyaW5naWZ5QWx3YXlzQXNCaWcgPSBzdHJpbmdpZnkyO1xuXG4vLyBzcmMvdXRpbHMvaGFzaC9jbGFzc0hhc2gudHNcbmZ1bmN0aW9uIGNvbXB1dGVQZWRlcnNlbkhhc2goYSwgYikge1xuICByZXR1cm4gc3RhcmtDdXJ2ZS5wZWRlcnNlbihCaWdJbnQoYSksIEJpZ0ludChiKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlUG9zZWlkb25IYXNoKGEsIGIpIHtcbiAgcmV0dXJuIHRvSGV4KHN0YXJrQ3VydmUucG9zZWlkb25IYXNoKEJpZ0ludChhKSwgQmlnSW50KGIpKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlSGFzaE9uRWxlbWVudHMyKGRhdGEpIHtcbiAgcmV0dXJuIFsuLi5kYXRhLCBkYXRhLmxlbmd0aF0ucmVkdWNlKCh4LCB5KSA9PiBzdGFya0N1cnZlLnBlZGVyc2VuKEJpZ0ludCh4KSwgQmlnSW50KHkpKSwgMCkudG9TdHJpbmcoKTtcbn1cbnZhciBjb21wdXRlUGVkZXJzZW5IYXNoT25FbGVtZW50cyA9IGNvbXB1dGVIYXNoT25FbGVtZW50czI7XG5mdW5jdGlvbiBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50cyhkYXRhKSB7XG4gIHJldHVybiB0b0hleChwb3NlaWRvbkhhc2hNYW55MihkYXRhLm1hcCgoeCkgPT4gQmlnSW50KHgpKSkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goc2FsdCwgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBkZXBsb3llckFkZHJlc3MpIHtcbiAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihjb21waWxlZENhbGxkYXRhKTtcbiAgY29uc3QgQ09OVFJBQ1RfQUREUkVTU19QUkVGSVggPSBmZWx0KFwiMHg1MzU0NDE1MjRiNGU0NTU0NWY0MzRmNGU1NDUyNDE0MzU0NWY0MTQ0NDQ1MjQ1NTM1M1wiKTtcbiAgY29uc3QgaGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoW1xuICAgIENPTlRSQUNUX0FERFJFU1NfUFJFRklYLFxuICAgIGRlcGxveWVyQWRkcmVzcyxcbiAgICBzYWx0LFxuICAgIGNsYXNzSGFzaCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhSGFzaFxuICBdKTtcbiAgcmV0dXJuIHRvSGV4KEJpZ0ludChoYXNoKSAlIEFERFJfQk9VTkQpO1xufVxuZnVuY3Rpb24gbnVsbFNraXBSZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT09IFwiYXR0cmlidXRlc1wiIHx8IGtleSA9PT0gXCJhY2Nlc3NpYmxlX3Njb3Blc1wiKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IHZhbHVlO1xuICB9XG4gIGlmIChrZXkgPT09IFwiZGVidWdfaW5mb1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gdm9pZCAwIDogdmFsdWU7XG59XG5mdW5jdGlvbiBmb3JtYXRTcGFjZXMoanNvbjIpIHtcbiAgbGV0IGluc2lkZVF1b3RlcyA9IGZhbHNlO1xuICBjb25zdCBuZXdTdHJpbmcgPSBbXTtcbiAgZm9yIChjb25zdCBjaGFyIG9mIGpzb24yKSB7XG4gICAgaWYgKGNoYXIgPT09ICdcIicgJiYgKG5ld1N0cmluZy5sZW5ndGggPiAwICYmIG5ld1N0cmluZy5zbGljZSgtMSlbMF0gPT09IFwiXFxcXFwiKSA9PT0gZmFsc2UpIHtcbiAgICAgIGluc2lkZVF1b3RlcyA9ICFpbnNpZGVRdW90ZXM7XG4gICAgfVxuICAgIGlmIChpbnNpZGVRdW90ZXMpIHtcbiAgICAgIG5ld1N0cmluZy5wdXNoKGNoYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHJpbmcucHVzaChjaGFyID09PSBcIjpcIiA/IFwiOiBcIiA6IGNoYXIgPT09IFwiLFwiID8gXCIsIFwiIDogY2hhcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdTdHJpbmcuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIaW50ZWRDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCkge1xuICBjb25zdCB7IGFiaSwgcHJvZ3JhbSB9ID0gY29tcGlsZWRDb250cmFjdDtcbiAgY29uc3QgY29udHJhY3RDbGFzcyA9IHsgYWJpLCBwcm9ncmFtIH07XG4gIGNvbnN0IHNlcmlhbGl6ZWRKc29uID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3RDbGFzcywgbnVsbFNraXBSZXBsYWNlcikpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KHNlcmlhbGl6ZWRKc29uKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaChjb250cmFjdCkge1xuICBjb25zdCBjb21waWxlZENvbnRyYWN0ID0gaXNTdHJpbmcoY29udHJhY3QpID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICBjb25zdCBhcGlWZXJzaW9uID0gdG9IZXgoQVBJX1ZFUlNJT04pO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTC5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBsMUhhbmRsZXJFbnRyeVBvaW50c0hhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUi5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBjb25zdHJ1Y3RvckVudHJ5UG9pbnRIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihcbiAgICBjb21waWxlZENvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGJ1aWx0aW5zSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoXG4gICAgY29tcGlsZWRDb250cmFjdC5wcm9ncmFtLmJ1aWx0aW5zLm1hcCgocykgPT4gZW5jb2RlU2hvcnRTdHJpbmcocykpXG4gICk7XG4gIGNvbnN0IGhpbnRlZENsYXNzSGFzaCA9IGNvbXB1dGVIaW50ZWRDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCk7XG4gIGNvbnN0IGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihjb21waWxlZENvbnRyYWN0LnByb2dyYW0uZGF0YSk7XG4gIHJldHVybiBjb21wdXRlSGFzaE9uRWxlbWVudHMyKFtcbiAgICBhcGlWZXJzaW9uLFxuICAgIGV4dGVybmFsRW50cnlQb2ludHNIYXNoLFxuICAgIGwxSGFuZGxlckVudHJ5UG9pbnRzSGFzaCxcbiAgICBjb25zdHJ1Y3RvckVudHJ5UG9pbnRIYXNoLFxuICAgIGJ1aWx0aW5zSGFzaCxcbiAgICBoaW50ZWRDbGFzc0hhc2gsXG4gICAgZGF0YUhhc2hcbiAgXSk7XG59XG5mdW5jdGlvbiBoYXNoQnVpbHRpbnMoYnVpbHRpbnMpIHtcbiAgcmV0dXJuIHBvc2VpZG9uSGFzaE1hbnkyKFxuICAgIGJ1aWx0aW5zLmZsYXRNYXAoKGl0KSA9PiB7XG4gICAgICByZXR1cm4gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKGl0KSk7XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc2hFbnRyeVBvaW50KGRhdGEpIHtcbiAgY29uc3QgYmFzZSA9IGRhdGEuZmxhdE1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gW0JpZ0ludChpdC5zZWxlY3RvciksIEJpZ0ludChpdC5vZmZzZXQpLCBoYXNoQnVpbHRpbnMoaXQuYnVpbHRpbnMpXTtcbiAgfSk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55MihiYXNlKTtcbn1cbmZ1bmN0aW9uIGhhc2hCeXRlQ29kZVNlZ21lbnRzKGNhc20pIHtcbiAgY29uc3QgYnl0ZUNvZGUgPSBjYXNtLmJ5dGVjb2RlLm1hcCgobikgPT4gQmlnSW50KG4pKTtcbiAgY29uc3QgYnl0ZWNvZGVTZWdtZW50TGVuZ3RocyA9IGNhc20uYnl0ZWNvZGVfc2VnbWVudF9sZW5ndGhzID8/IFtdO1xuICBsZXQgc2VnbWVudFN0YXJ0ID0gMDtcbiAgY29uc3QgaGFzaExlYXZlcyA9IGJ5dGVjb2RlU2VnbWVudExlbmd0aHMuZmxhdE1hcCgobGVuKSA9PiB7XG4gICAgY29uc3Qgc2VnbWVudCA9IGJ5dGVDb2RlLnNsaWNlKHNlZ21lbnRTdGFydCwgc2VnbWVudFN0YXJ0ICs9IGxlbik7XG4gICAgcmV0dXJuIFtCaWdJbnQobGVuKSwgcG9zZWlkb25IYXNoTWFueTIoc2VnbWVudCldO1xuICB9KTtcbiAgcmV0dXJuIDFuICsgcG9zZWlkb25IYXNoTWFueTIoaGFzaExlYXZlcyk7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2goY2FzbSkge1xuICBjb25zdCBDT01QSUxFRF9DTEFTU19WRVJTSU9OID0gXCJDT01QSUxFRF9DTEFTU19WMVwiO1xuICBjb25zdCBjb21waWxlZENsYXNzVmVyc2lvbiA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhDT01QSUxFRF9DTEFTU19WRVJTSU9OKSk7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTCk7XG4gIGNvbnN0IGwxSGFuZGxlcnMgPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkwxX0hBTkRMRVIpO1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IpO1xuICBjb25zdCBieXRlY29kZSA9IGNhc20uYnl0ZWNvZGVfc2VnbWVudF9sZW5ndGhzID8gaGFzaEJ5dGVDb2RlU2VnbWVudHMoY2FzbSkgOiBwb3NlaWRvbkhhc2hNYW55MihjYXNtLmJ5dGVjb2RlLm1hcCgoaXQpID0+IEJpZ0ludChpdCkpKTtcbiAgcmV0dXJuIHRvSGV4KFxuICAgIHBvc2VpZG9uSGFzaE1hbnkyKFtcbiAgICAgIGNvbXBpbGVkQ2xhc3NWZXJzaW9uLFxuICAgICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgICBsMUhhbmRsZXJzLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBieXRlY29kZVxuICAgIF0pXG4gICk7XG59XG5mdW5jdGlvbiBoYXNoRW50cnlQb2ludFNpZXJyYShkYXRhKSB7XG4gIGNvbnN0IGJhc2UgPSBkYXRhLmZsYXRNYXAoKGl0KSA9PiB7XG4gICAgcmV0dXJuIFtCaWdJbnQoaXQuc2VsZWN0b3IpLCBCaWdJbnQoaXQuZnVuY3Rpb25faWR4KV07XG4gIH0pO1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueTIoYmFzZSk7XG59XG5mdW5jdGlvbiBoYXNoQWJpKHNpZXJyYSkge1xuICBjb25zdCBpbmRlbnRTdHJpbmcgPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5MihzaWVycmEuYWJpLCBudWxsKSk7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KGluZGVudFN0cmluZykpLnRvU3RyaW5nKDE2KSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoKHNpZXJyYSkge1xuICBjb25zdCBDT05UUkFDVF9DTEFTU19WRVJTSU9OID0gXCJDT05UUkFDVF9DTEFTU19WMC4xLjBcIjtcbiAgY29uc3QgY29tcGlsZWRDbGFzc1ZlcnNpb24gPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoQ09OVFJBQ1RfQ0xBU1NfVkVSU0lPTikpO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTCk7XG4gIGNvbnN0IGwxSGFuZGxlcnMgPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUik7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SKTtcbiAgY29uc3QgYWJpSGFzaCA9IGhhc2hBYmkoc2llcnJhKTtcbiAgY29uc3Qgc2llcnJhUHJvZ3JhbSA9IHBvc2VpZG9uSGFzaE1hbnkyKHNpZXJyYS5zaWVycmFfcHJvZ3JhbS5tYXAoKGl0KSA9PiBCaWdJbnQoaXQpKSk7XG4gIHJldHVybiB0b0hleChcbiAgICBwb3NlaWRvbkhhc2hNYW55MihbXG4gICAgICBjb21waWxlZENsYXNzVmVyc2lvbixcbiAgICAgIGV4dGVybmFsRW50cnlQb2ludHNIYXNoLFxuICAgICAgbDFIYW5kbGVycyxcbiAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgYWJpSGFzaCxcbiAgICAgIHNpZXJyYVByb2dyYW1cbiAgICBdKVxuICApO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSBpc1N0cmluZyhjb250cmFjdCkgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGlmIChcInNpZXJyYV9wcm9ncmFtXCIgaW4gY29tcGlsZWRDb250cmFjdCkge1xuICAgIHJldHVybiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbn1cblxuLy8gc3JjL3V0aWxzL3N0YXJrLnRzXG52YXIgc3RhcmtfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3RhcmtfZXhwb3J0cywge1xuICBjb21wcmVzc1Byb2dyYW06ICgpID0+IGNvbXByZXNzUHJvZ3JhbSxcbiAgZGVjb21wcmVzc1Byb2dyYW06ICgpID0+IGRlY29tcHJlc3NQcm9ncmFtLFxuICBlc3RpbWF0ZUZlZVRvQm91bmRzOiAoKSA9PiBlc3RpbWF0ZUZlZVRvQm91bmRzLFxuICBlc3RpbWF0ZWRGZWVUb01heEZlZTogKCkgPT4gZXN0aW1hdGVkRmVlVG9NYXhGZWUsXG4gIGZvcm1hdFNpZ25hdHVyZTogKCkgPT4gZm9ybWF0U2lnbmF0dXJlLFxuICBpbnREQU06ICgpID0+IGludERBTSxcbiAgbWFrZUFkZHJlc3M6ICgpID0+IG1ha2VBZGRyZXNzLFxuICByYW5kb21BZGRyZXNzOiAoKSA9PiByYW5kb21BZGRyZXNzLFxuICByZWR1Y2VWMjogKCkgPT4gcmVkdWNlVjIsXG4gIHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5OiAoKSA9PiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheSxcbiAgc2lnbmF0dXJlVG9IZXhBcnJheTogKCkgPT4gc2lnbmF0dXJlVG9IZXhBcnJheSxcbiAgdG9GZWVWZXJzaW9uOiAoKSA9PiB0b0ZlZVZlcnNpb24sXG4gIHRvVHJhbnNhY3Rpb25WZXJzaW9uOiAoKSA9PiB0b1RyYW5zYWN0aW9uVmVyc2lvbixcbiAgdjNEZXRhaWxzOiAoKSA9PiB2M0RldGFpbHNcbn0pO1xuaW1wb3J0IHsgZ2V0U3RhcmtLZXksIHV0aWxzIH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuaW1wb3J0IHsgZ3ppcCwgdW5nemlwIH0gZnJvbSBcInBha29cIjtcbmZ1bmN0aW9uIGNvbXByZXNzUHJvZ3JhbShqc29uUHJvZ3JhbSkge1xuICBjb25zdCBzdHJpbmdpZmllZCA9IGlzU3RyaW5nKGpzb25Qcm9ncmFtKSA/IGpzb25Qcm9ncmFtIDogc3RyaW5naWZ5Mihqc29uUHJvZ3JhbSk7XG4gIGNvbnN0IGNvbXByZXNzZWRQcm9ncmFtID0gZ3ppcChzdHJpbmdpZmllZCk7XG4gIHJldHVybiBidG9hVW5pdmVyc2FsKGNvbXByZXNzZWRQcm9ncmFtKTtcbn1cbmZ1bmN0aW9uIGRlY29tcHJlc3NQcm9ncmFtKGJhc2U2NDIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFzZTY0MikpXG4gICAgcmV0dXJuIGJhc2U2NDI7XG4gIGNvbnN0IGRlY29tcHJlc3NlZCA9IGFycmF5QnVmZmVyVG9TdHJpbmcodW5nemlwKGF0b2JVbml2ZXJzYWwoYmFzZTY0MikpKTtcbiAgcmV0dXJuIHBhcnNlMihkZWNvbXByZXNzZWQpO1xufVxuZnVuY3Rpb24gcmFuZG9tQWRkcmVzcygpIHtcbiAgY29uc3QgcmFuZG9tS2V5UGFpciA9IHV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgcmV0dXJuIGdldFN0YXJrS2V5KHJhbmRvbUtleVBhaXIpO1xufVxuZnVuY3Rpb24gbWFrZUFkZHJlc3MoaW5wdXQpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChpbnB1dCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNpZ25hdHVyZShzaWcpIHtcbiAgaWYgKCFzaWcpXG4gICAgdGhyb3cgRXJyb3IoXCJmb3JtYXRTaWduYXR1cmU6IHByb3ZpZGVkIHNpZ25hdHVyZSBpcyB1bmRlZmluZWRcIik7XG4gIGlmIChBcnJheS5pc0FycmF5KHNpZykpIHtcbiAgICByZXR1cm4gc2lnLm1hcCgoaXQpID0+IHRvSGV4KGl0KSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZztcbiAgICByZXR1cm4gW3RvSGV4KHIpLCB0b0hleChzKV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgbmVlZCB0byBiZSB3ZWllcnN0cmFzcy5TaWduYXR1cmVUeXBlIG9yIGFuIGFycmF5IGZvciBjdXN0b21cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5KHNpZykge1xuICByZXR1cm4gYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheShmb3JtYXRTaWduYXR1cmUoc2lnKSk7XG59XG5mdW5jdGlvbiBzaWduYXR1cmVUb0hleEFycmF5KHNpZykge1xuICByZXR1cm4gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkoZm9ybWF0U2lnbmF0dXJlKHNpZykpO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVkRmVlVG9NYXhGZWUoZXN0aW1hdGVkRmVlLCBvdmVyaGVhZCA9IDUwIC8qIE1BWF9GRUUgKi8pIHtcbiAgcmV0dXJuIGFkZFBlcmNlbnQoZXN0aW1hdGVkRmVlLCBvdmVyaGVhZCk7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZUZlZVRvQm91bmRzKGVzdGltYXRlLCBhbW91bnRPdmVyaGVhZCA9IDUwIC8qIEwxX0JPVU5EX01BWF9BTU9VTlQgKi8sIHByaWNlT3ZlcmhlYWQgPSA1MCAvKiBMMV9CT1VORF9NQVhfUFJJQ0VfUEVSX1VOSVQgKi8pIHtcbiAgaWYgKGlzQmlnSW50KGVzdGltYXRlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBsMl9nYXM6IHsgbWF4X2Ftb3VudDogXCIweDBcIiwgbWF4X3ByaWNlX3Blcl91bml0OiBcIjB4MFwiIH0sXG4gICAgICBsMV9nYXM6IHsgbWF4X2Ftb3VudDogXCIweDBcIiwgbWF4X3ByaWNlX3Blcl91bml0OiBcIjB4MFwiIH1cbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgZXN0aW1hdGUuZ2FzX2NvbnN1bWVkID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBlc3RpbWF0ZS5nYXNfcHJpY2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBFcnJvcihcImVzdGltYXRlRmVlVG9Cb3VuZHM6IGVzdGltYXRlIGlzIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBjb25zdCBtYXhVbml0cyA9IGVzdGltYXRlLmRhdGFfZ2FzX2NvbnN1bWVkICE9PSB2b2lkIDAgJiYgZXN0aW1hdGUuZGF0YV9nYXNfcHJpY2UgIT09IHZvaWQgMCA/IHRvSGV4KGFkZFBlcmNlbnQoQmlnSW50KGVzdGltYXRlLm92ZXJhbGxfZmVlKSAvIEJpZ0ludChlc3RpbWF0ZS5nYXNfcHJpY2UpLCBhbW91bnRPdmVyaGVhZCkpIDogdG9IZXgoYWRkUGVyY2VudChlc3RpbWF0ZS5nYXNfY29uc3VtZWQsIGFtb3VudE92ZXJoZWFkKSk7XG4gIGNvbnN0IG1heFVuaXRQcmljZSA9IHRvSGV4KGFkZFBlcmNlbnQoZXN0aW1hdGUuZ2FzX3ByaWNlLCBwcmljZU92ZXJoZWFkKSk7XG4gIHJldHVybiB7XG4gICAgbDJfZ2FzOiB7IG1heF9hbW91bnQ6IFwiMHgwXCIsIG1heF9wcmljZV9wZXJfdW5pdDogXCIweDBcIiB9LFxuICAgIGwxX2dhczogeyBtYXhfYW1vdW50OiBtYXhVbml0cywgbWF4X3ByaWNlX3Blcl91bml0OiBtYXhVbml0UHJpY2UgfVxuICB9O1xufVxuZnVuY3Rpb24gaW50REFNKGRhbSkge1xuICBpZiAoZGFtID09PSBhcGlfZXhwb3J0cy5FRGF0YUF2YWlsYWJpbGl0eU1vZGUuTDEpXG4gICAgcmV0dXJuIGFwaV9leHBvcnRzLkVEQU1vZGUuTDE7XG4gIGlmIChkYW0gPT09IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMilcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRURBTW9kZS5MMjtcbiAgdGhyb3cgRXJyb3IoXCJFREFNIGNvbnZlcnNpb25cIik7XG59XG5mdW5jdGlvbiB0b1RyYW5zYWN0aW9uVmVyc2lvbihkZWZhdWx0VmVyc2lvbiwgcHJvdmlkZWRWZXJzaW9uKSB7XG4gIGNvbnN0IHByb3ZpZGVkVmVyc2lvbjB4cyA9IHByb3ZpZGVkVmVyc2lvbiA/IHRvSGV4KHByb3ZpZGVkVmVyc2lvbikgOiB2b2lkIDA7XG4gIGNvbnN0IGRlZmF1bHRWZXJzaW9uMHhzID0gdG9IZXgoZGVmYXVsdFZlcnNpb24pO1xuICBpZiAocHJvdmlkZWRWZXJzaW9uICYmICFPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24pLmluY2x1ZGVzKHByb3ZpZGVkVmVyc2lvbjB4cykpIHtcbiAgICB0aHJvdyBFcnJvcihgcHJvdmlkZWRWZXJzaW9uICR7cHJvdmlkZWRWZXJzaW9ufSBpcyBub3QgRVRyYW5zYWN0aW9uVmVyc2lvbmApO1xuICB9XG4gIGlmICghT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uKS5pbmNsdWRlcyhkZWZhdWx0VmVyc2lvbjB4cykpIHtcbiAgICB0aHJvdyBFcnJvcihgZGVmYXVsdFZlcnNpb24gJHtkZWZhdWx0VmVyc2lvbn0gaXMgbm90IEVUcmFuc2FjdGlvblZlcnNpb25gKTtcbiAgfVxuICByZXR1cm4gcHJvdmlkZWRWZXJzaW9uID8gcHJvdmlkZWRWZXJzaW9uMHhzIDogZGVmYXVsdFZlcnNpb24weHM7XG59XG5mdW5jdGlvbiB0b0ZlZVZlcnNpb24ocHJvdmlkZWRWZXJzaW9uKSB7XG4gIGlmICghcHJvdmlkZWRWZXJzaW9uKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHZlcnNpb24gPSB0b0hleChwcm92aWRlZFZlcnNpb24pO1xuICBpZiAodmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMClcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMDtcbiAgaWYgKHZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEpXG4gICAgcmV0dXJuIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjE7XG4gIGlmICh2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyO1xuICBpZiAodmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMylcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMztcbiAgdGhyb3cgRXJyb3IoYHRvRmVlVmVyc2lvbjogJHt2ZXJzaW9ufSBpcyBub3Qgc3VwcG9ydGVkYCk7XG59XG5mdW5jdGlvbiB2M0RldGFpbHMoZGV0YWlscykge1xuICByZXR1cm4ge1xuICAgIHRpcDogZGV0YWlscy50aXAgfHwgMCxcbiAgICBwYXltYXN0ZXJEYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEgfHwgW10sXG4gICAgYWNjb3VudERlcGxveW1lbnREYXRhOiBkZXRhaWxzLmFjY291bnREZXBsb3ltZW50RGF0YSB8fCBbXSxcbiAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUgfHwgYXBpX2V4cG9ydHMuRURhdGFBdmFpbGFiaWxpdHlNb2RlLkwxLFxuICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlIHx8IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMSxcbiAgICByZXNvdXJjZUJvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyA/PyBlc3RpbWF0ZUZlZVRvQm91bmRzKFpFUk8pXG4gIH07XG59XG5mdW5jdGlvbiByZWR1Y2VWMihwcm92aWRlZFZlcnNpb24pIHtcbiAgaWYgKHByb3ZpZGVkVmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMilcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMTtcbiAgaWYgKHByb3ZpZGVkVmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMilcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMTtcbiAgcmV0dXJuIHByb3ZpZGVkVmVyc2lvbjtcbn1cblxuLy8gc3JjL3V0aWxzL2NvbnRyYWN0LnRzXG5mdW5jdGlvbiBpc1NpZXJyYShjb250cmFjdCkge1xuICBjb25zdCBjb21waWxlZENvbnRyYWN0ID0gaXNTdHJpbmcoY29udHJhY3QpID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICByZXR1cm4gXCJzaWVycmFfcHJvZ3JhbVwiIGluIGNvbXBpbGVkQ29udHJhY3Q7XG59XG5mdW5jdGlvbiBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCkge1xuICBjb25zdCByZXNwb25zZSA9IHsgLi4ucGF5bG9hZCB9O1xuICBpZiAoaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkpIHtcbiAgICBpZiAoIXBheWxvYWQuY29tcGlsZWRDbGFzc0hhc2ggJiYgcGF5bG9hZC5jYXNtKSB7XG4gICAgICByZXNwb25zZS5jb21waWxlZENsYXNzSGFzaCA9IGNvbXB1dGVDb21waWxlZENsYXNzSGFzaChwYXlsb2FkLmNhc20pO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmNvbXBpbGVkQ2xhc3NIYXNoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkV4dHJhY3QgY29tcGlsZWRDbGFzc0hhc2ggZmFpbGVkLCBwcm92aWRlIChDYWlyb0Fzc2VtYmx5KS5jYXNtIGZpbGUgb3IgY29tcGlsZWRDbGFzc0hhc2hcIlxuICAgICAgKTtcbiAgfVxuICByZXNwb25zZS5jbGFzc0hhc2ggPSBwYXlsb2FkLmNsYXNzSGFzaCA/PyBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2gocGF5bG9hZC5jb250cmFjdCk7XG4gIGlmICghcmVzcG9uc2UuY2xhc3NIYXNoKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4dHJhY3QgY2xhc3NIYXNoIGZhaWxlZCwgcHJvdmlkZSAoQ29tcGlsZWRDb250cmFjdCkuanNvbiBmaWxlIG9yIGNsYXNzSGFzaFwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gY29udHJhY3RDbGFzc1Jlc3BvbnNlVG9MZWdhY3lDb21waWxlZENvbnRyYWN0KGNjcikge1xuICBpZiAoaXNTaWVycmEoY2NyKSkge1xuICAgIHRocm93IEVycm9yKFwiQ29udHJhY3RDbGFzc1Jlc3BvbnNlIG5lZWQgdG8gYmUgTGVnYWN5Q29udHJhY3RDbGFzcyAoY2Fpcm8wIHJlc3BvbnNlIGNsYXNzKVwiKTtcbiAgfVxuICBjb25zdCBjb250cmFjdCA9IGNjcjtcbiAgcmV0dXJuIHsgLi4uY29udHJhY3QsIHByb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnByb2dyYW0pIH07XG59XG5cbi8vIHNyYy91dGlscy9ldGgudHNcbnZhciBldGhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZXRoX2V4cG9ydHMsIHtcbiAgZXRoUmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gZXRoUmFuZG9tUHJpdmF0ZUtleSxcbiAgdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3M6ICgpID0+IHZhbGlkYXRlQW5kUGFyc2VFdGhBZGRyZXNzXG59KTtcbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuZnVuY3Rpb24gZXRoUmFuZG9tUHJpdmF0ZUtleSgpIHtcbiAgcmV0dXJuIHNhbml0aXplSGV4KGJ1ZjJoZXgoc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3MoYWRkcmVzcykge1xuICBhc3NlcnRJblJhbmdlKGFkZHJlc3MsIFpFUk8sIDJuICoqIDE2MG4gLSAxbiwgXCJFdGhlcmV1bSBBZGRyZXNzIFwiKTtcbiAgY29uc3QgcmVzdWx0ID0gYWRkSGV4UHJlZml4KHJlbW92ZUhleFByZWZpeCh0b0hleChhZGRyZXNzKSkucGFkU3RhcnQoNDAsIFwiMFwiKSk7XG4gIGFzc2VydChyZXN1bHQubWF0Y2goL14oMHgpP1swLTlhLWZdezQwfSQvKSwgXCJJbnZhbGlkIEV0aGVyZXVtIEFkZHJlc3MgRm9ybWF0XCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvdXRpbHMvZmV0Y2hQb255ZmlsbC50c1xuaW1wb3J0IG1ha2VGZXRjaENvb2tpZSBmcm9tIFwiZmV0Y2gtY29va2llXCI7XG5pbXBvcnQgaXNvbW9ycGhpY0ZldGNoIGZyb20gXCJpc29tb3JwaGljLWZldGNoXCI7XG52YXIgZmV0Y2hQb255ZmlsbF9kZWZhdWx0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZmV0Y2ggfHwgLy8gdXNlIGJ1aWxkaW4gZmV0Y2ggaW4gYnJvd3NlciBpZiBhdmFpbGFibGVcbnR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgbWFrZUZldGNoQ29va2llKGdsb2JhbC5mZXRjaCkgfHwgLy8gdXNlIGJ1aWxkaW4gZmV0Y2ggaW4gbm9kZSwgcmVhY3QtbmF0aXZlIGFuZCBzZXJ2aWNlIHdvcmtlciBpZiBhdmFpbGFibGVcbmlzb21vcnBoaWNGZXRjaDtcblxuLy8gc3JjL3V0aWxzL3Byb3ZpZGVyLnRzXG52YXIgcHJvdmlkZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocHJvdmlkZXJfZXhwb3J0cywge1xuICBCbG9jazogKCkgPT4gQmxvY2ssXG4gIGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3M6ICgpID0+IGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MsXG4gIGZvcm1hdEhhc2g6ICgpID0+IGZvcm1hdEhhc2gsXG4gIGdldERlZmF1bHROb2RlVXJsOiAoKSA9PiBnZXREZWZhdWx0Tm9kZVVybCxcbiAgaXNQZW5kaW5nQmxvY2s6ICgpID0+IGlzUGVuZGluZ0Jsb2NrLFxuICBpc1BlbmRpbmdTdGF0ZVVwZGF0ZTogKCkgPT4gaXNQZW5kaW5nU3RhdGVVcGRhdGUsXG4gIGlzUGVuZGluZ1RyYW5zYWN0aW9uOiAoKSA9PiBpc1BlbmRpbmdUcmFuc2FjdGlvbixcbiAgaXNWM1R4OiAoKSA9PiBpc1YzVHgsXG4gIGlzVmVyc2lvbjogKCkgPT4gaXNWZXJzaW9uLFxuICBwYXJzZUNvbnRyYWN0OiAoKSA9PiBwYXJzZUNvbnRyYWN0LFxuICB0eElkZW50aWZpZXI6ICgpID0+IHR4SWRlbnRpZmllcixcbiAgdmFsaWRCbG9ja1RhZ3M6ICgpID0+IHZhbGlkQmxvY2tUYWdzLFxuICB3YWl0OiAoKSA9PiB3YWl0XG59KTtcbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlcywgZGVsYXkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MoY29udHJhY3QpIHtcbiAgY29uc3QgcmVzdWx0ID0geyAuLi5jb250cmFjdCB9O1xuICBkZWxldGUgcmVzdWx0LnNpZXJyYV9wcm9ncmFtX2RlYnVnX2luZm87XG4gIHJlc3VsdC5hYmkgPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdC5hYmkpKTtcbiAgcmVzdWx0LnNpZXJyYV9wcm9ncmFtID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3Quc2llcnJhX3Byb2dyYW0pKTtcbiAgcmVzdWx0LnNpZXJyYV9wcm9ncmFtID0gY29tcHJlc3NQcm9ncmFtKHJlc3VsdC5zaWVycmFfcHJvZ3JhbSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUNvbnRyYWN0KGNvbnRyYWN0KSB7XG4gIGNvbnN0IHBhcnNlZENvbnRyYWN0ID0gaXNTdHJpbmcoY29udHJhY3QpID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wYXJzZWRDb250cmFjdCxcbiAgICAgIC4uLlwicHJvZ3JhbVwiIGluIHBhcnNlZENvbnRyYWN0ICYmIHsgcHJvZ3JhbTogY29tcHJlc3NQcm9ncmFtKHBhcnNlZENvbnRyYWN0LnByb2dyYW0pIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzKHBhcnNlZENvbnRyYWN0KTtcbn1cbnZhciBnZXREZWZhdWx0Tm9kZVVybCA9IChuZXR3b3JrTmFtZSwgbXV0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmICghbXV0ZSkge1xuICAgIGNvbnNvbGUud2FybihcIlVzaW5nIGRlZmF1bHQgcHVibGljIG5vZGUgdXJsLCBwbGVhc2UgcHJvdmlkZSBub2RlVXJsIGluIHByb3ZpZGVyIG9wdGlvbnMhXCIpO1xuICB9XG4gIGNvbnN0IG5vZGVzID0gUlBDX05PREVTW25ldHdvcmtOYW1lID8/IFwiU05fU0VQT0xJQVwiIC8qIFNOX1NFUE9MSUEgKi9dO1xuICBjb25zdCByYW5kSWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKTtcbiAgcmV0dXJuIG5vZGVzW3JhbmRJZHhdO1xufTtcbmZ1bmN0aW9uIGZvcm1hdEhhc2goaGFzaFZhbHVlKSB7XG4gIGlmIChpc1N0cmluZyhoYXNoVmFsdWUpKVxuICAgIHJldHVybiBoYXNoVmFsdWU7XG4gIHJldHVybiB0b0hleChoYXNoVmFsdWUpO1xufVxuZnVuY3Rpb24gdHhJZGVudGlmaWVyKHR4SGFzaCwgdHhJZCkge1xuICBpZiAoIXR4SGFzaCkge1xuICAgIHJldHVybiBgdHJhbnNhY3Rpb25JZD0ke0pTT04uc3RyaW5naWZ5KHR4SWQpfWA7XG4gIH1cbiAgY29uc3QgaGFzaFN0cmluZyA9IGZvcm1hdEhhc2godHhIYXNoKTtcbiAgcmV0dXJuIGB0cmFuc2FjdGlvbkhhc2g9JHtoYXNoU3RyaW5nfWA7XG59XG52YXIgdmFsaWRCbG9ja1RhZ3MgPSBPYmplY3QudmFsdWVzKEJsb2NrVGFnKTtcbnZhciBCbG9jayA9IGNsYXNzIHtcbiAgaGFzaCA9IG51bGw7XG4gIG51bWJlciA9IG51bGw7XG4gIHRhZyA9IG51bGw7XG4gIHNldElkZW50aWZpZXIoX19pZGVudGlmaWVyKSB7XG4gICAgaWYgKGlzU3RyaW5nKF9faWRlbnRpZmllcikpIHtcbiAgICAgIGlmIChpc0RlY2ltYWxTdHJpbmcoX19pZGVudGlmaWVyKSkge1xuICAgICAgICB0aGlzLm51bWJlciA9IHBhcnNlSW50KF9faWRlbnRpZmllciwgMTApO1xuICAgICAgfSBlbHNlIGlmIChpc0hleChfX2lkZW50aWZpZXIpKSB7XG4gICAgICAgIHRoaXMuaGFzaCA9IF9faWRlbnRpZmllcjtcbiAgICAgIH0gZWxzZSBpZiAodmFsaWRCbG9ja1RhZ3MuaW5jbHVkZXMoX19pZGVudGlmaWVyKSkge1xuICAgICAgICB0aGlzLnRhZyA9IF9faWRlbnRpZmllcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihgQmxvY2sgaWRlbnRpZmllciB1bm1hbmFnZWQ6ICR7X19pZGVudGlmaWVyfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNCaWdJbnQoX19pZGVudGlmaWVyKSkge1xuICAgICAgdGhpcy5oYXNoID0gdG9IZXgoX19pZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKF9faWRlbnRpZmllcikpIHtcbiAgICAgIHRoaXMubnVtYmVyID0gX19pZGVudGlmaWVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZyA9IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi87XG4gICAgfVxuICAgIGlmIChpc051bWJlcih0aGlzLm51bWJlcikgJiYgdGhpcy5udW1iZXIgPCAwKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoYEJsb2NrIG51bWJlciAoJHt0aGlzLm51bWJlcn0pIGNhbid0IGJlIG5lZ2F0aXZlYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKF9pZGVudGlmaWVyKSB7XG4gICAgdGhpcy5zZXRJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgfVxuICAvLyBUT0RPOiBmaXggYW55XG4gIGdldCBxdWVyeUlkZW50aWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubnVtYmVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYGJsb2NrTnVtYmVyPSR7dGhpcy5udW1iZXJ9YDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGBibG9ja0hhc2g9JHt0aGlzLmhhc2h9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBibG9ja051bWJlcj0ke3RoaXMudGFnfWA7XG4gIH1cbiAgLy8gVE9ETzogZml4IGFueVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICBpZiAodGhpcy5udW1iZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGJsb2NrX251bWJlcjogdGhpcy5udW1iZXIgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgYmxvY2tfaGFzaDogdGhpcy5oYXNoIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZztcbiAgfVxuICBzZXQgaWRlbnRpZmllcihfaWRlbnRpZmllcikge1xuICAgIHRoaXMuc2V0SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gIH1cbiAgdmFsdWVPZiA9ICgpID0+IHRoaXMubnVtYmVyO1xuICB0b1N0cmluZyA9ICgpID0+IHRoaXMuaGFzaDtcbn07XG5mdW5jdGlvbiBpc1YzVHgoZGV0YWlscykge1xuICBjb25zdCB2ZXJzaW9uID0gZGV0YWlscy52ZXJzaW9uID8gdG9IZXgoZGV0YWlscy52ZXJzaW9uKSA6IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjM7XG4gIHJldHVybiB2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzIHx8IHZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjM7XG59XG5mdW5jdGlvbiBpc1ZlcnNpb24odmVyc2lvbiwgcmVzcG9uc2UpIHtcbiAgY29uc3QgW21ham9yUywgbWlub3JTXSA9IHZlcnNpb24uc3BsaXQoXCIuXCIpO1xuICBjb25zdCBbbWFqb3JSLCBtaW5vclJdID0gcmVzcG9uc2Uuc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gbWFqb3JTID09PSBtYWpvclIgJiYgbWlub3JTID09PSBtaW5vclI7XG59XG5mdW5jdGlvbiBpc1BlbmRpbmdCbG9jayhyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2Uuc3RhdHVzID09PSBcIlBFTkRJTkdcIjtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZ1RyYW5zYWN0aW9uKHJlc3BvbnNlKSB7XG4gIHJldHVybiAhKFwiYmxvY2tfaGFzaFwiIGluIHJlc3BvbnNlKTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZ1N0YXRlVXBkYXRlKHJlc3BvbnNlKSB7XG4gIHJldHVybiAhKFwiYmxvY2tfaGFzaFwiIGluIHJlc3BvbnNlKTtcbn1cblxuLy8gc3JjL3V0aWxzL3RyYW5zYWN0aW9uLnRzXG52YXIgdHJhbnNhY3Rpb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHJhbnNhY3Rpb25fZXhwb3J0cywge1xuICBidWlsZFVEQ0NhbGw6ICgpID0+IGJ1aWxkVURDQ2FsbCxcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGE6ICgpID0+IGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhLFxuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFXaXRoTm9uY2UsXG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xLFxuICBnZXRFeGVjdXRlQ2FsbGRhdGE6ICgpID0+IGdldEV4ZWN1dGVDYWxsZGF0YSxcbiAgZ2V0VmVyc2lvbnNCeVR5cGU6ICgpID0+IGdldFZlcnNpb25zQnlUeXBlLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMTogKCkgPT4gdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzFcbn0pO1xudmFyIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gW107XG4gIGNvbnN0IGNhbGxkYXRhID0gW107XG4gIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICBjb25zdCBkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKTtcbiAgICBjYWxsQXJyYXkucHVzaCh7XG4gICAgICB0bzogdG9CaWdJbnQoY2FsbC5jb250cmFjdEFkZHJlc3MpLnRvU3RyaW5nKDEwKSxcbiAgICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICAgIGRhdGFfb2Zmc2V0OiBjYWxsZGF0YS5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAgIGRhdGFfbGVuOiBkYXRhLmxlbmd0aC50b1N0cmluZygpXG4gICAgfSk7XG4gICAgY2FsbGRhdGEucHVzaCguLi5kYXRhKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsbEFycmF5LFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHsgY2FsbGRhdGEgfSlcbiAgfTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgeyBjYWxsQXJyYXksIGNhbGxkYXRhIH0gPSB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzKGNhbGxzKTtcbiAgY29uc3QgY29tcGlsZWRDYWxscyA9IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsQXJyYXkgfSk7XG4gIHJldHVybiBbLi4uY29tcGlsZWRDYWxscywgLi4uY2FsbGRhdGFdO1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSA9IChjYWxscywgbm9uY2UpID0+IHtcbiAgcmV0dXJuIFsuLi5mcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YShjYWxscyksIHRvQmlnSW50KG5vbmNlKS50b1N0cmluZygpXTtcbn07XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKVxuICB9KSk7XG4gIHJldHVybiBjYWxsQXJyYXk7XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBvcmRlckNhbGxzID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlwb2ludDogY2FsbC5lbnRyeXBvaW50LFxuICAgIGNhbGxkYXRhOiBBcnJheS5pc0FycmF5KGNhbGwuY2FsbGRhdGEpICYmIFwiX19jb21waWxlZF9fXCIgaW4gY2FsbC5jYWxsZGF0YSA/IGNhbGwuY2FsbGRhdGEgOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEpXG4gICAgLy8gUmF3QXJnc09iamVjdCB8IFJhd0FyZ3NBcnJheSB0eXBlXG4gIH0pKTtcbiAgcmV0dXJuIENhbGxEYXRhLmNvbXBpbGUoeyBvcmRlckNhbGxzIH0pO1xufTtcbnZhciBnZXRFeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMsIGNhaXJvVmVyc2lvbiA9IFwiMFwiKSA9PiB7XG4gIGlmIChjYWlyb1ZlcnNpb24gPT09IFwiMVwiKSB7XG4gICAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMShjYWxscyk7XG4gIH1cbiAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKTtcbn07XG5mdW5jdGlvbiBidWlsZFVEQ0NhbGwocGF5bG9hZCwgYWRkcmVzcykge1xuICBjb25zdCBwYXJhbXMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIHNhbHQsXG4gICAgICB1bmlxdWUgPSB0cnVlLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdXG4gICAgfSA9IGl0O1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgZGVwbG95U2FsdCA9IHNhbHQgPz8gcmFuZG9tQWRkcmVzcygpO1xuICAgIHJldHVybiB7XG4gICAgICBjYWxsOiB7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogVURDLkFERFJFU1MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFVEQy5FTlRSWVBPSU5ULFxuICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBkZXBsb3lTYWx0LFxuICAgICAgICAgIHRvQ2Fpcm9Cb29sKHVuaXF1ZSksXG4gICAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi5jb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGFcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGFkZHJlc3M6IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKFxuICAgICAgICB1bmlxdWUgPyBzdGFya0N1cnZlLnBlZGVyc2VuKGFkZHJlc3MsIGRlcGxveVNhbHQpIDogZGVwbG95U2FsdCxcbiAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEsXG4gICAgICAgIHVuaXF1ZSA/IFVEQy5BRERSRVNTIDogMFxuICAgICAgKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNhbGxzOiBwYXJhbXMubWFwKChpdCkgPT4gaXQuY2FsbCksXG4gICAgYWRkcmVzc2VzOiBwYXJhbXMubWFwKChpdCkgPT4gaXQuYWRkcmVzcylcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFZlcnNpb25zQnlUeXBlKHZlcnNpb25UeXBlKSB7XG4gIHJldHVybiB2ZXJzaW9uVHlwZSA9PT0gXCJmZWVcIiA/IHtcbiAgICB2MTogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMSxcbiAgICB2MjogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMixcbiAgICB2MzogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GM1xuICB9IDogeyB2MTogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSwgdjI6IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIsIHYzOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzIH07XG59XG5cbi8vIHNyYy9jaGFubmVsL3JwY18wXzYudHNcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICBibG9ja0lkZW50aWZpZXI6IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8sXG4gIHJldHJpZXM6IDIwMFxufTtcbnZhciBScGNDaGFubmVsID0gY2xhc3Mge1xuICBub2RlVXJsO1xuICBoZWFkZXJzO1xuICByZXRyaWVzO1xuICByZXF1ZXN0SWQ7XG4gIGJsb2NrSWRlbnRpZmllcjtcbiAgY2hhaW5JZDtcbiAgc3BlY1ZlcnNpb247XG4gIHdhaXRNb2RlO1xuICAvLyBiZWhhdmUgbGlrZSB3ZWIyIHJwYyBhbmQgcmV0dXJuIHdoZW4gdHggaXMgcHJvY2Vzc2VkXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnNPclByb3ZpZGVyKSB7XG4gICAgY29uc3QgeyBub2RlVXJsLCByZXRyaWVzLCBoZWFkZXJzLCBibG9ja0lkZW50aWZpZXIsIGNoYWluSWQsIHNwZWNWZXJzaW9uLCB3YWl0TW9kZSB9ID0gb3B0aW9uc09yUHJvdmlkZXIgfHwge307XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoTmV0d29ya05hbWUpLmluY2x1ZGVzKG5vZGVVcmwpKSB7XG4gICAgICB0aGlzLm5vZGVVcmwgPSBnZXREZWZhdWx0Tm9kZVVybChub2RlVXJsLCBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCk7XG4gICAgfSBlbHNlIGlmIChub2RlVXJsKSB7XG4gICAgICB0aGlzLm5vZGVVcmwgPSBub2RlVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGVVcmwgPSBnZXREZWZhdWx0Tm9kZVVybCh2b2lkIDAsIG9wdGlvbnNPclByb3ZpZGVyPy5kZWZhdWx0KTtcbiAgICB9XG4gICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcyB8fCBkZWZhdWx0T3B0aW9ucy5yZXRyaWVzO1xuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMuaGVhZGVycywgLi4uaGVhZGVycyB9O1xuICAgIHRoaXMuYmxvY2tJZGVudGlmaWVyID0gYmxvY2tJZGVudGlmaWVyIHx8IGRlZmF1bHRPcHRpb25zLmJsb2NrSWRlbnRpZmllcjtcbiAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICAgIHRoaXMuc3BlY1ZlcnNpb24gPSBzcGVjVmVyc2lvbjtcbiAgICB0aGlzLndhaXRNb2RlID0gd2FpdE1vZGUgfHwgZmFsc2U7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSAwO1xuICB9XG4gIHNldENoYWluSWQoY2hhaW5JZCkge1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gIH1cbiAgZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkID0gMCkge1xuICAgIGNvbnN0IHJwY1JlcXVlc3RCb2R5ID0ge1xuICAgICAgaWQsXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kLFxuICAgICAgLi4ucGFyYW1zICYmIHsgcGFyYW1zIH1cbiAgICB9O1xuICAgIHJldHVybiBmZXRjaFBvbnlmaWxsX2RlZmF1bHQodGhpcy5ub2RlVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5MihycGNSZXF1ZXN0Qm9keSksXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuICBlcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIHJwY0Vycm9yLCBvdGhlckVycm9yKSB7XG4gICAgaWYgKHJwY0Vycm9yKSB7XG4gICAgICBjb25zdCB7IGNvZGUsIG1lc3NhZ2UsIGRhdGEgfSA9IHJwY0Vycm9yO1xuICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcihcbiAgICAgICAgYFJQQzogJHttZXRob2R9IHdpdGggcGFyYW1zICR7c3RyaW5naWZ5MihwYXJhbXMsIG51bGwsIDIpfVxuIFxuICAgICAgICAke2NvZGV9OiAke21lc3NhZ2V9OiAke3N0cmluZ2lmeTIoZGF0YSl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG90aGVyRXJyb3IgaW5zdGFuY2VvZiBMaWJyYXJ5RXJyb3IpIHtcbiAgICAgIHRocm93IG90aGVyRXJyb3I7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yKSB7XG4gICAgICB0aHJvdyBFcnJvcihvdGhlckVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaEVuZHBvaW50KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IGF3YWl0IHRoaXMuZmV0Y2gobWV0aG9kLCBwYXJhbXMsIHRoaXMucmVxdWVzdElkICs9IDEpO1xuICAgICAgY29uc3QgeyBlcnJvciwgcmVzdWx0IH0gPSBhd2FpdCByYXdSZXN1bHQuanNvbigpO1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcj8ucmVzcG9uc2U/LmRhdGEsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHRoaXMuY2hhaW5JZCA/Pz0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfY2hhaW5JZFwiKTtcbiAgICByZXR1cm4gdGhpcy5jaGFpbklkO1xuICB9XG4gIGFzeW5jIGdldFNwZWNWZXJzaW9uKCkge1xuICAgIHRoaXMuc3BlY1ZlcnNpb24gPz89IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NwZWNWZXJzaW9uXCIpO1xuICAgIHJldHVybiB0aGlzLnNwZWNWZXJzaW9uO1xuICB9XG4gIGdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXROb25jZVwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBoYXNoIGFuZCBudW1iZXJcbiAgICovXG4gIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrSGFzaEFuZE51bWJlclwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBudW1iZXJcbiAgICogcmVkdW5kYW50IHVzZSBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gICAqIEByZXR1cm5zIE51bWJlciBvZiB0aGUgbGF0ZXN0IGJsb2NrXG4gICAqL1xuICBnZXRCbG9ja051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tOdW1iZXJcIik7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4SGFzaGVzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdGF0ZVVwZGF0ZVwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZUJsb2NrVHJhbnNhY3Rpb25zXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaFxuICAgIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleFwiLCB7IGJsb2NrX2lkLCBpbmRleCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VUcmFuc2FjdGlvblwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblN0YXR1c1wiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zIGJsb2NrSWRlbnRpZmllciBhbmQgZmxhZ3MgdG8gc2tpcCB2YWxpZGF0aW9uIGFuZCBmZWUgY2hhcmdlPGJyLz5cbiAgICogLSBibG9ja0lkZW50aWZpZXI8YnIvPlxuICAgKiAtIHNraXBWYWxpZGF0ZSAoZGVmYXVsdCBmYWxzZSk8YnIvPlxuICAgKiAtIHNraXBGZWVDaGFyZ2UgKGRlZmF1bHQgdHJ1ZSk8YnIvPlxuICAgKi9cbiAgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywge1xuICAgIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLFxuICAgIHNraXBWYWxpZGF0ZSA9IHRydWUsXG4gICAgc2tpcEZlZUNoYXJnZSA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHNpbXVsYXRpb25GbGFncyA9IFtdO1xuICAgIGlmIChza2lwVmFsaWRhdGUpXG4gICAgICBzaW11bGF0aW9uRmxhZ3MucHVzaChycGNzcGVjXzBfNl9leHBvcnRzLkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFKTtcbiAgICBpZiAoc2tpcEZlZUNoYXJnZSlcbiAgICAgIHNpbXVsYXRpb25GbGFncy5wdXNoKHJwY3NwZWNfMF82X2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfRkVFX0NIQVJHRSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NpbXVsYXRlVHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgdHJhbnNhY3Rpb25zOiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQpKSxcbiAgICAgIHNpbXVsYXRpb25fZmxhZ3M6IHNpbXVsYXRpb25GbGFnc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIGxldCB7IHJldHJpZXMgfSA9IHRoaXM7XG4gICAgbGV0IG9uY2hhaW4gPSBmYWxzZTtcbiAgICBsZXQgaXNFcnJvclN0YXRlID0gZmFsc2U7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IG9wdGlvbnM/LnJldHJ5SW50ZXJ2YWwgPz8gNWUzO1xuICAgIGNvbnN0IGVycm9yU3RhdGVzID0gb3B0aW9ucz8uZXJyb3JTdGF0ZXMgPz8gW1xuICAgICAgcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuUkVKRUNURURcbiAgICAgIC8vIFRPRE86IGNvbW1lbnRlZCBvdXQgdG8gcHJlc2VydmUgdGhlIGxvbmctc3RhbmRpbmcgYmVoYXZpb3Igb2YgXCJyZXZlcnRlZFwiIG5vdCBiZWluZyB0cmVhdGVkIGFzIGFuIGVycm9yIGJ5IGRlZmF1bHRcbiAgICAgIC8vIHNob3VsZCBkZWNpZGUgd2hpY2ggYmVoYXZpb3IgdG8ga2VlcCBpbiB0aGUgZnV0dXJlXG4gICAgICAvLyBSUEMuRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlJFVkVSVEVELFxuICAgIF07XG4gICAgY29uc3Qgc3VjY2Vzc1N0YXRlcyA9IG9wdGlvbnM/LnN1Y2Nlc3NTdGF0ZXMgPz8gW1xuICAgICAgcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuU1VDQ0VFREVELFxuICAgICAgcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDIsXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMVxuICAgIF07XG4gICAgbGV0IHR4U3RhdHVzO1xuICAgIHdoaWxlICghb25jaGFpbikge1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR4U3RhdHVzID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBjb25zdCBleGVjdXRpb25TdGF0dXMgPSB0eFN0YXR1cy5leGVjdXRpb25fc3RhdHVzO1xuICAgICAgICBjb25zdCBmaW5hbGl0eVN0YXR1cyA9IHR4U3RhdHVzLmZpbmFsaXR5X3N0YXR1cztcbiAgICAgICAgaWYgKCFmaW5hbGl0eVN0YXR1cykge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwid2FpdGluZyBmb3IgdHJhbnNhY3Rpb24gc3RhdHVzXCIpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvclN0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IGVycm9yU3RhdGVzLmluY2x1ZGVzKGZpbmFsaXR5U3RhdHVzKSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtleGVjdXRpb25TdGF0dXN9OiAke2ZpbmFsaXR5U3RhdHVzfWA7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSB0eFN0YXR1cztcbiAgICAgICAgICBpc0Vycm9yU3RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGVsc2UgaWYgKHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMoZXhlY3V0aW9uU3RhdHVzKSB8fCBzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKGZpbmFsaXR5U3RhdHVzKSkge1xuICAgICAgICAgIG9uY2hhaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBpc0Vycm9yU3RhdGUpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yVHJhbnNhY3Rpb24gdGltZWQtb3V0IHdpdGggcmV0cmllcyAke3RoaXMucmV0cmllc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmllcyAtPSAxO1xuICAgIH1cbiAgICBsZXQgdHhSZWNlaXB0ID0gbnVsbDtcbiAgICB3aGlsZSAodHhSZWNlaXB0ID09PSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgfVxuICAgIHJldHVybiB0eFJlY2VpcHQ7XG4gIH1cbiAgZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IHRvU3RvcmFnZUtleShrZXkpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0U3RvcmFnZUF0XCIsIHtcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBrZXk6IHBhcnNlZEtleSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NIYXNoQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNsYXNzX2hhc2ggPSB0b0hleChjbGFzc0hhc2gpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NcIiwge1xuICAgICAgY2xhc3NfaGFzaCxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc0F0XCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgY29udHJhY3RfYWRkcmVzc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlKGludm9jYXRpb25zLCB7IGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSB0cnVlIH0pIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgbGV0IGZsYWdzID0ge307XG4gICAgaWYgKCFpc1ZlcnNpb24oXCIwLjVcIiwgYXdhaXQgdGhpcy5nZXRTcGVjVmVyc2lvbigpKSkge1xuICAgICAgZmxhZ3MgPSB7XG4gICAgICAgIHNpbXVsYXRpb25fZmxhZ3M6IHNraXBWYWxpZGF0ZSA/IFtycGNzcGVjXzBfNl9leHBvcnRzLkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFXSA6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0LCBcImZlZVwiKSksXG4gICAgICBibG9ja19pZCxcbiAgICAgIC4uLmZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaW52b2tlKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBpbnZva2VfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogZnVuY3Rpb25JbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHZlcnNpb246IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBpbnZva2VfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChmdW5jdGlvbkludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICAgIHZlcnNpb246IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGRldGFpbHMuYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZSh7IGNvbnRyYWN0LCBzaWduYXR1cmUsIHNlbmRlckFkZHJlc3MsIGNvbXBpbGVkQ2xhc3NIYXNoIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSAmJiAhaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgICBwcm9ncmFtOiBjb250cmFjdC5wcm9ncmFtLFxuICAgICAgICAgICAgZW50cnlfcG9pbnRzX2J5X3R5cGU6IGNvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLFxuICAgICAgICAgICAgYWJpOiBjb250cmFjdC5hYmlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlcnNpb246IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2NsYXNzX3ZlcnNpb246IGNvbnRyYWN0LmNvbnRyYWN0X2NsYXNzX3ZlcnNpb24sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgICB2ZXJzaW9uOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNTaWVycmEoY29udHJhY3QpICYmIGlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICAgIHZlcnNpb246IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5zaWVycmFfcHJvZ3JhbSksXG4gICAgICAgICAgICBjb250cmFjdF9jbGFzc192ZXJzaW9uOiBjb250cmFjdC5jb250cmFjdF9jbGFzc192ZXJzaW9uLFxuICAgICAgICAgICAgZW50cnlfcG9pbnRzX2J5X3R5cGU6IGNvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLFxuICAgICAgICAgICAgYWJpOiBjb250cmFjdC5hYmlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGRldGFpbHMuYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcImRlY2xhcmUgdW5zcG90dGVkIHBhcmFtZXRlcnNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50KHsgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBhZGRyZXNzU2FsdCwgc2lnbmF0dXJlIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGNsYXNzSGFzaCksXG4gICAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChhZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFUExPWV9BQ0NPVU5ULFxuICAgICAgICAgIHZlcnNpb246IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChhZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgICAgICByZXNvdXJjZV9ib3VuZHM6IGRldGFpbHMucmVzb3VyY2VCb3VuZHMsXG4gICAgICAgICAgdGlwOiB0b0hleChkZXRhaWxzLnRpcCksXG4gICAgICAgICAgcGF5bWFzdGVyX2RhdGE6IGRldGFpbHMucGF5bWFzdGVyRGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIG5vbmNlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdE1vZGUgPyB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbigoYXdhaXQgcHJvbWlzZSkudHJhbnNhY3Rpb25faGFzaCkgOiBwcm9taXNlO1xuICB9XG4gIGNhbGxDb250cmFjdChjYWxsLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfY2FsbFwiLCB7XG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGNhbGwuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3JGcm9tTmFtZShjYWxsLmVudHJ5cG9pbnQpLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY2FsbC5jYWxsZGF0YSlcbiAgICAgIH0sXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBORVc6IEVzdGltYXRlIHRoZSBmZWUgZm9yIGEgbWVzc2FnZSBmcm9tIEwxXG4gICAqIEBwYXJhbSBtZXNzYWdlIE1lc3NhZ2UgRnJvbSBMMVxuICAgKi9cbiAgZXN0aW1hdGVNZXNzYWdlRmVlKG1lc3NhZ2UsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgeyBmcm9tX2FkZHJlc3MsIHRvX2FkZHJlc3MsIGVudHJ5X3BvaW50X3NlbGVjdG9yLCBwYXlsb2FkIH0gPSBtZXNzYWdlO1xuICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSB7XG4gICAgICBmcm9tX2FkZHJlc3M6IHZhbGlkYXRlQW5kUGFyc2VFdGhBZGRyZXNzKGZyb21fYWRkcmVzcyksXG4gICAgICB0b19hZGRyZXNzOiB0b0hleCh0b19hZGRyZXNzKSxcbiAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvcihlbnRyeV9wb2ludF9zZWxlY3RvciksXG4gICAgICBwYXlsb2FkOiBnZXRIZXhTdHJpbmdBcnJheShwYXlsb2FkKVxuICAgIH07XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9lc3RpbWF0ZU1lc3NhZ2VGZWVcIiwge1xuICAgICAgbWVzc2FnZTogZm9ybWF0dGVkTWVzc2FnZSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGFib3V0IHRoZSBzeW5jIHN0YXR1cywgb3IgZmFsc2UgaWYgdGhlIG5vZGUgaXMgbm90IHN5bmNoaW5nXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHRoZSBzdGF0cyBkYXRhXG4gICAqL1xuICBnZXRTeW5jaW5nU3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3N5bmNpbmdcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gZmlsdGVyXG4gICAqIEByZXR1cm5zIGV2ZW50cyBhbmQgdGhlIHBhZ2luYXRpb24gb2YgdGhlIGV2ZW50c1xuICAgKi9cbiAgZ2V0RXZlbnRzKGV2ZW50RmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEV2ZW50c1wiLCB7IGZpbHRlcjogZXZlbnRGaWx0ZXIgfSk7XG4gIH1cbiAgYnVpbGRUcmFuc2FjdGlvbihpbnZvY2F0aW9uLCB2ZXJzaW9uVHlwZSkge1xuICAgIGNvbnN0IGRlZmF1bHRWZXJzaW9ucyA9IGdldFZlcnNpb25zQnlUeXBlKHZlcnNpb25UeXBlKTtcbiAgICBsZXQgZGV0YWlscztcbiAgICBpZiAoIWlzVjNUeChpbnZvY2F0aW9uKSkge1xuICAgICAgZGV0YWlscyA9IHtcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgbm9uY2U6IHRvSGV4KGludm9jYXRpb24ubm9uY2UpLFxuICAgICAgICBtYXhfZmVlOiB0b0hleChpbnZvY2F0aW9uLm1heEZlZSB8fCAwKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWlscyA9IHtcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgbm9uY2U6IHRvSGV4KGludm9jYXRpb24ubm9uY2UpLFxuICAgICAgICByZXNvdXJjZV9ib3VuZHM6IGludm9jYXRpb24ucmVzb3VyY2VCb3VuZHMsXG4gICAgICAgIHRpcDogdG9IZXgoaW52b2NhdGlvbi50aXApLFxuICAgICAgICBwYXltYXN0ZXJfZGF0YTogaW52b2NhdGlvbi5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgIG5vbmNlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGludm9jYXRpb24ubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGludm9jYXRpb24uZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgIGFjY291bnRfZGVwbG95bWVudF9kYXRhOiBpbnZvY2F0aW9uLmFjY291bnREZXBsb3ltZW50RGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gdjAgdjEgdjNcbiAgICAgICAgdHlwZTogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoaW52b2NhdGlvbi5jYWxsZGF0YSksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovKSB7XG4gICAgICBpZiAoIWlzU2llcnJhKGludm9jYXRpb24uY29udHJhY3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gQ2Fpcm8gMSAtIHYyIHYzXG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShpbnZvY2F0aW9uLmNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKVxuICAgICAgICB9LFxuICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBpbnZvY2F0aW9uLmNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgIGNvbnN0IHsgYWNjb3VudF9kZXBsb3ltZW50X2RhdGEsIC4uLnJlc3REZXRhaWxzIH0gPSBkZXRhaWxzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoaW52b2NhdGlvbi5jb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoaW52b2NhdGlvbi5jbGFzc0hhc2gpLFxuICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGludm9jYXRpb24uYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5yZXN0RGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJSUEMgYnVpbGRUcmFuc2FjdGlvbiByZWNlaXZlZCB1bmtub3duIFRyYW5zYWN0aW9uVHlwZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL2NoYW5uZWwvcnBjXzBfNy50c1xudmFyIHJwY18wXzdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocnBjXzBfN19leHBvcnRzLCB7XG4gIFJwY0NoYW5uZWw6ICgpID0+IFJwY0NoYW5uZWwyXG59KTtcbnZhciBkZWZhdWx0T3B0aW9uczIgPSB7XG4gIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgYmxvY2tJZGVudGlmaWVyOiBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovLFxuICByZXRyaWVzOiAyMDBcbn07XG52YXIgUnBjQ2hhbm5lbDIgPSBjbGFzcyB7XG4gIG5vZGVVcmw7XG4gIGhlYWRlcnM7XG4gIHJldHJpZXM7XG4gIHJlcXVlc3RJZDtcbiAgYmxvY2tJZGVudGlmaWVyO1xuICBjaGFpbklkO1xuICBzcGVjVmVyc2lvbjtcbiAgd2FpdE1vZGU7XG4gIC8vIGJlaGF2ZSBsaWtlIHdlYjIgcnBjIGFuZCByZXR1cm4gd2hlbiB0eCBpcyBwcm9jZXNzZWRcbiAgY29uc3RydWN0b3Iob3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICBjb25zdCB7IG5vZGVVcmwsIHJldHJpZXMsIGhlYWRlcnMsIGJsb2NrSWRlbnRpZmllciwgY2hhaW5JZCwgc3BlY1ZlcnNpb24sIHdhaXRNb2RlIH0gPSBvcHRpb25zT3JQcm92aWRlciB8fCB7fTtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhOZXR3b3JrTmFtZSkuaW5jbHVkZXMobm9kZVVybCkpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKG5vZGVVcmwsIG9wdGlvbnNPclByb3ZpZGVyPy5kZWZhdWx0KTtcbiAgICB9IGVsc2UgaWYgKG5vZGVVcmwpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IG5vZGVVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKHZvaWQgMCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQpO1xuICAgIH1cbiAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzIHx8IGRlZmF1bHRPcHRpb25zMi5yZXRyaWVzO1xuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMyLmhlYWRlcnMsIC4uLmhlYWRlcnMgfTtcbiAgICB0aGlzLmJsb2NrSWRlbnRpZmllciA9IGJsb2NrSWRlbnRpZmllciB8fCBkZWZhdWx0T3B0aW9uczIuYmxvY2tJZGVudGlmaWVyO1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgdGhpcy5zcGVjVmVyc2lvbiA9IHNwZWNWZXJzaW9uO1xuICAgIHRoaXMud2FpdE1vZGUgPSB3YWl0TW9kZSB8fCBmYWxzZTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IDA7XG4gIH1cbiAgc2V0Q2hhaW5JZChjaGFpbklkKSB7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgfVxuICBmZXRjaChtZXRob2QsIHBhcmFtcywgaWQgPSAwKSB7XG4gICAgY29uc3QgcnBjUmVxdWVzdEJvZHkgPSB7XG4gICAgICBpZCxcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICBtZXRob2QsXG4gICAgICAuLi5wYXJhbXMgJiYgeyBwYXJhbXMgfVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoUG9ueWZpbGxfZGVmYXVsdCh0aGlzLm5vZGVVcmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBzdHJpbmdpZnkyKHJwY1JlcXVlc3RCb2R5KSxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgIH0pO1xuICB9XG4gIGVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgcnBjRXJyb3IsIG90aGVyRXJyb3IpIHtcbiAgICBpZiAocnBjRXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gcnBjRXJyb3I7XG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKFxuICAgICAgICBgUlBDOiAke21ldGhvZH0gd2l0aCBwYXJhbXMgJHtzdHJpbmdpZnkyKHBhcmFtcywgbnVsbCwgMil9XG4gXG4gICAgICAgICR7Y29kZX06ICR7bWVzc2FnZX06ICR7c3RyaW5naWZ5MihkYXRhKX1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvciBpbnN0YW5jZW9mIExpYnJhcnlFcnJvcikge1xuICAgICAgdGhyb3cgb3RoZXJFcnJvcjtcbiAgICB9XG4gICAgaWYgKG90aGVyRXJyb3IpIHtcbiAgICAgIHRocm93IEVycm9yKG90aGVyRXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZldGNoRW5kcG9pbnQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmF3UmVzdWx0ID0gYXdhaXQgdGhpcy5mZXRjaChtZXRob2QsIHBhcmFtcywgdGhpcy5yZXF1ZXN0SWQgKz0gMSk7XG4gICAgICBjb25zdCB7IGVycm9yLCByZXN1bHQgfSA9IGF3YWl0IHJhd1Jlc3VsdC5qc29uKCk7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yPy5yZXNwb25zZT8uZGF0YSwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgdGhpcy5jaGFpbklkID8/PSBhd2FpdCB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jaGFpbklkXCIpO1xuICAgIHJldHVybiB0aGlzLmNoYWluSWQ7XG4gIH1cbiAgYXN5bmMgZ2V0U3BlY1ZlcnNpb24oKSB7XG4gICAgdGhpcy5zcGVjVmVyc2lvbiA/Pz0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3BlY1ZlcnNpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuc3BlY1ZlcnNpb247XG4gIH1cbiAgZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldE5vbmNlXCIsIHtcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIGhhc2ggYW5kIG51bWJlclxuICAgKi9cbiAgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tIYXNoQW5kTnVtYmVyXCIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIG51bWJlclxuICAgKiByZWR1bmRhbnQgdXNlIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKTtcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIHRoZSBsYXRlc3QgYmxvY2tcbiAgICovXG4gIGdldEJsb2NrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9ibG9ja051bWJlclwiKTtcbiAgfVxuICBnZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoVHhIYXNoZXNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1dpdGhUeHMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4c1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrV2l0aFJlY2VpcHRzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhSZWNlaXB0c1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrU3RhdGVVcGRhdGUoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFN0YXRlVXBkYXRlXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3RyYWNlQmxvY2tUcmFuc2FjdGlvbnNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudFwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLCB7XG4gICAgICB0cmFuc2FjdGlvbl9oYXNoXG4gICAgfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleChibG9ja0lkZW50aWZpZXIsIGluZGV4KSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4XCIsIHsgYmxvY2tfaWQsIGluZGV4IH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvblRyYWNlKHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZVRyYW5zYWN0aW9uXCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uU3RhdHVzXCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIGludm9jYXRpb25zIEFjY291bnRJbnZvY2F0aW9uc1xuICAgKiBAcGFyYW0gc2ltdWxhdGVUcmFuc2FjdGlvbk9wdGlvbnMgYmxvY2tJZGVudGlmaWVyIGFuZCBmbGFncyB0byBza2lwIHZhbGlkYXRpb24gYW5kIGZlZSBjaGFyZ2U8YnIvPlxuICAgKiAtIGJsb2NrSWRlbnRpZmllcjxici8+XG4gICAqIC0gc2tpcFZhbGlkYXRlIChkZWZhdWx0IGZhbHNlKTxici8+XG4gICAqIC0gc2tpcEZlZUNoYXJnZSAoZGVmYXVsdCB0cnVlKTxici8+XG4gICAqL1xuICBzaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCB7XG4gICAgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsXG4gICAgc2tpcFZhbGlkYXRlID0gdHJ1ZSxcbiAgICBza2lwRmVlQ2hhcmdlID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3Qgc2ltdWxhdGlvbkZsYWdzID0gW107XG4gICAgaWYgKHNraXBWYWxpZGF0ZSlcbiAgICAgIHNpbXVsYXRpb25GbGFncy5wdXNoKFJQQ1NQRUMwNy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9WQUxJREFURSk7XG4gICAgaWYgKHNraXBGZWVDaGFyZ2UpXG4gICAgICBzaW11bGF0aW9uRmxhZ3MucHVzaChSUENTUEVDMDcuRVNpbXVsYXRpb25GbGFnLlNLSVBfRkVFX0NIQVJHRSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NpbXVsYXRlVHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgdHJhbnNhY3Rpb25zOiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQpKSxcbiAgICAgIHNpbXVsYXRpb25fZmxhZ3M6IHNpbXVsYXRpb25GbGFnc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIGxldCB7IHJldHJpZXMgfSA9IHRoaXM7XG4gICAgbGV0IG9uY2hhaW4gPSBmYWxzZTtcbiAgICBsZXQgaXNFcnJvclN0YXRlID0gZmFsc2U7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IG9wdGlvbnM/LnJldHJ5SW50ZXJ2YWwgPz8gNWUzO1xuICAgIGNvbnN0IGVycm9yU3RhdGVzID0gb3B0aW9ucz8uZXJyb3JTdGF0ZXMgPz8gW1xuICAgICAgUlBDU1BFQzA3LkVUcmFuc2FjdGlvblN0YXR1cy5SRUpFQ1RFRFxuICAgICAgLy8gVE9ETzogY29tbWVudGVkIG91dCB0byBwcmVzZXJ2ZSB0aGUgbG9uZy1zdGFuZGluZyBiZWhhdmlvciBvZiBcInJldmVydGVkXCIgbm90IGJlaW5nIHRyZWF0ZWQgYXMgYW4gZXJyb3IgYnkgZGVmYXVsdFxuICAgICAgLy8gc2hvdWxkIGRlY2lkZSB3aGljaCBiZWhhdmlvciB0byBrZWVwIGluIHRoZSBmdXR1cmVcbiAgICAgIC8vIFJQQy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuUkVWRVJURUQsXG4gICAgXTtcbiAgICBjb25zdCBzdWNjZXNzU3RhdGVzID0gb3B0aW9ucz8uc3VjY2Vzc1N0YXRlcyA/PyBbXG4gICAgICBSUENTUEVDMDcuRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlNVQ0NFRURFRCxcbiAgICAgIFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDIsXG4gICAgICBSUENTUEVDMDcuRVRyYW5zYWN0aW9uU3RhdHVzLkFDQ0VQVEVEX09OX0wxXG4gICAgXTtcbiAgICBsZXQgdHhTdGF0dXM7XG4gICAgd2hpbGUgKCFvbmNoYWluKSB7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhTdGF0dXMgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvblN0YXR1cyA9IHR4U3RhdHVzLmV4ZWN1dGlvbl9zdGF0dXM7XG4gICAgICAgIGNvbnN0IGZpbmFsaXR5U3RhdHVzID0gdHhTdGF0dXMuZmluYWxpdHlfc3RhdHVzO1xuICAgICAgICBpZiAoIWZpbmFsaXR5U3RhdHVzKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJ3YWl0aW5nIGZvciB0cmFuc2FjdGlvbiBzdGF0dXNcIik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke2V4ZWN1dGlvblN0YXR1c306ICR7ZmluYWxpdHlTdGF0dXN9YDtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHR4U3RhdHVzO1xuICAgICAgICAgIGlzRXJyb3JTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgb25jaGFpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGlzRXJyb3JTdGF0ZSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgfVxuICAgIGxldCB0eFJlY2VpcHQgPSBudWxsO1xuICAgIHdoaWxlICh0eFJlY2VpcHQgPT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAocmV0cmllcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yVHJhbnNhY3Rpb24gdGltZWQtb3V0IHdpdGggcmV0cmllcyAke3RoaXMucmV0cmllc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmllcyAtPSAxO1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4UmVjZWlwdDtcbiAgfVxuICBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gdG9TdG9yYWdlS2V5KGtleSk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdG9yYWdlQXRcIiwge1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGtleTogcGFyc2VkS2V5LFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc0hhc2hBdFwiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3NcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzcyhjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY2xhc3NfaGFzaCA9IHRvSGV4KGNsYXNzSGFzaCk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc1wiLCB7XG4gICAgICBjbGFzc19oYXNoLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbnMsIHsgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IHRydWUgfSkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBsZXQgZmxhZ3MgPSB7fTtcbiAgICBpZiAoIWlzVmVyc2lvbihcIjAuNVwiLCBhd2FpdCB0aGlzLmdldFNwZWNWZXJzaW9uKCkpKSB7XG4gICAgICBmbGFncyA9IHtcbiAgICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2tpcFZhbGlkYXRlID8gW1JQQ1NQRUMwNy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9WQUxJREFURV0gOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlRmVlXCIsIHtcbiAgICAgIHJlcXVlc3Q6IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCwgXCJmZWVcIikpLFxuICAgICAgYmxvY2tfaWQsXG4gICAgICAuLi5mbGFnc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGludm9rZShmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpIHtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZEludm9rZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgaW52b2tlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGZ1bmN0aW9uSW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGZ1bmN0aW9uSW52b2NhdGlvbi5jYWxsZGF0YSksXG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGludm9rZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogZnVuY3Rpb25JbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgICB2ZXJzaW9uOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGRldGFpbHMuYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZSh7IGNvbnRyYWN0LCBzaWduYXR1cmUsIHNlbmRlckFkZHJlc3MsIGNvbXBpbGVkQ2xhc3NIYXNoIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSAmJiAhaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHByb2dyYW06IGNvbnRyYWN0LnByb2dyYW0sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNTaWVycmEoY29udHJhY3QpICYmICFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZWNsYXJlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2NsYXNzX3ZlcnNpb246IGNvbnRyYWN0LmNvbnRyYWN0X2NsYXNzX3ZlcnNpb24sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgICB2ZXJzaW9uOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMixcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgICB2ZXJzaW9uOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5zaWVycmFfcHJvZ3JhbSksXG4gICAgICAgICAgICBjb250cmFjdF9jbGFzc192ZXJzaW9uOiBjb250cmFjdC5jb250cmFjdF9jbGFzc192ZXJzaW9uLFxuICAgICAgICAgICAgZW50cnlfcG9pbnRzX2J5X3R5cGU6IGNvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLFxuICAgICAgICAgICAgYWJpOiBjb250cmFjdC5hYmlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGRldGFpbHMuYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcImRlY2xhcmUgdW5zcG90dGVkIHBhcmFtZXRlcnNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50KHsgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBhZGRyZXNzU2FsdCwgc2lnbmF0dXJlIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGNsYXNzSGFzaCksXG4gICAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChhZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICB2ZXJzaW9uOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFUExPWV9BQ0NPVU5ULFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgICBjbGFzc19oYXNoOiB0b0hleChjbGFzc0hhc2gpLFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgY2FsbENvbnRyYWN0KGNhbGwsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jYWxsXCIsIHtcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCksXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjYWxsLmNhbGxkYXRhKVxuICAgICAgfSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogRXN0aW1hdGUgdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gTDFcbiAgICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSBGcm9tIEwxXG4gICAqL1xuICBlc3RpbWF0ZU1lc3NhZ2VGZWUobWVzc2FnZSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCB7IGZyb21fYWRkcmVzcywgdG9fYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHtcbiAgICAgIGZyb21fYWRkcmVzczogdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3MoZnJvbV9hZGRyZXNzKSxcbiAgICAgIHRvX2FkZHJlc3M6IHRvSGV4KHRvX2FkZHJlc3MpLFxuICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yKGVudHJ5X3BvaW50X3NlbGVjdG9yKSxcbiAgICAgIHBheWxvYWQ6IGdldEhleFN0cmluZ0FycmF5KHBheWxvYWQpXG4gICAgfTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlTWVzc2FnZUZlZVwiLCB7XG4gICAgICBtZXNzYWdlOiBmb3JtYXR0ZWRNZXNzYWdlLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYWJvdXQgdGhlIHN5bmMgc3RhdHVzLCBvciBmYWxzZSBpZiB0aGUgbm9kZSBpcyBub3Qgc3luY2hpbmdcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHN0YXRzIGRhdGFcbiAgICovXG4gIGdldFN5bmNpbmdTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3luY2luZ1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGFuZCB0aGUgcGFnaW5hdGlvbiBvZiB0aGUgZXZlbnRzXG4gICAqL1xuICBnZXRFdmVudHMoZXZlbnRGaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0RXZlbnRzXCIsIHsgZmlsdGVyOiBldmVudEZpbHRlciB9KTtcbiAgfVxuICBidWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb24sIHZlcnNpb25UeXBlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb25zID0gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpO1xuICAgIGxldCBkZXRhaWxzO1xuICAgIGlmICghaXNWM1R4KGludm9jYXRpb24pKSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGludm9jYXRpb24ubWF4RmVlIHx8IDApXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIHJlc291cmNlX2JvdW5kczogaW52b2NhdGlvbi5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgdGlwOiB0b0hleChpbnZvY2F0aW9uLnRpcCksXG4gICAgICAgIHBheW1hc3Rlcl9kYXRhOiBpbnZvY2F0aW9uLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGludm9jYXRpb24uYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyB2MCB2MSB2M1xuICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYzKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgaWYgKCFpc1NpZXJyYShpbnZvY2F0aW9uLmNvbnRyYWN0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczogaW52b2NhdGlvbi5jb250cmFjdCxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5zZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIENhaXJvIDEgLSB2MiB2M1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgLi4uaW52b2NhdGlvbi5jb250cmFjdCxcbiAgICAgICAgICBzaWVycmFfcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oaW52b2NhdGlvbi5jb250cmFjdC5zaWVycmFfcHJvZ3JhbSlcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogaW52b2NhdGlvbi5jb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5zZW5kZXJBZGRyZXNzLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYzKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovKSB7XG4gICAgICBjb25zdCB7IGFjY291bnRfZGVwbG95bWVudF9kYXRhLCAuLi5yZXN0RGV0YWlscyB9ID0gZGV0YWlscztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGludm9jYXRpb24uY2xhc3NIYXNoKSxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChpbnZvY2F0aW9uLmFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYzKSxcbiAgICAgICAgLi4ucmVzdERldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwiUlBDIGJ1aWxkVHJhbnNhY3Rpb24gcmVjZWl2ZWQgdW5rbm93biBUcmFuc2FjdGlvblR5cGVcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9yZXNwb25zZVBhcnNlci9ycGMudHNcbnZhciBSUENSZXNwb25zZVBhcnNlciA9IGNsYXNzIHtcbiAgbWFyZ2luO1xuICBjb25zdHJ1Y3RvcihtYXJnaW4pIHtcbiAgICB0aGlzLm1hcmdpbiA9IG1hcmdpbjtcbiAgfVxuICBlc3RpbWF0ZWRGZWVUb01heEZlZShlc3RpbWF0ZWRGZWUpIHtcbiAgICByZXR1cm4gZXN0aW1hdGVkRmVlVG9NYXhGZWUoZXN0aW1hdGVkRmVlLCB0aGlzLm1hcmdpbj8ubWF4RmVlKTtcbiAgfVxuICBlc3RpbWF0ZUZlZVRvQm91bmRzKGVzdGltYXRlKSB7XG4gICAgcmV0dXJuIGVzdGltYXRlRmVlVG9Cb3VuZHMoXG4gICAgICBlc3RpbWF0ZSxcbiAgICAgIHRoaXMubWFyZ2luPy5sMUJvdW5kTWF4QW1vdW50LFxuICAgICAgdGhpcy5tYXJnaW4/LmwxQm91bmRNYXhQcmljZVBlclVuaXRcbiAgICApO1xuICB9XG4gIHBhcnNlR2V0QmxvY2tSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwiUEVORElOR1wiLCAuLi5yZXMgfTtcbiAgfVxuICBwYXJzZVRyYW5zYWN0aW9uUmVjZWlwdChyZXMpIHtcbiAgICBpZiAoXCJhY3R1YWxfZmVlXCIgaW4gcmVzICYmIGlzU3RyaW5nKHJlcy5hY3R1YWxfZmVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzLFxuICAgICAgICBhY3R1YWxfZmVlOiB7XG4gICAgICAgICAgYW1vdW50OiByZXMuYWN0dWFsX2ZlZSxcbiAgICAgICAgICB1bml0OiBcIkZSSVwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHJlcykge1xuICAgIGNvbnN0IHZhbCA9IHJlc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHZhbC5nYXNfY29uc3VtZWQpLFxuICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludCh2YWwuZ2FzX3ByaWNlKSxcbiAgICAgIHVuaXQ6IHZhbC51bml0LFxuICAgICAgc3VnZ2VzdGVkTWF4RmVlOiB0aGlzLmVzdGltYXRlZEZlZVRvTWF4RmVlKHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICByZXNvdXJjZUJvdW5kczogdGhpcy5lc3RpbWF0ZUZlZVRvQm91bmRzKHZhbCksXG4gICAgICBkYXRhX2dhc19jb25zdW1lZDogdmFsLmRhdGFfZ2FzX2NvbnN1bWVkID8gdG9CaWdJbnQodmFsLmRhdGFfZ2FzX2NvbnN1bWVkKSA6IDBuLFxuICAgICAgZGF0YV9nYXNfcHJpY2U6IHZhbC5kYXRhX2dhc19wcmljZSA/IHRvQmlnSW50KHZhbC5kYXRhX2dhc19wcmljZSkgOiAwblxuICAgIH07XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZUJ1bGtSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gcmVzLm1hcCgodmFsKSA9PiAoe1xuICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHZhbC5nYXNfY29uc3VtZWQpLFxuICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludCh2YWwuZ2FzX3ByaWNlKSxcbiAgICAgIHVuaXQ6IHZhbC51bml0LFxuICAgICAgc3VnZ2VzdGVkTWF4RmVlOiB0aGlzLmVzdGltYXRlZEZlZVRvTWF4RmVlKHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICByZXNvdXJjZUJvdW5kczogdGhpcy5lc3RpbWF0ZUZlZVRvQm91bmRzKHZhbCksXG4gICAgICBkYXRhX2dhc19jb25zdW1lZDogdmFsLmRhdGFfZ2FzX2NvbnN1bWVkID8gdG9CaWdJbnQodmFsLmRhdGFfZ2FzX2NvbnN1bWVkKSA6IDBuLFxuICAgICAgZGF0YV9nYXNfcHJpY2U6IHZhbC5kYXRhX2dhc19wcmljZSA/IHRvQmlnSW50KHZhbC5kYXRhX2dhc19wcmljZSkgOiAwblxuICAgIH0pKTtcbiAgfVxuICBwYXJzZVNpbXVsYXRlVHJhbnNhY3Rpb25SZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gcmVzLm1hcCgoaXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLml0LFxuICAgICAgICBzdWdnZXN0ZWRNYXhGZWU6IHRoaXMuZXN0aW1hdGVkRmVlVG9NYXhGZWUoaXQuZmVlX2VzdGltYXRpb24ub3ZlcmFsbF9mZWUpLFxuICAgICAgICByZXNvdXJjZUJvdW5kczogdGhpcy5lc3RpbWF0ZUZlZVRvQm91bmRzKGl0LmZlZV9lc3RpbWF0aW9uKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBwYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzLFxuICAgICAgYWJpOiBpc1N0cmluZyhyZXMuYWJpKSA/IEpTT04ucGFyc2UocmVzLmFiaSkgOiByZXMuYWJpXG4gICAgfTtcbiAgfVxuICBwYXJzZUwxR2FzUHJpY2VSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gcmVzLmwxX2dhc19wcmljZS5wcmljZV9pbl93ZWk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy90cmFuc2FjdGlvblJlY2VpcHQudHNcbnZhciBSZWNlaXB0VHggPSBjbGFzcyBfUmVjZWlwdFR4IHtcbiAgc3RhdHVzUmVjZWlwdDtcbiAgdmFsdWU7XG4gIGNvbnN0cnVjdG9yKHJlY2VpcHQpIHtcbiAgICBbdGhpcy5zdGF0dXNSZWNlaXB0LCB0aGlzLnZhbHVlXSA9IF9SZWNlaXB0VHguaXNTdWNjZXNzKHJlY2VpcHQpID8gW1wic3VjY2Vzc1wiLCByZWNlaXB0XSA6IF9SZWNlaXB0VHguaXNSZXZlcnRlZChyZWNlaXB0KSA/IFtcInJldmVydGVkXCIsIHJlY2VpcHRdIDogX1JlY2VpcHRUeC5pc1JlamVjdGVkKHJlY2VpcHQpID8gW1wicmVqZWN0ZWRcIiwgcmVjZWlwdF0gOiBbXCJlcnJvclwiLCBuZXcgRXJyb3IoXCJVbmtub3duIHJlc3BvbnNlIHR5cGVcIildO1xuICAgIGZvciAoY29uc3QgW2tleV0gb2YgT2JqZWN0LmVudHJpZXModGhpcykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZWNlaXB0KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgbWF0Y2goY2FsbGJhY2tzKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzUmVjZWlwdCBpbiBjYWxsYmFja3MpIHtcbiAgICAgIHJldHVybiBjYWxsYmFja3NbdGhpcy5zdGF0dXNSZWNlaXB0XSh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrcy5fKCk7XG4gIH1cbiAgaXNTdWNjZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1c1JlY2VpcHQgPT09IFwic3VjY2Vzc1wiO1xuICB9XG4gIGlzUmV2ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzUmVjZWlwdCA9PT0gXCJyZXZlcnRlZFwiO1xuICB9XG4gIGlzUmVqZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzUmVjZWlwdCA9PT0gXCJyZWplY3RlZFwiO1xuICB9XG4gIGlzRXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzUmVjZWlwdCA9PT0gXCJlcnJvclwiO1xuICB9XG4gIHN0YXRpYyBpc1N1Y2Nlc3ModHJhbnNhY3Rpb25SZWNlaXB0KSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uUmVjZWlwdC5leGVjdXRpb25fc3RhdHVzID09PSBcIlNVQ0NFRURFRFwiIC8qIFNVQ0NFRURFRCAqLztcbiAgfVxuICBzdGF0aWMgaXNSZXZlcnRlZCh0cmFuc2FjdGlvblJlY2VpcHQpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25SZWNlaXB0LmV4ZWN1dGlvbl9zdGF0dXMgPT09IFwiUkVWRVJURURcIiAvKiBSRVZFUlRFRCAqLztcbiAgfVxuICBzdGF0aWMgaXNSZWplY3RlZCh0cmFuc2FjdGlvblJlY2VpcHQpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25SZWNlaXB0LnN0YXR1cyA9PT0gXCJSRUpFQ1RFRFwiIC8qIFJFSkVDVEVEICovO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvcnBjLnRzXG52YXIgUnBjUHJvdmlkZXIgPSBjbGFzcyB7XG4gIHJlc3BvbnNlUGFyc2VyO1xuICBjaGFubmVsO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zT3JQcm92aWRlcikge1xuICAgIGlmIChvcHRpb25zT3JQcm92aWRlciAmJiBcImNoYW5uZWxcIiBpbiBvcHRpb25zT3JQcm92aWRlcikge1xuICAgICAgdGhpcy5jaGFubmVsID0gb3B0aW9uc09yUHJvdmlkZXIuY2hhbm5lbDtcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIgPSBvcHRpb25zT3JQcm92aWRlci5yZXNwb25zZVBhcnNlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFubmVsID0gbmV3IFJwY0NoYW5uZWwyKHsgLi4ub3B0aW9uc09yUHJvdmlkZXIsIHdhaXRNb2RlOiBmYWxzZSB9KTtcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIgPSBuZXcgUlBDUmVzcG9uc2VQYXJzZXIob3B0aW9uc09yUHJvdmlkZXI/LmZlZU1hcmdpblBlcmNlbnRhZ2UpO1xuICAgIH1cbiAgfVxuICBmZXRjaChtZXRob2QsIHBhcmFtcywgaWQgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5mZXRjaChtZXRob2QsIHBhcmFtcywgaWQpO1xuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRDaGFpbklkKCk7XG4gIH1cbiAgYXN5bmMgZ2V0U3BlY1ZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRTcGVjVmVyc2lvbigpO1xuICB9XG4gIGFzeW5jIGdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcikudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0QmxvY2tSZXNwb25zZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgaGFzaCBhbmQgbnVtYmVyXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIG51bWJlclxuICAgKiByZWR1bmRhbnQgdXNlIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKTtcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIHRoZSBsYXRlc3QgYmxvY2tcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0TDFHYXNQcmljZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcikudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlTDFHYXNQcmljZVJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1dpdGhSZWNlaXB0cyhibG9ja0lkZW50aWZpZXIpIHtcbiAgICBpZiAodGhpcy5jaGFubmVsIGluc3RhbmNlb2YgcnBjXzBfNl9leHBvcnRzLlJwY0NoYW5uZWwpXG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKFwiVW5zdXBwb3J0ZWQgbWV0aG9kIGZvciBSUEMgdmVyc2lvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFJlY2VpcHRzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgZ2V0U3RhdGVVcGRhdGUgPSB0aGlzLmdldEJsb2NrU3RhdGVVcGRhdGU7XG4gIGFzeW5jIGdldEJsb2NrU3RhdGVVcGRhdGUoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJhbnNhY3Rpb25zIGZyb20gcGVuZGluZyBibG9ja1xuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkIHVzZSBnZXRCbG9jayhCbG9ja1RhZy5wZW5kaW5nKTsgKHdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IG1pbm9yIHZlcnNpb24pXG4gICAqIFV0aWxpdHkgbWV0aG9kLCBzYW1lIHJlc3VsdCBjYW4gYmUgYWNoaWV2ZWQgdXNpbmcgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoQmxvY2tUYWcucGVuZGluZyk7XG4gICAqL1xuICBhc3luYyBnZXRQZW5kaW5nVHJhbnNhY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBhd2FpdCB0aGlzLmdldEJsb2NrV2l0aFR4SGFzaGVzKFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0QmxvY2tSZXNwb25zZVxuICAgICk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmdldFRyYW5zYWN0aW9uQnlIYXNoKGl0KSkpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleChibG9ja0lkZW50aWZpZXIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4KGJsb2NrSWRlbnRpZmllciwgaW5kZXgpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBjb25zdCB0eFJlY2VpcHRXb0hlbHBlciA9IGF3YWl0IHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICBjb25zdCB0eFJlY2VpcHRXb0hlbHBlck1vZGlmaWVkID0gdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZVRyYW5zYWN0aW9uUmVjZWlwdCh0eFJlY2VpcHRXb0hlbHBlcik7XG4gICAgcmV0dXJuIG5ldyBSZWNlaXB0VHgodHhSZWNlaXB0V29IZWxwZXJNb2RpZmllZCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uVHJhY2UodHhIYXNoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gaW52b2NhdGlvbnMgQWNjb3VudEludm9jYXRpb25zXG4gICAqIEBwYXJhbSBzaW11bGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyBibG9ja0lkZW50aWZpZXIgYW5kIGZsYWdzIHRvIHNraXAgdmFsaWRhdGlvbiBhbmQgZmVlIGNoYXJnZTxici8+XG4gICAqIC0gYmxvY2tJZGVudGlmaWVyPGJyLz5cbiAgICogLSBza2lwVmFsaWRhdGUgKGRlZmF1bHQgZmFsc2UpPGJyLz5cbiAgICogLSBza2lwRmVlQ2hhcmdlIChkZWZhdWx0IHRydWUpPGJyLz5cbiAgICovXG4gIGFzeW5jIGdldFNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLnNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIG9wdGlvbnMpLnRoZW4oKHIpID0+IHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UocikpO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWNlaXB0V29IZWxwZXIgPSBhd2FpdCB0aGlzLmNoYW5uZWwud2FpdEZvclRyYW5zYWN0aW9uKFxuICAgICAgdHhIYXNoLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcmV0dXJuIG5ldyBSZWNlaXB0VHgocmVjZWlwdFdvSGVscGVyKTtcbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NCeUhhc2goY2xhc3NIYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2xhc3MoY2xhc3NIYXNoKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzcyhjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDb250cmFjdFZlcnNpb24oY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIHtcbiAgICBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmNoYW5uZWwuYmxvY2tJZGVudGlmaWVyLFxuICAgIGNvbXBpbGVyID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICBsZXQgY29udHJhY3RDbGFzcztcbiAgICBpZiAoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICBjb250cmFjdENsYXNzID0gYXdhaXQgdGhpcy5nZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzSGFzaCkge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcImdldENvbnRyYWN0VmVyc2lvbiByZXF1aXJlIGNvbnRyYWN0QWRkcmVzcyBvciBjbGFzc0hhc2hcIik7XG4gICAgfVxuICAgIGlmIChpc1NpZXJyYShjb250cmFjdENsYXNzKSkge1xuICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgIGNvbnN0IGFiaVRlc3QgPSBnZXRBYmlDb250cmFjdFZlcnNpb24oY29udHJhY3RDbGFzcy5hYmkpO1xuICAgICAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBhYmlUZXN0LmNvbXBpbGVyIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiB2b2lkIDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMFwiLCBjb21waWxlcjogXCIwXCIgfTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGdldCp0eXBlKkVzdGltYXRlRmVlICh3aWxsIGJlIHJlZmFjdG9yZWQgYmFzZWQgb24gdHlwZSBhZnRlciBzZXF1ZW5jZXIgZGVwcmVjYXRpb24pXG4gICAqL1xuICBhc3luYyBnZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpO1xuICB9XG4gIGFzeW5jIGdldEludm9rZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0RXN0aW1hdGVGZWUoXG4gICAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLyxcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAgIC4uLmludm9jYXRpb25EZXRhaWxzXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH1cbiAgICApLnRoZW4oKHIpID0+IHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyBnZXREZWNsYXJlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLyxcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfVxuICAgICkudGhlbigocikgPT4gdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UocikpO1xuICB9XG4gIGFzeW5jIGdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBkZXRhaWxzLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0RXN0aW1hdGVGZWUoXG4gICAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH1cbiAgICApLnRoZW4oKHIpID0+IHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyBnZXRFc3RpbWF0ZUZlZUJ1bGsoaW52b2NhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKGludm9jYXRpb25zLCBvcHRpb25zKS50aGVuKChyKSA9PiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UocikpO1xuICB9XG4gIGFzeW5jIGludm9rZUZ1bmN0aW9uKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuaW52b2tlKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZUNvbnRyYWN0KHRyYW5zYWN0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5kZWNsYXJlKHRyYW5zYWN0aW9uLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50Q29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmRlcGxveUFjY291bnQoXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIGRldGFpbHNcbiAgICApO1xuICB9XG4gIGFzeW5jIGNhbGxDb250cmFjdChjYWxsLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmNhbGxDb250cmFjdChjYWxsLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIC8qKlxuICAgKiBORVc6IEVzdGltYXRlIHRoZSBmZWUgZm9yIGEgbWVzc2FnZSBmcm9tIEwxXG4gICAqIEBwYXJhbSBtZXNzYWdlIE1lc3NhZ2UgRnJvbSBMMVxuICAgKi9cbiAgYXN5bmMgZXN0aW1hdGVNZXNzYWdlRmVlKG1lc3NhZ2UsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZXN0aW1hdGVNZXNzYWdlRmVlKG1lc3NhZ2UsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGFib3V0IHRoZSBzeW5jIHN0YXR1cywgb3IgZmFsc2UgaWYgdGhlIG5vZGUgaXMgbm90IHN5bmNoaW5nXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHRoZSBzdGF0cyBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRTeW5jaW5nU3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRTeW5jaW5nU3RhdHMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGFuZCB0aGUgcGFnaW5hdGlvbiBvZiB0aGUgZXZlbnRzXG4gICAqL1xuICBhc3luYyBnZXRFdmVudHMoZXZlbnRGaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEV2ZW50cyhldmVudEZpbHRlcik7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9leHRlbnNpb25zL2RlZmF1bHQudHNcbmltcG9ydCB7IE1peGluIH0gZnJvbSBcInRzLW1peGVyXCI7XG5cbi8vIHNyYy91dGlscy9zdGFya25ldElkLnRzXG52YXIgc3RhcmtuZXRJZF9leHBvcnRzID0ge307XG5fX2V4cG9ydChzdGFya25ldElkX2V4cG9ydHMsIHtcbiAgU3RhcmtuZXRJZENvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkQ29udHJhY3QsXG4gIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdCxcbiAgU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QsXG4gIFN0YXJrbmV0SWRQZnBDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZFBmcENvbnRyYWN0LFxuICBTdGFya25ldElkUG9wQ29udHJhY3Q6ICgpID0+IFN0YXJrbmV0SWRQb3BDb250cmFjdCxcbiAgU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3Q6ICgpID0+IFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0LFxuICBkeW5hbWljQ2FsbERhdGE6ICgpID0+IGR5bmFtaWNDYWxsRGF0YSxcbiAgZHluYW1pY0ZlbHQ6ICgpID0+IGR5bmFtaWNGZWx0LFxuICBleGVjdXRpb246ICgpID0+IGV4ZWN1dGlvbixcbiAgZ2V0U3RhcmtuZXRJZENvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkQ29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdCxcbiAgZ2V0U3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRQZnBDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZFBmcENvbnRyYWN0LFxuICBnZXRTdGFya25ldElkUG9wQ29udHJhY3Q6ICgpID0+IGdldFN0YXJrbmV0SWRQb3BDb250cmFjdCxcbiAgZ2V0U3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3Q6ICgpID0+IGdldFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0LFxuICB1c2VEZWNvZGVkOiAoKSA9PiB1c2VEZWNvZGVkLFxuICB1c2VFbmNvZGVkOiAoKSA9PiB1c2VFbmNvZGVkXG59KTtcbnZhciBiYXNpY0FscGhhYmV0ID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXCI7XG52YXIgYmFzaWNTaXplUGx1c09uZSA9IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCArIDEpO1xudmFyIGJpZ0FscGhhYmV0ID0gXCJcXHU4RkQ5XFx1Njc2NVwiO1xudmFyIGJhc2ljQWxwaGFiZXRTaXplID0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoKTtcbnZhciBiaWdBbHBoYWJldFNpemUgPSBCaWdJbnQoYmlnQWxwaGFiZXQubGVuZ3RoKTtcbnZhciBiaWdBbHBoYWJldFNpemVQbHVzT25lID0gQmlnSW50KGJpZ0FscGhhYmV0Lmxlbmd0aCArIDEpO1xuZnVuY3Rpb24gZXh0cmFjdFN0YXJzKHN0cikge1xuICBsZXQgayA9IDA7XG4gIHdoaWxlIChzdHIuZW5kc1dpdGgoYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0pKSB7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgayArPSAxO1xuICB9XG4gIHJldHVybiBbc3RyLCBrXTtcbn1cbmZ1bmN0aW9uIHVzZURlY29kZWQoZW5jb2RlZCkge1xuICBsZXQgZGVjb2RlZCA9IFwiXCI7XG4gIGVuY29kZWQuZm9yRWFjaCgoc3ViZG9tYWluKSA9PiB7XG4gICAgd2hpbGUgKHN1YmRvbWFpbiAhPT0gWkVSTykge1xuICAgICAgY29uc3QgY29kZSA9IHN1YmRvbWFpbiAlIGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBzdWJkb21haW4gLz0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIGlmIChjb2RlID09PSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IG5leHRTdWJkb21haW4gPSBzdWJkb21haW4gLyBiaWdBbHBoYWJldFNpemVQbHVzT25lO1xuICAgICAgICBpZiAobmV4dFN1YmRvbWFpbiA9PT0gWkVSTykge1xuICAgICAgICAgIGNvbnN0IGNvZGUyID0gc3ViZG9tYWluICUgYmlnQWxwaGFiZXRTaXplUGx1c09uZTtcbiAgICAgICAgICBzdWJkb21haW4gPSBuZXh0U3ViZG9tYWluO1xuICAgICAgICAgIGlmIChjb2RlMiA9PT0gWkVSTylcbiAgICAgICAgICAgIGRlY29kZWQgKz0gYmFzaWNBbHBoYWJldFswXTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWNvZGVkICs9IGJpZ0FscGhhYmV0W051bWJlcihjb2RlMikgLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjb2RlMiA9IHN1YmRvbWFpbiAlIGJpZ0FscGhhYmV0U2l6ZTtcbiAgICAgICAgICBkZWNvZGVkICs9IGJpZ0FscGhhYmV0W051bWJlcihjb2RlMildO1xuICAgICAgICAgIHN1YmRvbWFpbiAvPSBiaWdBbHBoYWJldFNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBkZWNvZGVkICs9IGJhc2ljQWxwaGFiZXRbTnVtYmVyKGNvZGUpXTtcbiAgICB9XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZCk7XG4gICAgaWYgKGspXG4gICAgICBkZWNvZGVkID0gc3RyICsgKGsgJSAyID09PSAwID8gYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KGsgLyAyIC0gMSkgKyBiaWdBbHBoYWJldFswXSArIGJhc2ljQWxwaGFiZXRbMV0gOiBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoKGsgLSAxKSAvIDIgKyAxKSk7XG4gICAgZGVjb2RlZCArPSBcIi5cIjtcbiAgfSk7XG4gIGlmICghZGVjb2RlZCkge1xuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG4gIHJldHVybiBkZWNvZGVkLmNvbmNhdChcInN0YXJrXCIpO1xufVxuZnVuY3Rpb24gdXNlRW5jb2RlZChkZWNvZGVkKSB7XG4gIGxldCBlbmNvZGVkID0gQmlnSW50KDApO1xuICBsZXQgbXVsdGlwbGllciA9IEJpZ0ludCgxKTtcbiAgaWYgKGRlY29kZWQuZW5kc1dpdGgoYmlnQWxwaGFiZXRbMF0gKyBiYXNpY0FscGhhYmV0WzFdKSkge1xuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQuc3Vic3RyaW5nKDAsIGRlY29kZWQubGVuZ3RoIC0gMikpO1xuICAgIGRlY29kZWQgPSBzdHIgKyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoMiAqIChrICsgMSkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQpO1xuICAgIGlmIChrKVxuICAgICAgZGVjb2RlZCA9IHN0ciArIGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdCgxICsgMiAqIChrIC0gMSkpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBkZWNvZGVkW2ldO1xuICAgIGNvbnN0IGluZGV4ID0gYmFzaWNBbHBoYWJldC5pbmRleE9mKGNoYXIpO1xuICAgIGNvbnN0IGJuSW5kZXggPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5pbmRleE9mKGNoYXIpKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoaSA9PT0gZGVjb2RlZC5sZW5ndGggLSAxICYmIGRlY29kZWRbaV0gPT09IGJhc2ljQWxwaGFiZXRbMF0pIHtcbiAgICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYmFzaWNBbHBoYWJldFNpemU7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYm5JbmRleDtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYmlnQWxwaGFiZXQuaW5kZXhPZihjaGFyKSAhPT0gLTEpIHtcbiAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJhc2ljQWxwaGFiZXRTaXplO1xuICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgY29uc3QgbmV3aWQgPSAoaSA9PT0gZGVjb2RlZC5sZW5ndGggLSAxID8gMSA6IDApICsgYmlnQWxwaGFiZXQuaW5kZXhPZihjaGFyKTtcbiAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIEJpZ0ludChuZXdpZCk7XG4gICAgICBtdWx0aXBsaWVyICo9IGJpZ0FscGhhYmV0U2l6ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG52YXIgU3RhcmtuZXRJZENvbnRyYWN0ID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRJZENvbnRyYWN0MikgPT4ge1xuICBTdGFya25ldElkQ29udHJhY3QyW1wiTUFJTk5FVFwiXSA9IFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIjtcbiAgU3RhcmtuZXRJZENvbnRyYWN0MltcIlRFU1RORVRcIl0gPSBcIjB4M2JhYjI2OGU5MzJkMmNlY2QxOTQ2ZjEwMGFlNjdjZTNkZmY5ZmQyMzQxMTllYTJmNmRhNTdkMTZkMjlmY2VcIjtcbiAgU3RhcmtuZXRJZENvbnRyYWN0MltcIlRFU1RORVRfU0VQT0xJQVwiXSA9IFwiMHgwNzA3ZjA5YmM1NzZiZDdjZmVlNTk2OTQ4NDYyOTEwNDdlOTY1ZjQxODRmZTEzZGFjNjJjNTY3NTliM2I2ZmE3XCI7XG4gIHJldHVybiBTdGFya25ldElkQ29udHJhY3QyO1xufSkoU3RhcmtuZXRJZENvbnRyYWN0IHx8IHt9KTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4NmFjNTk3ZjgxMTZmODg2ZmExYzk3YTIzZmE0ZTA4Mjk5OTc1ZWNhZjZiNTk4ODczY2E2NzkyYjliYmZiNjc4XCIgLyogTUFJTk5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi86XG4gICAgICByZXR1cm4gXCIweDNiYWIyNjhlOTMyZDJjZWNkMTk0NmYxMDBhZTY3Y2UzZGZmOWZkMjM0MTE5ZWEyZjZkYTU3ZDE2ZDI5ZmNlXCIgLyogVEVTVE5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiIC8qIFNOX1NFUE9MSUEgKi86XG4gICAgICByZXR1cm4gXCIweDA3MDdmMDliYzU3NmJkN2NmZWU1OTY5NDg0NjI5MTA0N2U5NjVmNDE4NGZlMTNkYWM2MmM1Njc1OWIzYjZmYTdcIiAvKiBURVNUTkVUX1NFUE9MSUEgKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJrbmV0LmlkIGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCIpO1xuICB9XG59XG52YXIgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDIpID0+IHtcbiAgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyW1wiTUFJTk5FVFwiXSA9IFwiMHgwNWRiZGVkYzIwM2U5Mjc0OWUyZTc0NmUyZDQwYTc2OGQ5NjZiZDI0M2RmMDRhNmI3MTJlMjIyYmMwNDBhOWFmXCI7XG4gIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0MltcIlRFU1RORVRcIl0gPSBcIjB4NzgzYTkwOTdiMjZlYWUwNTg2MzczYjJjZTBlZDM1MjlkZGM0NDA2OWQxZTBmYmM0ZjY2ZDQyYjY5ZDY4NTBkXCI7XG4gIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0MltcIlRFU1RORVRfU0VQT0xJQVwiXSA9IFwiMHgwNzBERjhCNEY1Y2IyODc5Zjg1OTI4NDlmQThmMzEzNGRhMzlkMjUzMjZCODU1OGNjOUM4RkU4RDQ3RUEzQTkwXCI7XG4gIHJldHVybiBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDI7XG59KShTdGFya25ldElkSWRlbnRpdHlDb250cmFjdCB8fCB7fSk7XG5mdW5jdGlvbiBnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4MDVkYmRlZGMyMDNlOTI3NDllMmU3NDZlMmQ0MGE3NjhkOTY2YmQyNDNkZjA0YTZiNzEyZTIyMmJjMDQwYTlhZlwiIC8qIE1BSU5ORVQgKi87XG4gICAgY2FzZSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCIgLyogU05fR09FUkxJICovOlxuICAgICAgcmV0dXJuIFwiMHg3ODNhOTA5N2IyNmVhZTA1ODYzNzNiMmNlMGVkMzUyOWRkYzQ0MDY5ZDFlMGZiYzRmNjZkNDJiNjlkNjg1MGRcIiAvKiBURVNUTkVUICovO1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBcIjB4MDcwREY4QjRGNWNiMjg3OWY4NTkyODQ5ZkE4ZjMxMzRkYTM5ZDI1MzI2Qjg1NThjYzlDOEZFOEQ0N0VBM0E5MFwiIC8qIFRFU1RORVRfU0VQT0xJQSAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhcmtuZXQuaWQgdmVyaWZpZXIgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIik7XG4gIH1cbn1cbnZhciBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QgPSBcIjB4MDM0ZmZiOGY0NDUyZGY3YTYxM2EwMjEwODI0ZDY0MTRkYmFkY2RkY2U2YzZlMTliZjRkZGM5ZTIyY2U1Zjk3MFwiO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDtcbiAgICBjYXNlIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi86XG4gICAgICByZXR1cm4gU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0O1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJrbmV0LmlkIG11bHRpY2FsbCBjb250cmFjdCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0ID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyKSA9PiB7XG4gIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4MDdkMTRkZmQ4ZWU5NWI0MWZjZTE3OTE3MGQ4OGJhMWYwZDVhNTEyZTEzYWViMjMyZjE5Y2ZlZWMwYTg4ZjhiZlwiO1xuICBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDJbXCJURVNUTkVUXCJdID0gXCIweDA1N2M5NDI1NDQwNjNjM2FlYTZlYTZjMzcwMDljYzlkMWJlYWNkNzUwY2I2ODAxNTQ5YTEyOWM3MjY1ZjBmMTFcIjtcbiAgU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyW1wiVEVTVE5FVF9TRVBPTElBXCJdID0gXCIweDAxODJFY0U4MTczQzIxNkEzOTVmNDgyOGUxNTIzNTQxYjdlMzYwMGJmMTkwQ0IyNTJFMWExQTBjRTIxOWQxODRcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0Mjtcbn0pKFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0IHx8IHt9KTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHgwN2QxNGRmZDhlZTk1YjQxZmNlMTc5MTcwZDg4YmExZjBkNWE1MTJlMTNhZWIyMzJmMTljZmVlYzBhODhmOGJmXCIgLyogTUFJTk5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi86XG4gICAgICByZXR1cm4gXCIweDA1N2M5NDI1NDQwNjNjM2FlYTZlYTZjMzcwMDljYzlkMWJlYWNkNzUwY2I2ODAxNTQ5YTEyOWM3MjY1ZjBmMTFcIiAvKiBURVNUTkVUICovO1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBcIjB4MDE4MkVjRTgxNzNDMjE2QTM5NWY0ODI4ZTE1MjM1NDFiN2UzNjAwYmYxOTBDQjI1MkUxYTFBMGNFMjE5ZDE4NFwiIC8qIFRFU1RORVRfU0VQT0xJQSAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhcmtuZXQuaWQgdmVyaWZpZXIgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIik7XG4gIH1cbn1cbnZhciBTdGFya25ldElkUGZwQ29udHJhY3QgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldElkUGZwQ29udHJhY3QyKSA9PiB7XG4gIFN0YXJrbmV0SWRQZnBDb250cmFjdDJbXCJNQUlOTkVUXCJdID0gXCIweDA3MGFhYTIwZWM0YTQ2ZGE1N2M5MzJkOWZkODljYTVlNmJiOWNhMzE4OGQzZGYzNjFhMzIzMDZhZmY3ZDU5YzdcIjtcbiAgU3RhcmtuZXRJZFBmcENvbnRyYWN0MltcIlRFU1RORVRcIl0gPSBcIjB4MDNjYWMzMjI4YjQzNDI1OTczNGVlMGU0ZmY0NDVmNjQyMjA2ZWExMWFkYWNlN2U0ZjQ1ZWRkMjU5Njc0ODY5OFwiO1xuICBTdGFya25ldElkUGZwQ29udHJhY3QyW1wiVEVTVE5FVF9TRVBPTElBXCJdID0gXCIweDA1ODA2MWJiNmJkYzUwMWVFMjE1MTcyYzlmODdkNTU3QzFFMGY0NjZkQzQ5OGNBODFiMThmOTk4QmYxMzYyYjJcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRQZnBDb250cmFjdDI7XG59KShTdGFya25ldElkUGZwQ29udHJhY3QgfHwge30pO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZFBmcENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHgwNzBhYWEyMGVjNGE0NmRhNTdjOTMyZDlmZDg5Y2E1ZTZiYjljYTMxODhkM2RmMzYxYTMyMzA2YWZmN2Q1OWM3XCIgLyogTUFJTk5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi86XG4gICAgICByZXR1cm4gXCIweDAzY2FjMzIyOGI0MzQyNTk3MzRlZTBlNGZmNDQ1ZjY0MjIwNmVhMTFhZGFjZTdlNGY0NWVkZDI1OTY3NDg2OThcIiAvKiBURVNUTkVUICovO1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBcIjB4MDU4MDYxYmI2YmRjNTAxZUUyMTUxNzJjOWY4N2Q1NTdDMUUwZjQ2NmRDNDk4Y0E4MWIxOGY5OThCZjEzNjJiMlwiIC8qIFRFU1RORVRfU0VQT0xJQSAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlN0YXJrbmV0LmlkIHByb2ZpbGUgcGljdHVyZSB2ZXJpZmllciBjb250cmFjdCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiXG4gICAgICApO1xuICB9XG59XG52YXIgU3RhcmtuZXRJZFBvcENvbnRyYWN0ID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRJZFBvcENvbnRyYWN0MikgPT4ge1xuICBTdGFya25ldElkUG9wQ29udHJhY3QyW1wiTUFJTk5FVFwiXSA9IFwiMHgwMjkzZWIyYmE5ODYyZjc2MmJkMzAzNjU4NmQ1NzU1YTc4MmJkMjJlNmY1MDI4MzIwZjFkMDQwNWZkNDdiZmY0XCI7XG4gIFN0YXJrbmV0SWRQb3BDb250cmFjdDJbXCJURVNUTkVUXCJdID0gXCIweDAzNTI4Y2FmMDkwMTc5ZTMzNzkzMWVlNjY5YTViMDIxNDA0MWUxYmFlMzBkNDYwZmYwN2QyY2VhMmM3YTkxMDZcIjtcbiAgU3RhcmtuZXRJZFBvcENvbnRyYWN0MltcIlRFU1RORVRfU0VQT0xJQVwiXSA9IFwiMHgwMDIzRkUzYjg0NWVkNTY2NWE5ZWIzNzkyYmJCMTczNDdCNDkwRUU0MDkwZjg1NUMxMjk4ZDAzQkI1RjQ5QjQ5XCI7XG4gIHJldHVybiBTdGFya25ldElkUG9wQ29udHJhY3QyO1xufSkoU3RhcmtuZXRJZFBvcENvbnRyYWN0IHx8IHt9KTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRQb3BDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4MDI5M2ViMmJhOTg2MmY3NjJiZDMwMzY1ODZkNTc1NWE3ODJiZDIyZTZmNTAyODMyMGYxZDA0MDVmZDQ3YmZmNFwiIC8qIE1BSU5ORVQgKi87XG4gICAgY2FzZSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCIgLyogU05fR09FUkxJICovOlxuICAgICAgcmV0dXJuIFwiMHgwMzUyOGNhZjA5MDE3OWUzMzc5MzFlZTY2OWE1YjAyMTQwNDFlMWJhZTMwZDQ2MGZmMDdkMmNlYTJjN2E5MTA2XCIgLyogVEVTVE5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiIC8qIFNOX1NFUE9MSUEgKi86XG4gICAgICByZXR1cm4gXCIweDAwMjNGRTNiODQ1ZWQ1NjY1YTllYjM3OTJiYkIxNzM0N0I0OTBFRTQwOTBmODU1QzEyOThkMDNCQjVGNDlCNDlcIiAvKiBURVNUTkVUX1NFUE9MSUEgKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJTdGFya25ldC5pZCBwcm9vZiBvZiBwZXJzb25ob29kIHZlcmlmaWVyIGNvbnRyYWN0IGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCJcbiAgICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4ZWN1dGlvbihzdGF0aWNFeCwgaWZFcXVhbCA9IHZvaWQgMCwgaWZOb3RFcXVhbCA9IHZvaWQgMCkge1xuICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bSh7XG4gICAgU3RhdGljOiBzdGF0aWNFeCxcbiAgICBJZkVxdWFsOiBpZkVxdWFsID8gdHVwbGUoaWZFcXVhbFswXSwgaWZFcXVhbFsxXSwgaWZFcXVhbFsyXSkgOiB2b2lkIDAsXG4gICAgSWZOb3RFcXVhbDogaWZOb3RFcXVhbCA/IHR1cGxlKGlmTm90RXF1YWxbMF0sIGlmTm90RXF1YWxbMV0sIGlmTm90RXF1YWxbMl0pIDogdm9pZCAwXG4gIH0pO1xufVxuZnVuY3Rpb24gZHluYW1pY0ZlbHQoaGFyZGNvZGVkLCByZWZlcmVuY2UgPSB2b2lkIDApIHtcbiAgcmV0dXJuIG5ldyBDYWlyb0N1c3RvbUVudW0oe1xuICAgIEhhcmRjb2RlZDogaGFyZGNvZGVkLFxuICAgIFJlZmVyZW5jZTogcmVmZXJlbmNlID8gdHVwbGUocmVmZXJlbmNlWzBdLCByZWZlcmVuY2VbMV0pIDogdm9pZCAwXG4gIH0pO1xufVxuZnVuY3Rpb24gZHluYW1pY0NhbGxEYXRhKGhhcmRjb2RlZCwgcmVmZXJlbmNlID0gdm9pZCAwLCBhcnJheVJlZmVyZW5jZSA9IHZvaWQgMCkge1xuICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bSh7XG4gICAgSGFyZGNvZGVkOiBoYXJkY29kZWQsXG4gICAgUmVmZXJlbmNlOiByZWZlcmVuY2UgPyB0dXBsZShyZWZlcmVuY2VbMF0sIHJlZmVyZW5jZVsxXSkgOiB2b2lkIDAsXG4gICAgQXJyYXlSZWZlcmVuY2U6IGFycmF5UmVmZXJlbmNlID8gdHVwbGUoYXJyYXlSZWZlcmVuY2VbMF0sIGFycmF5UmVmZXJlbmNlWzFdKSA6IHZvaWQgMFxuICB9KTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVyL2V4dGVuc2lvbnMvc3RhcmtuZXRJZC50c1xudmFyIFN0YXJrbmV0SWQgPSBjbGFzcyBfU3RhcmtuZXRJZCB7XG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIF9TdGFya25ldElkLmdldFN0YXJrTmFtZShcbiAgICAgIC8vIEFmdGVyIE1peGluLCB0aGlzIGlzIFByb3ZpZGVySW50ZXJmYWNlXG4gICAgICB0aGlzLFxuICAgICAgYWRkcmVzcyxcbiAgICAgIFN0YXJrbmV0SWRDb250cmFjdDJcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gX1N0YXJrbmV0SWQuZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUoXG4gICAgICAvLyBBZnRlciBNaXhpbiwgdGhpcyBpcyBQcm92aWRlckludGVyZmFjZVxuICAgICAgdGhpcyxcbiAgICAgIG5hbWUsXG4gICAgICBTdGFya25ldElkQ29udHJhY3QyXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRTdGFya1Byb2ZpbGUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0MiwgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyLCBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDIsIFN0YXJrbmV0SWRQZnBDb250cmFjdDIsIFN0YXJrbmV0SWRQb3BDb250cmFjdDIsIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDIpIHtcbiAgICByZXR1cm4gX1N0YXJrbmV0SWQuZ2V0U3RhcmtQcm9maWxlKFxuICAgICAgLy8gQWZ0ZXIgTWl4aW4sIHRoaXMgaXMgUHJvdmlkZXJJbnRlcmZhY2VcbiAgICAgIHRoaXMsXG4gICAgICBhZGRyZXNzLFxuICAgICAgU3RhcmtuZXRJZENvbnRyYWN0MixcbiAgICAgIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0MixcbiAgICAgIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MixcbiAgICAgIFN0YXJrbmV0SWRQZnBDb250cmFjdDIsXG4gICAgICBTdGFya25ldElkUG9wQ29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0MlxuICAgICk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldFN0YXJrTmFtZShwcm92aWRlciwgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlci5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBTdGFya25ldElkQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGV4RG9tYWluID0gYXdhaXQgcHJvdmlkZXIuY2FsbENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBjb250cmFjdCxcbiAgICAgICAgZW50cnlwb2ludDogXCJhZGRyZXNzX3RvX2RvbWFpblwiLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7XG4gICAgICAgICAgYWRkcmVzc1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCBkZWNpbWFsRG9tYWluID0gaGV4RG9tYWluLm1hcCgoZWxlbWVudCkgPT4gQmlnSW50KGVsZW1lbnQpKS5zbGljZSgxKTtcbiAgICAgIGNvbnN0IHN0cmluZ0RvbWFpbiA9IHVzZURlY29kZWQoZGVjaW1hbERvbWFpbik7XG4gICAgICBpZiAoIXN0cmluZ0RvbWFpbikge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlN0YXJrbmFtZSBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nRG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlID09PSBcIlN0YXJrbmFtZSBub3QgZm91bmRcIikge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IHN0YXJrIG5hbWVcIik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShwcm92aWRlciwgbmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlci5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBTdGFya25ldElkQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5jb2RlZERvbWFpbiA9IG5hbWUucmVwbGFjZShcIi5zdGFya1wiLCBcIlwiKS5zcGxpdChcIi5cIikubWFwKChwYXJ0KSA9PiB1c2VFbmNvZGVkKHBhcnQpLnRvU3RyaW5nKDEwKSk7XG4gICAgICBjb25zdCBhZGRyZXNzRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmNhbGxDb250cmFjdCh7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udHJhY3QsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFwiZG9tYWluX3RvX2FkZHJlc3NcIixcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoeyBkb21haW46IGVuY29kZWREb21haW4sIGhpbnQ6IFtdIH0pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhZGRyZXNzRGF0YVswXTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGdldCBhZGRyZXNzIGZyb20gc3RhcmsgbmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldFN0YXJrUHJvZmlsZShwcm92aWRlciwgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0MiwgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyLCBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDIsIFN0YXJrbmV0SWRQZnBDb250cmFjdDIsIFN0YXJrbmV0SWRQb3BDb250cmFjdDIsIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDIpIHtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgcHJvdmlkZXIuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gU3RhcmtuZXRJZENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkQ29udHJhY3QoY2hhaW5JZCk7XG4gICAgY29uc3QgaWRlbnRpdHlDb250cmFjdCA9IFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdChjaGFpbklkKTtcbiAgICBjb25zdCB2ZXJpZmllckNvbnRyYWN0ID0gU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0KGNoYWluSWQpO1xuICAgIGNvbnN0IHBmcENvbnRyYWN0ID0gU3RhcmtuZXRJZFBmcENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkUGZwQ29udHJhY3QoY2hhaW5JZCk7XG4gICAgY29uc3QgcG9wQ29udHJhY3QgPSBTdGFya25ldElkUG9wQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRQb3BDb250cmFjdChjaGFpbklkKTtcbiAgICBjb25zdCBtdWx0aWNhbGxBZGRyZXNzID0gU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QoY2hhaW5JZCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IG11bHRpY2FsbEFkZHJlc3MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFwiYWdncmVnYXRlXCIsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgICBjYWxsczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChjb250cmFjdCksXG4gICAgICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiYWRkcmVzc190b19kb21haW5cIikpLFxuICAgICAgICAgICAgICBjYWxsZGF0YTogW2R5bmFtaWNDYWxsRGF0YShhZGRyZXNzKV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGNvbnRyYWN0KSxcbiAgICAgICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJkb21haW5fdG9faWRcIikpLFxuICAgICAgICAgICAgICBjYWxsZGF0YTogW2R5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIHZvaWQgMCwgWzAsIDBdKV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGlkZW50aXR5Q29udHJhY3QpLFxuICAgICAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF92ZXJpZmllcl9kYXRhXCIpKSxcbiAgICAgICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbMSwgMF0pLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShlbmNvZGVTaG9ydFN0cmluZyhcInR3aXR0ZXJcIikpLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2ZXJpZmllckNvbnRyYWN0KSxcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGlkZW50aXR5Q29udHJhY3QpLFxuICAgICAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF92ZXJpZmllcl9kYXRhXCIpKSxcbiAgICAgICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbMSwgMF0pLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShlbmNvZGVTaG9ydFN0cmluZyhcImdpdGh1YlwiKSksXG4gICAgICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZlcmlmaWVyQ29udHJhY3QpLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwiZGlzY29yZFwiKSksXG4gICAgICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZlcmlmaWVyQ29udHJhY3QpLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwicHJvb2Zfb2ZfcGVyc29uaG9vZFwiKSksXG4gICAgICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHBvcENvbnRyYWN0KSxcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBQRlBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwibmZ0X3BwX2NvbnRyYWN0XCIpKSxcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEocGZwQ29udHJhY3QpLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X2V4dGVuZGVkX3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwibmZ0X3BwX2lkXCIpKSxcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIyXCIpLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShwZnBDb250cmFjdCksXG4gICAgICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMFwiKVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih2b2lkIDAsIHZvaWQgMCwgWzYsIDAsIDBdKSxcbiAgICAgICAgICAgICAgdG86IGR5bmFtaWNGZWx0KHZvaWQgMCwgWzYsIDBdKSxcbiAgICAgICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJ0b2tlblVSSVwiKSksXG4gICAgICAgICAgICAgIGNhbGxkYXRhOiBbZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzcsIDFdKSwgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzcsIDJdKV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChkYXRhWzBdLCAxNik7XG4gICAgICAgIGNvbnN0IGZpbmFsQXJyYXkgPSBbXTtcbiAgICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViQXJyYXlTaXplID0gcGFyc2VJbnQoZGF0YVtpbmRleF0sIDE2KTtcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICBjb25zdCBzdWJBcnJheSA9IGRhdGEuc2xpY2UoaW5kZXgsIGluZGV4ICsgc3ViQXJyYXlTaXplKTtcbiAgICAgICAgICAgIGZpbmFsQXJyYXkucHVzaChzdWJBcnJheSk7XG4gICAgICAgICAgICBpbmRleCArPSBzdWJBcnJheVNpemU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdXNlRGVjb2RlZChmaW5hbEFycmF5WzBdLnNsaWNlKDEpLm1hcCgoaGV4U3RyaW5nKSA9PiBCaWdJbnQoaGV4U3RyaW5nKSkpO1xuICAgICAgICBjb25zdCB0d2l0dGVyID0gZmluYWxBcnJheVsyXVswXSAhPT0gXCIweDBcIiA/IEJpZ0ludChmaW5hbEFycmF5WzJdWzBdKS50b1N0cmluZygpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBnaXRodWIgPSBmaW5hbEFycmF5WzNdWzBdICE9PSBcIjB4MFwiID8gQmlnSW50KGZpbmFsQXJyYXlbM11bMF0pLnRvU3RyaW5nKCkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGRpc2NvcmQgPSBmaW5hbEFycmF5WzRdWzBdICE9PSBcIjB4MFwiID8gQmlnSW50KGZpbmFsQXJyYXlbNF1bMF0pLnRvU3RyaW5nKCkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHByb29mT2ZQZXJzb25ob29kID0gZmluYWxBcnJheVs1XVswXSA9PT0gXCIweDFcIjtcbiAgICAgICAgY29uc3QgcHJvZmlsZVBpY3R1cmVNZXRhZGF0YSA9IGRhdGFbMF0gPT09IFwiMHg5XCIgPyBmaW5hbEFycmF5WzhdLnNsaWNlKDEpLm1hcCgodmFsKSA9PiBkZWNvZGVTaG9ydFN0cmluZyh2YWwpKS5qb2luKFwiXCIpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBwcm9maWxlUGljdHVyZSA9IHByb2ZpbGVQaWN0dXJlTWV0YWRhdGEgfHwgYGh0dHBzOi8vc3RhcmtuZXQuaWQvYXBpL2lkZW50aWNvbnMvJHtCaWdJbnQoZmluYWxBcnJheVsxXVswXSkudG9TdHJpbmcoKX1gO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHdpdHRlcixcbiAgICAgICAgICBnaXRodWIsXG4gICAgICAgICAgZGlzY29yZCxcbiAgICAgICAgICBwcm9vZk9mUGVyc29uaG9vZCxcbiAgICAgICAgICBwcm9maWxlUGljdHVyZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJFcnJvciB3aGlsZSBjYWxsaW5nIGFnZ3JlZ2F0ZSBmdW5jdGlvblwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgdXNlciBzdGFyayBwcm9maWxlIGRhdGEgZnJvbSBhZGRyZXNzXCIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2V4dGVuc2lvbnMvZGVmYXVsdC50c1xudmFyIFJwY1Byb3ZpZGVyMiA9IGNsYXNzIGV4dGVuZHMgTWl4aW4oUnBjUHJvdmlkZXIsIFN0YXJrbmV0SWQpIHtcbn07XG5cbi8vIHNyYy9wcm92aWRlci9pbnRlcmZhY2UudHNcbnZhciBQcm92aWRlckludGVyZmFjZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy9wcm92aWRlci9pbmRleC50c1xudmFyIGRlZmF1bHRQcm92aWRlciA9IG5ldyBScGNQcm92aWRlcih7IGRlZmF1bHQ6IHRydWUgfSk7XG5cbi8vIHNyYy9zaWduZXIvaW50ZXJmYWNlLnRzXG52YXIgU2lnbmVySW50ZXJmYWNlID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL3V0aWxzL3R5cGVkRGF0YS50c1xudmFyIHR5cGVkRGF0YV9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0eXBlZERhdGFfZXhwb3J0cywge1xuICBUeXBlZERhdGFSZXZpc2lvbjogKCkgPT4gVHlwZWREYXRhUmV2aXNpb24sXG4gIGVuY29kZURhdGE6ICgpID0+IGVuY29kZURhdGEsXG4gIGVuY29kZVR5cGU6ICgpID0+IGVuY29kZVR5cGUsXG4gIGVuY29kZVZhbHVlOiAoKSA9PiBlbmNvZGVWYWx1ZSxcbiAgZ2V0RGVwZW5kZW5jaWVzOiAoKSA9PiBnZXREZXBlbmRlbmNpZXMsXG4gIGdldE1lc3NhZ2VIYXNoOiAoKSA9PiBnZXRNZXNzYWdlSGFzaCxcbiAgZ2V0U3RydWN0SGFzaDogKCkgPT4gZ2V0U3RydWN0SGFzaCxcbiAgZ2V0VHlwZUhhc2g6ICgpID0+IGdldFR5cGVIYXNoLFxuICBpc01lcmtsZVRyZWVUeXBlOiAoKSA9PiBpc01lcmtsZVRyZWVUeXBlLFxuICBwcmVwYXJlU2VsZWN0b3I6ICgpID0+IHByZXBhcmVTZWxlY3RvclxufSk7XG5cbi8vIHNyYy91dGlscy9tZXJrbGUudHNcbnZhciBtZXJrbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobWVya2xlX2V4cG9ydHMsIHtcbiAgTWVya2xlVHJlZTogKCkgPT4gTWVya2xlVHJlZSxcbiAgcHJvb2ZNZXJrbGVQYXRoOiAoKSA9PiBwcm9vZk1lcmtsZVBhdGhcbn0pO1xudmFyIE1lcmtsZVRyZWUgPSBjbGFzcyBfTWVya2xlVHJlZSB7XG4gIGxlYXZlcztcbiAgYnJhbmNoZXMgPSBbXTtcbiAgcm9vdDtcbiAgaGFzaE1ldGhvZDtcbiAgY29uc3RydWN0b3IobGVhZkhhc2hlcywgaGFzaE1ldGhvZCA9IGNvbXB1dGVQZWRlcnNlbkhhc2gpIHtcbiAgICB0aGlzLmhhc2hNZXRob2QgPSBoYXNoTWV0aG9kO1xuICAgIHRoaXMubGVhdmVzID0gbGVhZkhhc2hlcztcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmJ1aWxkKGxlYWZIYXNoZXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgTWVya2xlIHRyZWVcbiAgICogQHBhcmFtIGxlYXZlcyBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEByZXR1cm5zIGZvcm1hdDogaGV4LXN0cmluZzsgTWVya2xlIHRyZWUgcm9vdFxuICAgKi9cbiAgYnVpbGQobGVhdmVzKSB7XG4gICAgaWYgKGxlYXZlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBsZWF2ZXNbMF07XG4gICAgfVxuICAgIGlmIChsZWF2ZXMubGVuZ3RoICE9PSB0aGlzLmxlYXZlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYnJhbmNoZXMucHVzaChsZWF2ZXMpO1xuICAgIH1cbiAgICBjb25zdCBuZXdMZWF2ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKGkgKyAxID09PSBsZWF2ZXMubGVuZ3RoKSB7XG4gICAgICAgIG5ld0xlYXZlcy5wdXNoKF9NZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBcIjB4MFwiLCB0aGlzLmhhc2hNZXRob2QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0xlYXZlcy5wdXNoKF9NZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBsZWF2ZXNbaSArIDFdLCB0aGlzLmhhc2hNZXRob2QpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVpbGQobmV3TGVhdmVzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGhhc2ggZnJvbSBvcmRlcmVkIGEgYW5kIGIsIFBlZGVyc2VuIGhhc2ggZGVmYXVsdFxuICAgKiBAcmV0dXJucyBmb3JtYXQ6IGhleC1zdHJpbmdcbiAgICovXG4gIHN0YXRpYyBoYXNoKGEsIGIsIGhhc2hNZXRob2QgPSBjb21wdXRlUGVkZXJzZW5IYXNoKSB7XG4gICAgY29uc3QgW2FTb3J0ZWQsIGJTb3J0ZWRdID0gW0JpZ0ludChhKSwgQmlnSW50KGIpXS5zb3J0KCh4LCB5KSA9PiB4ID49IHkgPyAxIDogLTEpO1xuICAgIHJldHVybiBoYXNoTWV0aG9kKGFTb3J0ZWQsIGJTb3J0ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gcGF0aCB0byBsZWFmXG4gICAqIEBwYXJhbSBsZWFmIGhleC1zdHJpbmdcbiAgICogQHBhcmFtIGJyYW5jaCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEBwYXJhbSBoYXNoUGF0aCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEByZXR1cm5zIGZvcm1hdDogaGV4LXN0cmluZyBhcnJheVxuICAgKi9cbiAgZ2V0UHJvb2YobGVhZiwgYnJhbmNoID0gdGhpcy5sZWF2ZXMsIGhhc2hQYXRoID0gW10pIHtcbiAgICBjb25zdCBpbmRleCA9IGJyYW5jaC5pbmRleE9mKGxlYWYpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxlYWYgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc2hQYXRoO1xuICAgIH1cbiAgICBjb25zdCBpc0xlZnQgPSBpbmRleCAlIDIgPT09IDA7XG4gICAgY29uc3QgbmVlZGVkQnJhbmNoID0gKGlzTGVmdCA/IGJyYW5jaFtpbmRleCArIDFdIDogYnJhbmNoW2luZGV4IC0gMV0pID8/IFwiMHgwXCI7XG4gICAgY29uc3QgbmV3SGFzaFBhdGggPSBbLi4uaGFzaFBhdGgsIG5lZWRlZEJyYW5jaF07XG4gICAgY29uc3QgY3VycmVudEJyYW5jaExldmVsSW5kZXggPSB0aGlzLmxlYXZlcy5sZW5ndGggPT09IGJyYW5jaC5sZW5ndGggPyAtMSA6IHRoaXMuYnJhbmNoZXMuZmluZEluZGV4KChiKSA9PiBiLmxlbmd0aCA9PT0gYnJhbmNoLmxlbmd0aCk7XG4gICAgY29uc3QgbmV4dEJyYW5jaCA9IHRoaXMuYnJhbmNoZXNbY3VycmVudEJyYW5jaExldmVsSW5kZXggKyAxXSA/PyBbdGhpcy5yb290XTtcbiAgICByZXR1cm4gdGhpcy5nZXRQcm9vZihcbiAgICAgIF9NZXJrbGVUcmVlLmhhc2goaXNMZWZ0ID8gbGVhZiA6IG5lZWRlZEJyYW5jaCwgaXNMZWZ0ID8gbmVlZGVkQnJhbmNoIDogbGVhZiwgdGhpcy5oYXNoTWV0aG9kKSxcbiAgICAgIG5leHRCcmFuY2gsXG4gICAgICBuZXdIYXNoUGF0aFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZk1lcmtsZVBhdGgocm9vdCwgbGVhZiwgcGF0aCwgaGFzaE1ldGhvZCA9IGNvbXB1dGVQZWRlcnNlbkhhc2gpIHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJvb3QgPT09IGxlYWY7XG4gIH1cbiAgY29uc3QgW25leHQsIC4uLnJlc3RdID0gcGF0aDtcbiAgcmV0dXJuIHByb29mTWVya2xlUGF0aChyb290LCBNZXJrbGVUcmVlLmhhc2gobGVhZiwgbmV4dCwgaGFzaE1ldGhvZCksIHJlc3QsIGhhc2hNZXRob2QpO1xufVxuXG4vLyBzcmMvdXRpbHMvdHlwZWREYXRhLnRzXG52YXIgcHJlc2V0VHlwZXMgPSB7XG4gIHUyNTY6IEpTT04ucGFyc2UoJ1t7IFwibmFtZVwiOiBcImxvd1wiLCBcInR5cGVcIjogXCJ1MTI4XCIgfSwgeyBcIm5hbWVcIjogXCJoaWdoXCIsIFwidHlwZVwiOiBcInUxMjhcIiB9XScpLFxuICBUb2tlbkFtb3VudDogSlNPTi5wYXJzZShcbiAgICAnW3sgXCJuYW1lXCI6IFwidG9rZW5fYWRkcmVzc1wiLCBcInR5cGVcIjogXCJDb250cmFjdEFkZHJlc3NcIiB9LCB7IFwibmFtZVwiOiBcImFtb3VudFwiLCBcInR5cGVcIjogXCJ1MjU2XCIgfV0nXG4gICksXG4gIE5mdElkOiBKU09OLnBhcnNlKFxuICAgICdbeyBcIm5hbWVcIjogXCJjb2xsZWN0aW9uX2FkZHJlc3NcIiwgXCJ0eXBlXCI6IFwiQ29udHJhY3RBZGRyZXNzXCIgfSwgeyBcIm5hbWVcIjogXCJ0b2tlbl9pZFwiLCBcInR5cGVcIjogXCJ1MjU2XCIgfV0nXG4gIClcbn07XG52YXIgcmV2aXNpb25Db25maWd1cmF0aW9uID0ge1xuICBbVHlwZWREYXRhUmV2aXNpb24uQWN0aXZlXToge1xuICAgIGRvbWFpbjogXCJTdGFya25ldERvbWFpblwiLFxuICAgIGhhc2hNZXRob2Q6IGNvbXB1dGVQb3NlaWRvbkhhc2hPbkVsZW1lbnRzLFxuICAgIGhhc2hNZXJrbGVNZXRob2Q6IGNvbXB1dGVQb3NlaWRvbkhhc2gsXG4gICAgZXNjYXBlVHlwZVN0cmluZzogKHMpID0+IGBcIiR7c31cImAsXG4gICAgcHJlc2V0VHlwZXNcbiAgfSxcbiAgW1R5cGVkRGF0YVJldmlzaW9uLkxlZ2FjeV06IHtcbiAgICBkb21haW46IFwiU3RhcmtOZXREb21haW5cIixcbiAgICBoYXNoTWV0aG9kOiBjb21wdXRlUGVkZXJzZW5IYXNoT25FbGVtZW50cyxcbiAgICBoYXNoTWVya2xlTWV0aG9kOiBjb21wdXRlUGVkZXJzZW5IYXNoLFxuICAgIGVzY2FwZVR5cGVTdHJpbmc6IChzKSA9PiBzLFxuICAgIHByZXNldFR5cGVzOiB7fVxuICB9XG59O1xuZnVuY3Rpb24gYXNzZXJ0UmFuZ2UoZGF0YSwgdHlwZSwgeyBtaW4sIG1heCB9KSB7XG4gIGNvbnN0IHZhbHVlID0gQmlnSW50KGRhdGEpO1xuICBhc3NlcnQodmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heCwgYCR7dmFsdWV9ICgke3R5cGV9KSBpcyBvdXQgb2YgYm91bmRzIFske21pbn0sICR7bWF4fV1gKTtcbn1cbmZ1bmN0aW9uIGlkZW50aWZ5UmV2aXNpb24oeyB0eXBlcywgZG9tYWluIH0pIHtcbiAgaWYgKHJldmlzaW9uQ29uZmlndXJhdGlvbltUeXBlZERhdGFSZXZpc2lvbi5BY3RpdmVdLmRvbWFpbiBpbiB0eXBlcyAmJiBkb21haW4ucmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFjdGl2ZSlcbiAgICByZXR1cm4gVHlwZWREYXRhUmV2aXNpb24uQWN0aXZlO1xuICBpZiAocmV2aXNpb25Db25maWd1cmF0aW9uW1R5cGVkRGF0YVJldmlzaW9uLkxlZ2FjeV0uZG9tYWluIGluIHR5cGVzICYmIChkb21haW4ucmV2aXNpb24gPz8gVHlwZWREYXRhUmV2aXNpb24uTGVnYWN5KSA9PT0gVHlwZWREYXRhUmV2aXNpb24uTGVnYWN5KVxuICAgIHJldHVybiBUeXBlZERhdGFSZXZpc2lvbi5MZWdhY3k7XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRIZXgodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdG9IZXgodmFsdWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRvSGV4KGVuY29kZVNob3J0U3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBCaWdOdW1iZXJpc2g6ICR7dmFsdWV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZWREYXRhKGRhdGEpIHtcbiAgY29uc3QgdHlwZWREYXRhID0gZGF0YTtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgdHlwZWREYXRhLm1lc3NhZ2UgJiYgdHlwZWREYXRhLnByaW1hcnlUeXBlICYmIHR5cGVkRGF0YS50eXBlcyAmJiBpZGVudGlmeVJldmlzaW9uKHR5cGVkRGF0YSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTZWxlY3RvcihzZWxlY3Rvcikge1xuICByZXR1cm4gaXNIZXgoc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBnZXRTZWxlY3RvckZyb21OYW1lKHNlbGVjdG9yKTtcbn1cbmZ1bmN0aW9uIGlzTWVya2xlVHJlZVR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZS50eXBlID09PSBcIm1lcmtsZXRyZWVcIjtcbn1cbmZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyh0eXBlcywgdHlwZSwgZGVwZW5kZW5jaWVzID0gW10sIGNvbnRhaW5zID0gXCJcIiwgcmV2aXNpb24gPSBUeXBlZERhdGFSZXZpc2lvbi5MZWdhY3kpIHtcbiAgaWYgKHR5cGVbdHlwZS5sZW5ndGggLSAxXSA9PT0gXCIqXCIpIHtcbiAgICB0eXBlID0gdHlwZS5zbGljZSgwLCAtMSk7XG4gIH0gZWxzZSBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFjdGl2ZSkge1xuICAgIGlmICh0eXBlID09PSBcImVudW1cIikge1xuICAgICAgdHlwZSA9IGNvbnRhaW5zO1xuICAgIH0gZWxzZSBpZiAodHlwZS5tYXRjaCgvXlxcKC4qXFwpJC8pKSB7XG4gICAgICB0eXBlID0gdHlwZS5zbGljZSgxLCAtMSk7XG4gICAgfVxuICB9XG4gIGlmIChkZXBlbmRlbmNpZXMuaW5jbHVkZXModHlwZSkgfHwgIXR5cGVzW3R5cGVdKSB7XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgfVxuICByZXR1cm4gW1xuICAgIHR5cGUsXG4gICAgLi4udHlwZXNbdHlwZV0ucmVkdWNlKFxuICAgICAgKHByZXZpb3VzLCB0KSA9PiBbXG4gICAgICAgIC4uLnByZXZpb3VzLFxuICAgICAgICAuLi5nZXREZXBlbmRlbmNpZXModHlwZXMsIHQudHlwZSwgcHJldmlvdXMsIHQuY29udGFpbnMsIHJldmlzaW9uKS5maWx0ZXIoXG4gICAgICAgICAgKGRlcGVuZGVuY3kpID0+ICFwcmV2aW91cy5pbmNsdWRlcyhkZXBlbmRlbmN5KVxuICAgICAgICApXG4gICAgICBdLFxuICAgICAgW11cbiAgICApXG4gIF07XG59XG5mdW5jdGlvbiBnZXRNZXJrbGVUcmVlVHlwZSh0eXBlcywgY3R4KSB7XG4gIGlmIChjdHgucGFyZW50ICYmIGN0eC5rZXkpIHtcbiAgICBjb25zdCBwYXJlbnRUeXBlID0gdHlwZXNbY3R4LnBhcmVudF07XG4gICAgY29uc3QgbWVya2xlVHlwZSA9IHBhcmVudFR5cGUuZmluZCgodCkgPT4gdC5uYW1lID09PSBjdHgua2V5KTtcbiAgICBjb25zdCBpc01lcmtsZVRyZWUgPSBpc01lcmtsZVRyZWVUeXBlKG1lcmtsZVR5cGUpO1xuICAgIGlmICghaXNNZXJrbGVUcmVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y3R4LmtleX0gaXMgbm90IGEgbWVya2xlIHRyZWVgKTtcbiAgICB9XG4gICAgaWYgKG1lcmtsZVR5cGUuY29udGFpbnMuZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lcmtsZSB0cmVlIGNvbnRhaW4gcHJvcGVydHkgbXVzdCBub3QgYmUgYW4gYXJyYXkgYnV0IHdhcyBnaXZlbiAke2N0eC5rZXl9YCk7XG4gICAgfVxuICAgIHJldHVybiBtZXJrbGVUeXBlLmNvbnRhaW5zO1xuICB9XG4gIHJldHVybiBcInJhd1wiO1xufVxuZnVuY3Rpb24gZW5jb2RlVHlwZSh0eXBlcywgdHlwZSwgcmV2aXNpb24gPSBUeXBlZERhdGFSZXZpc2lvbi5MZWdhY3kpIHtcbiAgY29uc3QgYWxsVHlwZXMgPSByZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQWN0aXZlID8geyAuLi50eXBlcywgLi4ucmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5wcmVzZXRUeXBlcyB9IDogdHlwZXM7XG4gIGNvbnN0IFtwcmltYXJ5LCAuLi5kZXBlbmRlbmNpZXNdID0gZ2V0RGVwZW5kZW5jaWVzKFxuICAgIGFsbFR5cGVzLFxuICAgIHR5cGUsXG4gICAgdm9pZCAwLFxuICAgIHZvaWQgMCxcbiAgICByZXZpc2lvblxuICApO1xuICBjb25zdCBuZXdUeXBlcyA9ICFwcmltYXJ5ID8gW10gOiBbcHJpbWFyeSwgLi4uZGVwZW5kZW5jaWVzLnNvcnQoKV07XG4gIGNvbnN0IGVzYyA9IHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0uZXNjYXBlVHlwZVN0cmluZztcbiAgcmV0dXJuIG5ld1R5cGVzLm1hcCgoZGVwZW5kZW5jeSkgPT4ge1xuICAgIGNvbnN0IGRlcGVuZGVuY3lFbGVtZW50cyA9IGFsbFR5cGVzW2RlcGVuZGVuY3ldLm1hcCgodCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IHQudHlwZSA9PT0gXCJlbnVtXCIgJiYgcmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFjdGl2ZSA/IHQuY29udGFpbnMgOiB0LnR5cGU7XG4gICAgICBjb25zdCB0eXBlU3RyaW5nID0gdGFyZ2V0VHlwZS5tYXRjaCgvXlxcKC4qXFwpJC8pID8gYCgke3RhcmdldFR5cGUuc2xpY2UoMSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoKGUpID0+IGUgPyBlc2MoZSkgOiBlKS5qb2luKFwiLFwiKX0pYCA6IGVzYyh0YXJnZXRUeXBlKTtcbiAgICAgIHJldHVybiBgJHtlc2ModC5uYW1lKX06JHt0eXBlU3RyaW5nfWA7XG4gICAgfSk7XG4gICAgcmV0dXJuIGAke2VzYyhkZXBlbmRlbmN5KX0oJHtkZXBlbmRlbmN5RWxlbWVudHN9KWA7XG4gIH0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBnZXRUeXBlSGFzaCh0eXBlcywgdHlwZSwgcmV2aXNpb24gPSBUeXBlZERhdGFSZXZpc2lvbi5MZWdhY3kpIHtcbiAgcmV0dXJuIGdldFNlbGVjdG9yRnJvbU5hbWUoZW5jb2RlVHlwZSh0eXBlcywgdHlwZSwgcmV2aXNpb24pKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVZhbHVlKHR5cGVzLCB0eXBlLCBkYXRhLCBjdHggPSB7fSwgcmV2aXNpb24gPSBUeXBlZERhdGFSZXZpc2lvbi5MZWdhY3kpIHtcbiAgaWYgKHR5cGVzW3R5cGVdKSB7XG4gICAgcmV0dXJuIFt0eXBlLCBnZXRTdHJ1Y3RIYXNoKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbildO1xuICB9XG4gIGlmIChyZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzW3R5cGVdKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHR5cGUsXG4gICAgICBnZXRTdHJ1Y3RIYXNoKFxuICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzLFxuICAgICAgICB0eXBlLFxuICAgICAgICBkYXRhLFxuICAgICAgICByZXZpc2lvblxuICAgICAgKVxuICAgIF07XG4gIH1cbiAgaWYgKHR5cGUuZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgY29uc3QgaGFzaGVzID0gZGF0YS5tYXAoXG4gICAgICAoZW50cnkpID0+IGVuY29kZVZhbHVlKHR5cGVzLCB0eXBlLnNsaWNlKDAsIC0xKSwgZW50cnksIHZvaWQgMCwgcmV2aXNpb24pWzFdXG4gICAgKTtcbiAgICByZXR1cm4gW3R5cGUsIHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0uaGFzaE1ldGhvZChoYXNoZXMpXTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiZW51bVwiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFjdGl2ZSkge1xuICAgICAgICBjb25zdCBbdmFyaWFudEtleSwgdmFyaWFudERhdGFdID0gT2JqZWN0LmVudHJpZXMoZGF0YSlbMF07XG4gICAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSB0eXBlc1tjdHgucGFyZW50XVswXTtcbiAgICAgICAgY29uc3QgZW51bVR5cGUgPSB0eXBlc1twYXJlbnRUeXBlLmNvbnRhaW5zXTtcbiAgICAgICAgY29uc3QgdmFyaWFudFR5cGUgPSBlbnVtVHlwZS5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IHZhcmlhbnRLZXkpO1xuICAgICAgICBjb25zdCB2YXJpYW50SW5kZXggPSBlbnVtVHlwZS5pbmRleE9mKHZhcmlhbnRUeXBlKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFN1YnR5cGVzID0gdmFyaWFudFR5cGUudHlwZS5zbGljZSgxLCAtMSkuc3BsaXQoXCIsXCIpLm1hcCgoc3VidHlwZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoIXN1YnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcbiAgICAgICAgICBjb25zdCBzdWJ0eXBlRGF0YSA9IHZhcmlhbnREYXRhW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gZW5jb2RlVmFsdWUodHlwZXMsIHN1YnR5cGUsIHN1YnR5cGVEYXRhLCB2b2lkIDAsIHJldmlzaW9uKVsxXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoW3ZhcmlhbnRJbmRleCwgLi4uZW5jb2RlZFN1YnR5cGVzXSlcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcIm1lcmtsZXRyZWVcIjoge1xuICAgICAgY29uc3QgbWVya2xlVHJlZVR5cGUgPSBnZXRNZXJrbGVUcmVlVHlwZSh0eXBlcywgY3R4KTtcbiAgICAgIGNvbnN0IHN0cnVjdEhhc2hlcyA9IGRhdGEubWFwKChzdHJ1Y3QpID0+IHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVZhbHVlKHR5cGVzLCBtZXJrbGVUcmVlVHlwZSwgc3RydWN0LCB2b2lkIDAsIHJldmlzaW9uKVsxXTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyByb290IH0gPSBuZXcgTWVya2xlVHJlZShcbiAgICAgICAgc3RydWN0SGFzaGVzLFxuICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXJrbGVNZXRob2RcbiAgICAgICk7XG4gICAgICByZXR1cm4gW1wiZmVsdFwiLCByb290XTtcbiAgICB9XG4gICAgY2FzZSBcInNlbGVjdG9yXCI6IHtcbiAgICAgIHJldHVybiBbXCJmZWx0XCIsIHByZXBhcmVTZWxlY3RvcihkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BY3RpdmUpIHtcbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gYnl0ZUFycmF5RnJvbVN0cmluZyhkYXRhKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXG4gICAgICAgICAgYnl0ZUFycmF5LmRhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmJ5dGVBcnJheS5kYXRhLFxuICAgICAgICAgIGJ5dGVBcnJheS5wZW5kaW5nX3dvcmQsXG4gICAgICAgICAgYnl0ZUFycmF5LnBlbmRpbmdfd29yZF9sZW5cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFt0eXBlLCByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoZWxlbWVudHMpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcImkxMjhcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BY3RpdmUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCaWdJbnQoZGF0YSk7XG4gICAgICAgIGFzc2VydFJhbmdlKHZhbHVlLCB0eXBlLCBSQU5HRV9JMTI4KTtcbiAgICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgodmFsdWUgPCAwbiA/IFBSSU1FICsgdmFsdWUgOiB2YWx1ZSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwidGltZXN0YW1wXCI6XG4gICAgY2FzZSBcInUxMjhcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BY3RpdmUpIHtcbiAgICAgICAgYXNzZXJ0UmFuZ2UoZGF0YSwgdHlwZSwgUkFOR0VfVTEyOCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJmZWx0XCI6XG4gICAgY2FzZSBcInNob3J0c3RyaW5nXCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQWN0aXZlKSB7XG4gICAgICAgIGFzc2VydFJhbmdlKGdldEhleChkYXRhKSwgdHlwZSwgUkFOR0VfRkVMVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJDbGFzc0hhc2hcIjpcbiAgICBjYXNlIFwiQ29udHJhY3RBZGRyZXNzXCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQWN0aXZlKSB7XG4gICAgICAgIGFzc2VydFJhbmdlKGRhdGEsIHR5cGUsIFJBTkdFX0ZFTFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwiYm9vbFwiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFjdGl2ZSkge1xuICAgICAgICBhc3NlcnQodHlwZW9mIGRhdGEgPT09IFwiYm9vbGVhblwiLCBgVHlwZSBtaXNtYXRjaCBmb3IgJHt0eXBlfSAke2RhdGF9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQWN0aXZlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZTogJHt0eXBlfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5jb2RlRGF0YSh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24gPSBUeXBlZERhdGFSZXZpc2lvbi5MZWdhY3kpIHtcbiAgY29uc3QgdGFyZ2V0VHlwZSA9IHR5cGVzW3R5cGVdID8/IHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0ucHJlc2V0VHlwZXNbdHlwZV07XG4gIGNvbnN0IFtyZXR1cm5UeXBlcywgdmFsdWVzXSA9IHRhcmdldFR5cGUucmVkdWNlKFxuICAgIChbdHMsIHZzXSwgZmllbGQpID0+IHtcbiAgICAgIGlmIChkYXRhW2ZpZWxkLm5hbWVdID09PSB2b2lkIDAgfHwgZGF0YVtmaWVsZC5uYW1lXSA9PT0gbnVsbCAmJiBmaWVsZC50eXBlICE9PSBcImVudW1cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBlbmNvZGUgZGF0YTogbWlzc2luZyBkYXRhIGZvciAnJHtmaWVsZC5uYW1lfSdgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtmaWVsZC5uYW1lXTtcbiAgICAgIGNvbnN0IGN0eCA9IHsgcGFyZW50OiB0eXBlLCBrZXk6IGZpZWxkLm5hbWUgfTtcbiAgICAgIGNvbnN0IFt0LCBlbmNvZGVkVmFsdWVdID0gZW5jb2RlVmFsdWUodHlwZXMsIGZpZWxkLnR5cGUsIHZhbHVlLCBjdHgsIHJldmlzaW9uKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFsuLi50cywgdF0sXG4gICAgICAgIFsuLi52cywgZW5jb2RlZFZhbHVlXVxuICAgICAgXTtcbiAgICB9LFxuICAgIFtbXCJmZWx0XCJdLCBbZ2V0VHlwZUhhc2godHlwZXMsIHR5cGUsIHJldmlzaW9uKV1dXG4gICk7XG4gIHJldHVybiBbcmV0dXJuVHlwZXMsIHZhbHVlc107XG59XG5mdW5jdGlvbiBnZXRTdHJ1Y3RIYXNoKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbiA9IFR5cGVkRGF0YVJldmlzaW9uLkxlZ2FjeSkge1xuICByZXR1cm4gcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKGVuY29kZURhdGEodHlwZXMsIHR5cGUsIGRhdGEsIHJldmlzaW9uKVsxXSk7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIGFjY291bnQpIHtcbiAgaWYgKCF2YWxpZGF0ZVR5cGVkRGF0YSh0eXBlZERhdGEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZWQgZGF0YSBkb2VzIG5vdCBtYXRjaCBKU09OIHNjaGVtYVwiKTtcbiAgfVxuICBjb25zdCByZXZpc2lvbiA9IGlkZW50aWZ5UmV2aXNpb24odHlwZWREYXRhKTtcbiAgY29uc3QgeyBkb21haW4sIGhhc2hNZXRob2QgfSA9IHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl07XG4gIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgZW5jb2RlU2hvcnRTdHJpbmcoXCJTdGFya05ldCBNZXNzYWdlXCIpLFxuICAgIGdldFN0cnVjdEhhc2godHlwZWREYXRhLnR5cGVzLCBkb21haW4sIHR5cGVkRGF0YS5kb21haW4sIHJldmlzaW9uKSxcbiAgICBhY2NvdW50LFxuICAgIGdldFN0cnVjdEhhc2godHlwZWREYXRhLnR5cGVzLCB0eXBlZERhdGEucHJpbWFyeVR5cGUsIHR5cGVkRGF0YS5tZXNzYWdlLCByZXZpc2lvbilcbiAgXTtcbiAgcmV0dXJuIGhhc2hNZXRob2QobWVzc2FnZSk7XG59XG5cbi8vIHNyYy9zaWduZXIvZGVmYXVsdC50c1xudmFyIFNpZ25lciA9IGNsYXNzIHtcbiAgcGs7XG4gIGNvbnN0cnVjdG9yKHBrID0gc3RhcmtDdXJ2ZS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpIHtcbiAgICB0aGlzLnBrID0gcGsgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnVmMmhleChwaykgOiB0b0hleChwayk7XG4gIH1cbiAgYXN5bmMgZ2V0UHViS2V5KCkge1xuICAgIHJldHVybiBzdGFya0N1cnZlLmdldFN0YXJrS2V5KHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcyk7XG4gICAgcmV0dXJuIHRoaXMuc2lnblJhdyhtc2dIYXNoKTtcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25zLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YSh0cmFuc2FjdGlvbnMsIGRldGFpbHMuY2Fpcm9WZXJzaW9uKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzZW5kZXJBZGRyZXNzOiBkZXQud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzZW5kZXJBZGRyZXNzOiBkZXQud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnblRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbihkZXRhaWxzKSB7XG4gICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShkZXRhaWxzLmNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzYWx0OiBkZXQuYWRkcmVzc1NhbHQsXG4gICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnblJhdyhtc2dIYXNoKTtcbiAgfVxuICBhc3luYyBzaWduRGVjbGFyZVRyYW5zYWN0aW9uKGRldGFpbHMpIHtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIGFzeW5jIHNpZ25SYXcobXNnSGFzaCkge1xuICAgIHJldHVybiBzdGFya0N1cnZlLnNpZ24obXNnSGFzaCwgdGhpcy5wayk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXIvZXRoU2lnbmVyLnRzXG5pbXBvcnQgeyBzZWNwMjU2azEgYXMgc2VjcDI1NmsxMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuXG4vLyBzcmMvdXRpbHMvdWludDI1Ni50c1xudmFyIHVpbnQyNTZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodWludDI1Nl9leHBvcnRzLCB7XG4gIFVJTlRfMTI4X01BWDogKCkgPT4gVUlOVF8xMjhfTUFYLFxuICBVSU5UXzI1Nl9NQVg6ICgpID0+IFVJTlRfMjU2X01BWCxcbiAgYm5Ub1VpbnQyNTY6ICgpID0+IGJuVG9VaW50MjU2LFxuICBpc1VpbnQyNTY6ICgpID0+IGlzVWludDI1NixcbiAgdWludDI1NlRvQk46ICgpID0+IHVpbnQyNTZUb0JOXG59KTtcbmZ1bmN0aW9uIHVpbnQyNTZUb0JOKHVpbnQyNTYyKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KHVpbnQyNTYyKS50b0JpZ0ludCgpO1xufVxuZnVuY3Rpb24gaXNVaW50MjU2KGJuKSB7XG4gIHJldHVybiBDYWlyb1VpbnQyNTYuaXMoYm4pO1xufVxuZnVuY3Rpb24gYm5Ub1VpbnQyNTYoYm4pIHtcbiAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYoYm4pLnRvVWludDI1NkhleFN0cmluZygpO1xufVxuXG4vLyBzcmMvc2lnbmVyL2V0aFNpZ25lci50c1xudmFyIEV0aFNpZ25lciA9IGNsYXNzIHtcbiAgcGs7XG4gIC8vIGhleCBzdHJpbmcgd2l0aG91dCAweCBhbmQgd2l0aCBhbiBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgY29uc3RydWN0b3IocGsgPSBldGhSYW5kb21Qcml2YXRlS2V5KCkpIHtcbiAgICB0aGlzLnBrID0gcGsgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnVmMmhleChwaykucGFkU3RhcnQoNjQsIFwiMFwiKSA6IHJlbW92ZUhleFByZWZpeCh0b0hleChwaykpLnBhZFN0YXJ0KDY0LCBcIjBcIik7XG4gIH1cbiAgLyoqXG4gICAqIHByb3ZpZGVzIHRoZSBFdGhlcmV1bSBmdWxsIHB1YmxpYyBrZXkgKHdpdGhvdXQgcGFyaXR5IHByZWZpeClcbiAgICogQHJldHVybnMgYW4gaGV4IHN0cmluZyA6IDY0IGZpcnN0IGNoYXJhY3RlcnMgYXJlIFBvaW50IFggY29vcmRpbmF0ZS4gNjQgbGFzdCBjaGFyYWN0ZXJzIGFyZSBQb2ludCBZIGNvb3JkaW5hdGUuXG4gICAqL1xuICBhc3luYyBnZXRQdWJLZXkoKSB7XG4gICAgcmV0dXJuIGFkZEhleFByZWZpeChcbiAgICAgIGJ1ZjJoZXgoc2VjcDI1NmsxMi5nZXRQdWJsaWNLZXkodGhpcy5waywgZmFsc2UpKS5wYWRTdGFydCgxMzAsIFwiMFwiKS5zbGljZSgyKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UodHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIGFjY291bnRBZGRyZXNzKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEyLnNpZ24oXG4gICAgICByZW1vdmVIZXhQcmVmaXgoc2FuaXRpemVIZXgobXNnSGFzaCkpLFxuICAgICAgdGhpcy5wa1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0RXRoU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9ucywgZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEodHJhbnNhY3Rpb25zLCBkZXRhaWxzLmNhaXJvVmVyc2lvbik7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMih7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogZGV0LndhbGxldEFkZHJlc3MsXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMih7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogZGV0LndhbGxldEFkZHJlc3MsXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25UcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEyLnNpZ24oXG4gICAgICByZW1vdmVIZXhQcmVmaXgoc2FuaXRpemVIZXgobXNnSGFzaCkpLFxuICAgICAgdGhpcy5wa1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0RXRoU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIH1cbiAgYXN5bmMgc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbihkZXRhaWxzKSB7XG4gICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShkZXRhaWxzLmNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzYWx0OiBkZXQuYWRkcmVzc1NhbHQsXG4gICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxMi5zaWduKFxuICAgICAgcmVtb3ZlSGV4UHJlZml4KHNhbml0aXplSGV4KG1zZ0hhc2gpKSxcbiAgICAgIHRoaXMucGtcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdEV0aFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVjbGFyZVRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMTIuc2lnbihcbiAgICAgIHJlbW92ZUhleFByZWZpeChzYW5pdGl6ZUhleChtc2dIYXNoKSksXG4gICAgICB0aGlzLnBrXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRFdGhTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBzaWduYXR1cmUgaW4gY29uZm9ybWl0eSB3aXRoIHN0YXJrbmV0OjpldGhfc2lnbmF0dXJlOjpTaWduYXR1cmVcbiAgICogQHBhcmFtIGV0aFNpZ25hdHVyZSBzZWNwMjU2azEgc2lnbmF0dXJlIGZyb20gTm9ibGUgY3VydmVzIGxpYnJhcnlcbiAgICogQHJldHVybiBhbiBhcnJheSBvZiBmZWx0cywgcmVwcmVzZW50aW5nIGEgQ2Fpcm8gRXRoIFNpZ25hdHVyZS5cbiAgICovXG4gIGZvcm1hdEV0aFNpZ25hdHVyZShldGhTaWduYXR1cmUpIHtcbiAgICBjb25zdCByID0gYm5Ub1VpbnQyNTYoZXRoU2lnbmF0dXJlLnIpO1xuICAgIGNvbnN0IHMgPSBiblRvVWludDI1NihldGhTaWduYXR1cmUucyk7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRvSGV4KHIubG93KSxcbiAgICAgIHRvSGV4KHIuaGlnaCksXG4gICAgICB0b0hleChzLmxvdyksXG4gICAgICB0b0hleChzLmhpZ2gpLFxuICAgICAgdG9IZXgoZXRoU2lnbmF0dXJlLnJlY292ZXJ5KVxuICAgIF07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9ldmVudHMudHNcbmZ1bmN0aW9uIHBhcnNlVURDRXZlbnQodHhSZWNlaXB0KSB7XG4gIGlmICghdHhSZWNlaXB0LmV2ZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVEQyBlbWl0dGVkIGV2ZW50IGlzIGVtcHR5XCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gdHhSZWNlaXB0LmV2ZW50cy5maW5kKFxuICAgIChpdCkgPT4gY2xlYW5IZXgoaXQuZnJvbV9hZGRyZXNzKSA9PT0gY2xlYW5IZXgoVURDLkFERFJFU1MpXG4gICkgfHwge1xuICAgIGRhdGE6IFtdXG4gIH07XG4gIHJldHVybiB7XG4gICAgdHJhbnNhY3Rpb25faGFzaDogdHhSZWNlaXB0LnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgY29udHJhY3RfYWRkcmVzczogZXZlbnQuZGF0YVswXSxcbiAgICBhZGRyZXNzOiBldmVudC5kYXRhWzBdLFxuICAgIGRlcGxveWVyOiBldmVudC5kYXRhWzFdLFxuICAgIHVuaXF1ZTogZXZlbnQuZGF0YVsyXSxcbiAgICBjbGFzc0hhc2g6IGV2ZW50LmRhdGFbM10sXG4gICAgY2FsbGRhdGFfbGVuOiBldmVudC5kYXRhWzRdLFxuICAgIGNhbGxkYXRhOiBldmVudC5kYXRhLnNsaWNlKDUsIDUgKyBwYXJzZUludChldmVudC5kYXRhWzRdLCAxNikpLFxuICAgIHNhbHQ6IGV2ZW50LmRhdGFbZXZlbnQuZGF0YS5sZW5ndGggLSAxXVxuICB9O1xufVxuXG4vLyBzcmMvYWNjb3VudC9kZWZhdWx0LnRzXG52YXIgQWNjb3VudCA9IGNsYXNzIGV4dGVuZHMgUnBjUHJvdmlkZXIyIHtcbiAgc2lnbmVyO1xuICBhZGRyZXNzO1xuICBjYWlyb1ZlcnNpb247XG4gIHRyYW5zYWN0aW9uVmVyc2lvbjtcbiAgY29uc3RydWN0b3IocHJvdmlkZXJPck9wdGlvbnMsIGFkZHJlc3MsIHBrT3JTaWduZXIsIGNhaXJvVmVyc2lvbiwgdHJhbnNhY3Rpb25WZXJzaW9uID0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMikge1xuICAgIHN1cGVyKHByb3ZpZGVyT3JPcHRpb25zKTtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5zaWduZXIgPSBpc1N0cmluZyhwa09yU2lnbmVyKSB8fCBwa09yU2lnbmVyIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG5ldyBTaWduZXIocGtPclNpZ25lcikgOiBwa09yU2lnbmVyO1xuICAgIGlmIChjYWlyb1ZlcnNpb24pIHtcbiAgICAgIHRoaXMuY2Fpcm9WZXJzaW9uID0gY2Fpcm9WZXJzaW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNhY3Rpb25WZXJzaW9uID0gdHJhbnNhY3Rpb25WZXJzaW9uO1xuICB9XG4gIC8vIHByb3ZpZGVkIHZlcnNpb24gb3IgY29udHJhY3QgYmFzZWQgcHJlZmVycmVkIHRyYW5zYWN0aW9uVmVyc2lvblxuICBnZXRQcmVmZXJyZWRWZXJzaW9uKHR5cGUxMiwgdHlwZTMpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvblZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpXG4gICAgICByZXR1cm4gdHlwZTM7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb25WZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyKVxuICAgICAgcmV0dXJuIHR5cGUxMjtcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMztcbiAgfVxuICBhc3luYyBnZXROb25jZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0Tm9uY2VGb3JBZGRyZXNzKHRoaXMuYWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXROb25jZVNhZmUobm9uY2UpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRvQmlnSW50KG5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiAwbjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgQ2Fpcm8gdmVyc2lvbiBmcm9tIHRoZSBuZXR3b3JrIGFuZCBzZXRzIGBjYWlyb1ZlcnNpb25gIGlmIG5vdCBhbHJlYWR5IHNldCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIGNsYXNzSGFzaCBpZiBwcm92aWRlZCBkZXRlY3RzIENhaXJvIHZlcnNpb24gZnJvbSBjbGFzc0hhc2gsIG90aGVyd2lzZSBmcm9tIHRoZSBhY2NvdW50IGFkZHJlc3NcbiAgICovXG4gIGFzeW5jIGdldENhaXJvVmVyc2lvbihjbGFzc0hhc2gpIHtcbiAgICBpZiAoIXRoaXMuY2Fpcm9WZXJzaW9uKSB7XG4gICAgICBjb25zdCB7IGNhaXJvIH0gPSBjbGFzc0hhc2ggPyBhd2FpdCBzdXBlci5nZXRDb250cmFjdFZlcnNpb24odm9pZCAwLCBjbGFzc0hhc2gpIDogYXdhaXQgc3VwZXIuZ2V0Q29udHJhY3RWZXJzaW9uKHRoaXMuYWRkcmVzcyk7XG4gICAgICB0aGlzLmNhaXJvVmVyc2lvbiA9IGNhaXJvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWlyb1ZlcnNpb247XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVGZWUoY2FsbHMsIGVzdGltYXRlRmVlRGV0YWlscyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIGVzdGltYXRlRmVlRGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vbmNlOiBwcm92aWRlZE5vbmNlLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgdmVyc2lvbjogcHJvdmlkZWRWZXJzaW9uLFxuICAgICAgc2tpcFZhbGlkYXRlID0gdHJ1ZVxuICAgIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IEFycmF5LmlzQXJyYXkoY2FsbHMpID8gY2FsbHMgOiBbY2FsbHNdO1xuICAgIGNvbnN0IG5vbmNlID0gdG9CaWdJbnQocHJvdmlkZWROb25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzKSxcbiAgICAgIHRvRmVlVmVyc2lvbihwcm92aWRlZFZlcnNpb24pXG4gICAgKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIG5vbmNlLFxuICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGNoYWluSWQsXG4gICAgICBjYWlyb1ZlcnNpb246IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCksXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICB9O1xuICAgIGNvbnN0IGludm9jYXRpb24gPSBhd2FpdCB0aGlzLmJ1aWxkSW52b2NhdGlvbih0cmFuc2FjdGlvbnMsIHNpZ25lckRldGFpbHMpO1xuICAgIHJldHVybiBzdXBlci5nZXRJbnZva2VFc3RpbWF0ZUZlZShcbiAgICAgIHsgLi4uaW52b2NhdGlvbiB9LFxuICAgICAgeyAuLi52M0RldGFpbHMoZGV0YWlscyksIHZlcnNpb24sIG5vbmNlIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBkZXRhaWxzLnNraXBWYWxpZGF0ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVEZWNsYXJlRmVlKHBheWxvYWQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIG5vbmNlOiBwcm92aWRlZE5vbmNlLFxuICAgICAgdmVyc2lvbjogcHJvdmlkZWRWZXJzaW9uLFxuICAgICAgc2tpcFZhbGlkYXRlID0gdHJ1ZVxuICAgIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IG5vbmNlID0gdG9CaWdJbnQocHJvdmlkZWROb25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgICFpc1NpZXJyYShwYXlsb2FkLmNvbnRyYWN0KSA/IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjEgOiB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMiwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMyksXG4gICAgICB0b0ZlZVZlcnNpb24ocHJvdmlkZWRWZXJzaW9uKVxuICAgICk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKHBheWxvYWQsIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIG5vbmNlLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIHZlcnNpb24sXG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMCxcbiAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXJcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5nZXREZWNsYXJlRXN0aW1hdGVGZWUoXG4gICAgICBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbixcbiAgICAgIHsgLi4udjNEZXRhaWxzKGRldGFpbHMpLCB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgZGV0YWlscy5za2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlQWNjb3VudERlcGxveUZlZSh7XG4gICAgY2xhc3NIYXNoLFxuICAgIGFkZHJlc3NTYWx0ID0gMCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgY29udHJhY3RBZGRyZXNzXG4gIH0sIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHsgYmxvY2tJZGVudGlmaWVyLCB2ZXJzaW9uOiBwcm92aWRlZFZlcnNpb24sIHNraXBWYWxpZGF0ZSA9IHRydWUgfSA9IGRldGFpbHM7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjEsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjMpLFxuICAgICAgdG9GZWVWZXJzaW9uKHByb3ZpZGVkVmVyc2lvbilcbiAgICApO1xuICAgIGNvbnN0IG5vbmNlID0gWkVSTztcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZChcbiAgICAgIHsgY2xhc3NIYXNoLCBhZGRyZXNzU2FsdCwgY29uc3RydWN0b3JDYWxsZGF0YSwgY29udHJhY3RBZGRyZXNzIH0sXG4gICAgICB7XG4gICAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICAgIGNhaXJvVmVyc2lvbjogdm9pZCAwLFxuICAgICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyLFxuICAgICAgICBza2lwVmFsaWRhdGVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBzdXBlci5nZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUoXG4gICAgICB7IC4uLnBheWxvYWQgfSxcbiAgICAgIHsgLi4udjNEZXRhaWxzKGRldGFpbHMpLCB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgZGV0YWlscy5za2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRGVwbG95RmVlKHBheWxvYWQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IGNhbGxzID0gdGhpcy5idWlsZFVEQ0NvbnRyYWN0UGF5bG9hZChwYXlsb2FkKTtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZUludm9rZUZlZShjYWxscywgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7IG5vbmNlLCBibG9ja0lkZW50aWZpZXIsIHZlcnNpb24sIHNraXBWYWxpZGF0ZSB9ID0gZGV0YWlscztcbiAgICBjb25zdCBhY2NvdW50SW52b2NhdGlvbnMgPSBhd2FpdCB0aGlzLmFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkoaW52b2NhdGlvbnMsIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIHZlcnNpb25zOiBbXG4gICAgICAgIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjEsXG4gICAgICAgIC8vIG5vbi1zaWVycmFcbiAgICAgICAgdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjIsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjMpLFxuICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgKVxuICAgICAgICAvLyBzaWVycmFcbiAgICAgIF0sXG4gICAgICBub25jZSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5nZXRFc3RpbWF0ZUZlZUJ1bGsoYWNjb3VudEludm9jYXRpb25zLCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICB9KTtcbiAgfVxuICBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7IG5vbmNlLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IHRydWUsIHNraXBFeGVjdXRlLCB2ZXJzaW9uIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IGFjY291bnRJbnZvY2F0aW9ucyA9IGF3YWl0IHRoaXMuYWNjb3VudEludm9jYXRpb25zRmFjdG9yeShpbnZvY2F0aW9ucywge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgdmVyc2lvbnM6IFtcbiAgICAgICAgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSxcbiAgICAgICAgLy8gbm9uLXNpZXJyYVxuICAgICAgICB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMiwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyksXG4gICAgICAgICAgdmVyc2lvblxuICAgICAgICApXG4gICAgICBdLFxuICAgICAgbm9uY2UsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbihhY2NvdW50SW52b2NhdGlvbnMsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZSxcbiAgICAgIHNraXBFeGVjdXRlXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZSh0cmFuc2FjdGlvbnMsIGFyZzIsIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgZGV0YWlscyA9IGFyZzIgPT09IHZvaWQgMCB8fCBBcnJheS5pc0FycmF5KGFyZzIpID8gdHJhbnNhY3Rpb25zRGV0YWlsIDogYXJnMjtcbiAgICBjb25zdCBjYWxscyA9IEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSA/IHRyYW5zYWN0aW9ucyA6IFt0cmFuc2FjdGlvbnNdO1xuICAgIGNvbnN0IG5vbmNlID0gdG9CaWdJbnQoZGV0YWlscy5ub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKSxcbiAgICAgIC8vIFRPRE86IGRvZXMgdGhpcyBkZXBlbmQgb24gY2Fpcm8gdmVyc2lvbiA/XG4gICAgICBkZXRhaWxzLnZlcnNpb25cbiAgICApO1xuICAgIGNvbnN0IGVzdGltYXRlID0gYXdhaXQgdGhpcy5nZXRVbml2ZXJzYWxTdWdnZXN0ZWRGZWUoXG4gICAgICB2ZXJzaW9uLFxuICAgICAgeyB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLywgcGF5bG9hZDogdHJhbnNhY3Rpb25zIH0sXG4gICAgICB7XG4gICAgICAgIC4uLmRldGFpbHMsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBzaWduZXJEZXRhaWxzID0ge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgbm9uY2UsXG4gICAgICBtYXhGZWU6IGVzdGltYXRlLm1heEZlZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBjaGFpbklkLFxuICAgICAgY2Fpcm9WZXJzaW9uOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpXG4gICAgfTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduVHJhbnNhY3Rpb24oY2FsbHMsIHNpZ25lckRldGFpbHMpO1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKGNhbGxzLCBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpKTtcbiAgICByZXR1cm4gdGhpcy5pbnZva2VGdW5jdGlvbihcbiAgICAgIHsgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsIGNhbGxkYXRhLCBzaWduYXR1cmUgfSxcbiAgICAgIHtcbiAgICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGUucmVzb3VyY2VCb3VuZHMsXG4gICAgICAgIG5vbmNlLFxuICAgICAgICBtYXhGZWU6IGVzdGltYXRlLm1heEZlZSxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEZpcnN0IGNoZWNrIGlmIGNvbnRyYWN0IGlzIGFscmVhZHkgZGVjbGFyZWQsIGlmIG5vdCBkZWNsYXJlIGl0XG4gICAqIElmIGNvbnRyYWN0IGFscmVhZHkgZGVjbGFyZWQgcmV0dXJuZWQgdHJhbnNhY3Rpb25faGFzaCBpcyAnJy5cbiAgICogTWV0aG9kIHdpbGwgcGFzcyBldmVuIGlmIGNvbnRyYWN0IGlzIGFscmVhZHkgZGVjbGFyZWRcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uc0RldGFpbCAob3B0aW9uYWwpXG4gICAqL1xuICBhc3luYyBkZWNsYXJlSWZOb3QocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RQYXlsb2FkID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmdldENsYXNzQnlIYXNoKGRlY2xhcmVDb250cmFjdFBheWxvYWQuY2xhc3NIYXNoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyZShwYXlsb2FkLCB0cmFuc2FjdGlvbnNEZXRhaWwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogXCJcIixcbiAgICAgIGNsYXNzX2hhc2g6IGRlY2xhcmVDb250cmFjdFBheWxvYWQuY2xhc3NIYXNoXG4gICAgfTtcbiAgfVxuICBhc3luYyBkZWNsYXJlKHBheWxvYWQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFBheWxvYWQgPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgY29uc3QgeyBub25jZSwgdmVyc2lvbjogcHJvdmlkZWRWZXJzaW9uIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgICFpc1NpZXJyYShwYXlsb2FkLmNvbnRyYWN0KSA/IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEgOiB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMiwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyksXG4gICAgICBwcm92aWRlZFZlcnNpb25cbiAgICApO1xuICAgIGNvbnN0IGVzdGltYXRlID0gYXdhaXQgdGhpcy5nZXRVbml2ZXJzYWxTdWdnZXN0ZWRGZWUoXG4gICAgICB2ZXJzaW9uLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICBwYXlsb2FkOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAuLi5kZXRhaWxzLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBkZWNsYXJlRGV0YWlscyA9IHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZS5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIG1heEZlZTogZXN0aW1hdGUubWF4RmVlLFxuICAgICAgbm9uY2U6IHRvQmlnSW50KG5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSksXG4gICAgICB2ZXJzaW9uLFxuICAgICAgY2hhaW5JZDogYXdhaXQgdGhpcy5nZXRDaGFpbklkKCksXG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMFxuICAgIH07XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLmJ1aWxkRGVjbGFyZVBheWxvYWQoXG4gICAgICBkZWNsYXJlQ29udHJhY3RQYXlsb2FkLFxuICAgICAgZGVjbGFyZURldGFpbHNcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmVDb250cmFjdChkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiwgZGVjbGFyZURldGFpbHMpO1xuICB9XG4gIGFzeW5jIGRlcGxveShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7IGNhbGxzLCBhZGRyZXNzZXMgfSA9IGJ1aWxkVURDQ2FsbChwYXlsb2FkLCB0aGlzLmFkZHJlc3MpO1xuICAgIGNvbnN0IGludm9rZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlKGNhbGxzLCB2b2lkIDAsIGRldGFpbHMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pbnZva2VSZXNwb25zZSxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGFkZHJlc3Nlc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZGVwbG95Q29udHJhY3QocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgZGVwbG95VHggPSBhd2FpdCB0aGlzLmRlcGxveShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICBjb25zdCB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbihkZXBsb3lUeC50cmFuc2FjdGlvbl9oYXNoKTtcbiAgICByZXR1cm4gcGFyc2VVRENFdmVudCh0eFJlY2VpcHQpO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVBbmREZXBsb3kocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgeyBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzYWx0LCB1bmlxdWUgfSA9IHBheWxvYWQ7XG4gICAgbGV0IGRlY2xhcmUgPSBhd2FpdCB0aGlzLmRlY2xhcmVJZk5vdChwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICBpZiAoZGVjbGFyZS50cmFuc2FjdGlvbl9oYXNoICE9PSBcIlwiKSB7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKGRlY2xhcmUudHJhbnNhY3Rpb25faGFzaCk7XG4gICAgICBkZWNsYXJlID0geyAuLi5kZWNsYXJlLCAuLi50eCB9O1xuICAgIH1cbiAgICBjb25zdCBkZXBsb3kgPSBhd2FpdCB0aGlzLmRlcGxveUNvbnRyYWN0KFxuICAgICAgeyBjbGFzc0hhc2g6IGRlY2xhcmUuY2xhc3NfaGFzaCwgc2FsdCwgdW5pcXVlLCBjb25zdHJ1Y3RvckNhbGxkYXRhIH0sXG4gICAgICBkZXRhaWxzXG4gICAgKTtcbiAgICByZXR1cm4geyBkZWNsYXJlOiB7IC4uLmRlY2xhcmUgfSwgZGVwbG95IH07XG4gIH1cbiAgZGVwbG95U2VsZiA9IHRoaXMuZGVwbG95QWNjb3VudDtcbiAgYXN5bmMgZGVwbG95QWNjb3VudCh7XG4gICAgY2xhc3NIYXNoLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXSxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29udHJhY3RBZGRyZXNzOiBwcm92aWRlZENvbnRyYWN0QWRkcmVzc1xuICB9LCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyksXG4gICAgICBkZXRhaWxzLnZlcnNpb25cbiAgICApO1xuICAgIGNvbnN0IG5vbmNlID0gWkVSTztcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gcHJvdmlkZWRDb250cmFjdEFkZHJlc3MgPz8gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goYWRkcmVzc1NhbHQsIGNsYXNzSGFzaCwgY29tcGlsZWRDYWxsZGF0YSwgMCk7XG4gICAgY29uc3QgZXN0aW1hdGUgPSBhd2FpdCB0aGlzLmdldFVuaXZlcnNhbFN1Z2dlc3RlZEZlZShcbiAgICAgIHZlcnNpb24sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGV0YWlsc1xuICAgICk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbih7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjaGFpbklkLFxuICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbm9uY2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kZXBsb3lBY2NvdW50Q29udHJhY3QoXG4gICAgICB7IGNsYXNzSGFzaCwgYWRkcmVzc1NhbHQsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNpZ25hdHVyZSB9LFxuICAgICAge1xuICAgICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICAgIG5vbmNlLFxuICAgICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGUucmVzb3VyY2VCb3VuZHMsXG4gICAgICAgIG1heEZlZTogZXN0aW1hdGUubWF4RmVlLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduZXIuc2lnbk1lc3NhZ2UodHlwZWREYXRhLCB0aGlzLmFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIGhhc2hNZXNzYWdlKHR5cGVkRGF0YSkge1xuICAgIHJldHVybiBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgYXN5bmMgdmVyaWZ5TWVzc2FnZUhhc2goaGFzaCwgc2lnbmF0dXJlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNhbGxDb250cmFjdCh7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICBlbnRyeXBvaW50OiBcImlzVmFsaWRTaWduYXR1cmVcIixcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoe1xuICAgICAgICAgIGhhc2g6IHRvQmlnSW50KGhhc2gpLnRvU3RyaW5nKCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBmb3JtYXRTaWduYXR1cmUoc2lnbmF0dXJlKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoQmlnSW50KHJlc3BbMF0pID09PSAwbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChbXCJhcmdlbnQvaW52YWxpZC1zaWduYXR1cmVcIiwgXCJpcyBpbnZhbGlkLCB3aXRoIHJlc3BlY3QgdG8gdGhlIHB1YmxpYyBrZXlcIl0uc29tZShcbiAgICAgICAgKGVyck1lc3NhZ2UpID0+IGVyci5tZXNzYWdlLmluY2x1ZGVzKGVyck1lc3NhZ2UpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKGBTaWduYXR1cmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgaXMgcmVqZWN0ZWQgYnkgdGhlIG5ldHdvcms6ICR7ZXJyfWApO1xuICAgIH1cbiAgfVxuICBhc3luYyB2ZXJpZnlNZXNzYWdlKHR5cGVkRGF0YSwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuaGFzaE1lc3NhZ2UodHlwZWREYXRhKTtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlNZXNzYWdlSGFzaChoYXNoLCBzaWduYXR1cmUpO1xuICB9XG4gIC8qXG4gICAqIFN1cHBvcnQgbWV0aG9kc1xuICAgKi9cbiAgYXN5bmMgZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKHZlcnNpb24sIHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IG1heEZlZSA9IDA7XG4gICAgbGV0IHJlc291cmNlQm91bmRzID0gZXN0aW1hdGVGZWVUb0JvdW5kcyhaRVJPKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMykge1xuICAgICAgcmVzb3VyY2VCb3VuZHMgPSBkZXRhaWxzLnJlc291cmNlQm91bmRzID8/IChhd2FpdCB0aGlzLmdldFN1Z2dlc3RlZEZlZSh7IHR5cGUsIHBheWxvYWQgfSwgZGV0YWlscykpLnJlc291cmNlQm91bmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhGZWUgPSBkZXRhaWxzLm1heEZlZSA/PyAoYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRGZWUoeyB0eXBlLCBwYXlsb2FkIH0sIGRldGFpbHMpKS5zdWdnZXN0ZWRNYXhGZWU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtYXhGZWUsXG4gICAgICByZXNvdXJjZUJvdW5kc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZ2V0U3VnZ2VzdGVkRmVlKHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IGZlZUVzdGltYXRlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlSW52b2tlRmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlRGVjbGFyZUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlQWNjb3VudERlcGxveUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVQTE9ZXCIgLyogREVQTE9ZICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVEZXBsb3lGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSB7XG4gICAgICAgICAgZ2FzX2NvbnN1bWVkOiAwbixcbiAgICAgICAgICBnYXNfcHJpY2U6IDBuLFxuICAgICAgICAgIG92ZXJhbGxfZmVlOiBaRVJPLFxuICAgICAgICAgIHVuaXQ6IFwiRlJJXCIsXG4gICAgICAgICAgc3VnZ2VzdGVkTWF4RmVlOiBaRVJPLFxuICAgICAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZUZlZVRvQm91bmRzKFpFUk8pLFxuICAgICAgICAgIGRhdGFfZ2FzX2NvbnN1bWVkOiAwbixcbiAgICAgICAgICBkYXRhX2dhc19wcmljZTogMG5cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBmZWVFc3RpbWF0ZTtcbiAgfVxuICBhc3luYyBidWlsZEludm9jYXRpb24oY2FsbCwgZGV0YWlscykge1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKGNhbGwsIGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCkpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICFkZXRhaWxzLnNraXBWYWxpZGF0ZSA/IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbihjYWxsLCBkZXRhaWxzKSA6IFtdO1xuICAgIHJldHVybiB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGNhbGxkYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuICBhc3luYyBidWlsZERlY2xhcmVQYXlsb2FkKHBheWxvYWQsIGRldGFpbHMpIHtcbiAgICBjb25zdCB7IGNsYXNzSGFzaCwgY29udHJhY3QsIGNvbXBpbGVkQ2xhc3NIYXNoIH0gPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgY29uc3QgY29tcHJlc3NlZENvbXBpbGVkQ29udHJhY3QgPSBwYXJzZUNvbnRyYWN0KGNvbnRyYWN0KTtcbiAgICBpZiAodHlwZW9mIGNvbXBpbGVkQ2xhc3NIYXNoID09PSBcInVuZGVmaW5lZFwiICYmIChkZXRhaWxzLnZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zLkYzIHx8IGRldGFpbHMudmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMuVjMpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlYzIFRyYW5zYWN0aW9uIHdvcmsgd2l0aCBDYWlybzEgQ29udHJhY3RzIGFuZCByZXF1aXJlIGNvbXBpbGVkQ2xhc3NIYXNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSAhZGV0YWlscy5za2lwVmFsaWRhdGUgPyBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVjbGFyZVRyYW5zYWN0aW9uKHtcbiAgICAgIC4uLmRldGFpbHMsXG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBjb21waWxlZENsYXNzSGFzaCxcbiAgICAgIC8vIFRPRE86IFRTLCBjYXN0IGJlY2F1c2Ugb3B0aW9uYWwgZm9yIHYyIGFuZCByZXF1aXJlZCBmb3IgdjMsIHRocm93biBpZiBub3QgcHJlc2VudFxuICAgICAgc2VuZGVyQWRkcmVzczogZGV0YWlscy53YWxsZXRBZGRyZXNzXG4gICAgfSkgOiBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgc2VuZGVyQWRkcmVzczogZGV0YWlscy53YWxsZXRBZGRyZXNzLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgY29udHJhY3Q6IGNvbXByZXNzZWRDb21waWxlZENvbnRyYWN0LFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2hcbiAgICB9O1xuICB9XG4gIGFzeW5jIGJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzID8/IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKGFkZHJlc3NTYWx0LCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2FsbGRhdGEsIDApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICFkZXRhaWxzLnNraXBWYWxpZGF0ZSA/IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oe1xuICAgICAgLi4uZGV0YWlscyxcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YVxuICAgIH0pIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH07XG4gIH1cbiAgYnVpbGRVRENDb250cmFjdFBheWxvYWQocGF5bG9hZCkge1xuICAgIGNvbnN0IGNhbGxzID0gW10uY29uY2F0KHBheWxvYWQpLm1hcCgoaXQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICBzYWx0ID0gXCIwXCIsXG4gICAgICAgIHVuaXF1ZSA9IHRydWUsXG4gICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXVxuICAgICAgfSA9IGl0O1xuICAgICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogVURDLkFERFJFU1MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFVEQy5FTlRSWVBPSU5ULFxuICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBzYWx0LFxuICAgICAgICAgIHRvQ2Fpcm9Cb29sKHVuaXF1ZSksXG4gICAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi5jb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGFcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbHM7XG4gIH1cbiAgYXN5bmMgYWNjb3VudEludm9jYXRpb25zRmFjdG9yeShpbnZvY2F0aW9ucywgZGV0YWlscykge1xuICAgIGNvbnN0IHsgbm9uY2UsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gdHJ1ZSB9ID0gZGV0YWlscztcbiAgICBjb25zdCBzYWZlTm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlU2FmZShub25jZSk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHZlcnNpb25zID0gZGV0YWlscy52ZXJzaW9ucy5tYXAoKGl0KSA9PiB0b1RyYW5zYWN0aW9uVmVyc2lvbihpdCkpO1xuICAgIGNvbnN0IHR4MFBheWxvYWQgPSBcInBheWxvYWRcIiBpbiBpbnZvY2F0aW9uc1swXSA/IGludm9jYXRpb25zWzBdLnBheWxvYWQgOiBpbnZvY2F0aW9uc1swXTtcbiAgICBjb25zdCBjYWlyb1ZlcnNpb24gPSBpbnZvY2F0aW9uc1swXS50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8gPyBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbih0eDBQYXlsb2FkLmNsYXNzSGFzaCkgOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIFtdLmNvbmNhdChpbnZvY2F0aW9ucykubWFwKGFzeW5jICh0cmFuc2FjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgdHhQYXlsb2FkID0gXCJwYXlsb2FkXCIgaW4gdHJhbnNhY3Rpb24gPyB0cmFuc2FjdGlvbi5wYXlsb2FkIDogdHJhbnNhY3Rpb247XG4gICAgICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9CaWdJbnQoTnVtYmVyKHNhZmVOb25jZSkgKyBpbmRleCksXG4gICAgICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgY2Fpcm9WZXJzaW9uLFxuICAgICAgICAgIHZlcnNpb246IFwiXCIsXG4gICAgICAgICAgc2tpcFZhbGlkYXRlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbW1vbiA9IHtcbiAgICAgICAgICB0eXBlOiB0cmFuc2FjdGlvbi50eXBlLFxuICAgICAgICAgIG5vbmNlOiB0b0JpZ0ludChOdW1iZXIoc2FmZU5vbmNlKSArIGluZGV4KSxcbiAgICAgICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICAgICAgdmVyc2lvbjogXCJcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8pIHtcbiAgICAgICAgICBjb25zdCB2ZXJzaW9uWCA9IHJlZHVjZVYyKHZlcnNpb25zWzFdKTtcbiAgICAgICAgICBzaWduZXJEZXRhaWxzLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb21tb24udmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkSW52b2NhdGlvbihcbiAgICAgICAgICAgIFtdLmNvbmNhdCh0eFBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmVyRGV0YWlsc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIkRFUExPWVwiIC8qIERFUExPWSAqLykge1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25YID0gcmVkdWNlVjIodmVyc2lvbnNbMV0pO1xuICAgICAgICAgIHNpZ25lckRldGFpbHMudmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbW1vbi52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29uc3QgY2FsbHMgPSB0aGlzLmJ1aWxkVURDQ29udHJhY3RQYXlsb2FkKHR4UGF5bG9hZCk7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKGNhbGxzLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25YID0gIWlzU2llcnJhKHR4UGF5bG9hZC5jb250cmFjdCkgPyB2ZXJzaW9uc1swXSA6IHZlcnNpb25zWzFdO1xuICAgICAgICAgIHNpZ25lckRldGFpbHMudmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbW1vbi52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZCh0eFBheWxvYWQsIHNpZ25lckRldGFpbHMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovKSB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvblggPSByZWR1Y2VWMih2ZXJzaW9uc1sxXSk7XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29tbW9uLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEFjY291bnREZXBsb3lQYXlsb2FkKHR4UGF5bG9hZCwgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKGBhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5OiB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiAke3RyYW5zYWN0aW9ufWApO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzID0gdGhpcy5hZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxufTtcblxuLy8gc3JjL2FjY291bnQvaW50ZXJmYWNlLnRzXG52YXIgQWNjb3VudEludGVyZmFjZSA9IGNsYXNzIGV4dGVuZHMgUHJvdmlkZXJJbnRlcmZhY2Uge1xufTtcblxuLy8gc3JjL3dhbGxldC9jb25uZWN0LnRzXG52YXIgY29ubmVjdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChjb25uZWN0X2V4cG9ydHMsIHtcbiAgYWRkRGVjbGFyZVRyYW5zYWN0aW9uOiAoKSA9PiBhZGREZWNsYXJlVHJhbnNhY3Rpb24sXG4gIGFkZEludm9rZVRyYW5zYWN0aW9uOiAoKSA9PiBhZGRJbnZva2VUcmFuc2FjdGlvbixcbiAgYWRkU3RhcmtuZXRDaGFpbjogKCkgPT4gYWRkU3RhcmtuZXRDaGFpbixcbiAgZGVwbG95bWVudERhdGE6ICgpID0+IGRlcGxveW1lbnREYXRhLFxuICBnZXRQZXJtaXNzaW9uczogKCkgPT4gZ2V0UGVybWlzc2lvbnMsXG4gIG9uQWNjb3VudENoYW5nZTogKCkgPT4gb25BY2NvdW50Q2hhbmdlLFxuICBvbk5ldHdvcmtDaGFuZ2VkOiAoKSA9PiBvbk5ldHdvcmtDaGFuZ2VkLFxuICByZXF1ZXN0QWNjb3VudHM6ICgpID0+IHJlcXVlc3RBY2NvdW50cyxcbiAgcmVxdWVzdENoYWluSWQ6ICgpID0+IHJlcXVlc3RDaGFpbklkLFxuICBzaWduTWVzc2FnZTogKCkgPT4gc2lnbk1lc3NhZ2UsXG4gIHN1cHBvcnRlZFNwZWNzOiAoKSA9PiBzdXBwb3J0ZWRTcGVjcyxcbiAgc3dpdGNoU3RhcmtuZXRDaGFpbjogKCkgPT4gc3dpdGNoU3RhcmtuZXRDaGFpbixcbiAgd2F0Y2hBc3NldDogKCkgPT4gd2F0Y2hBc3NldFxufSk7XG5mdW5jdGlvbiByZXF1ZXN0QWNjb3VudHMoc3dvLCBzaWxlbnRfbW9kZSA9IGZhbHNlKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgcGFyYW1zOiB7XG4gICAgICBzaWxlbnRfbW9kZVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9ucyhzd28pIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfZ2V0UGVybWlzc2lvbnNcIiB9KTtcbn1cbmZ1bmN0aW9uIHdhdGNoQXNzZXQoc3dvLCBhc3NldCkge1xuICByZXR1cm4gc3dvLnJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X3dhdGNoQXNzZXRcIixcbiAgICBwYXJhbXM6IGFzc2V0XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkU3RhcmtuZXRDaGFpbihzd28sIGNoYWluKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfYWRkU3RhcmtuZXRDaGFpblwiLFxuICAgIHBhcmFtczogY2hhaW5cbiAgfSk7XG59XG5mdW5jdGlvbiBzd2l0Y2hTdGFya25ldENoYWluKHN3bywgY2hhaW5JZCkge1xuICByZXR1cm4gc3dvLnJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X3N3aXRjaFN0YXJrbmV0Q2hhaW5cIixcbiAgICBwYXJhbXM6IHtcbiAgICAgIGNoYWluSWRcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVxdWVzdENoYWluSWQoc3dvKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7IHR5cGU6IFwid2FsbGV0X3JlcXVlc3RDaGFpbklkXCIgfSk7XG59XG5mdW5jdGlvbiBkZXBsb3ltZW50RGF0YShzd28pIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfZGVwbG95bWVudERhdGFcIiB9KTtcbn1cbmZ1bmN0aW9uIGFkZEludm9rZVRyYW5zYWN0aW9uKHN3bywgcGFyYW1zKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIixcbiAgICBwYXJhbXNcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGREZWNsYXJlVHJhbnNhY3Rpb24oc3dvLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIixcbiAgICBwYXJhbXNcbiAgfSk7XG59XG5mdW5jdGlvbiBzaWduTWVzc2FnZShzd28sIHR5cGVkRGF0YSkge1xuICByZXR1cm4gc3dvLnJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X3NpZ25UeXBlZERhdGFcIixcbiAgICBwYXJhbXM6IHR5cGVkRGF0YVxuICB9KTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRlZFNwZWNzKHN3bykge1xuICByZXR1cm4gc3dvLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9zdXBwb3J0ZWRTcGVjc1wiIH0pO1xufVxuZnVuY3Rpb24gb25BY2NvdW50Q2hhbmdlKHN3bywgY2FsbGJhY2spIHtcbiAgc3dvLm9uKFwiYWNjb3VudHNDaGFuZ2VkXCIsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG9uTmV0d29ya0NoYW5nZWQoc3dvLCBjYWxsYmFjaykge1xuICBzd28ub24oXCJuZXR3b3JrQ2hhbmdlZFwiLCBjYWxsYmFjayk7XG59XG5cbi8vIHNyYy93YWxsZXQvYWNjb3VudC50c1xudmFyIFdhbGxldEFjY291bnQgPSBjbGFzcyBleHRlbmRzIEFjY291bnQge1xuICBhZGRyZXNzID0gXCJcIjtcbiAgd2FsbGV0UHJvdmlkZXI7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyT3JPcHRpb25zLCB3YWxsZXRQcm92aWRlciwgY2Fpcm9WZXJzaW9uKSB7XG4gICAgc3VwZXIocHJvdmlkZXJPck9wdGlvbnMsIFwiXCIsIFwiXCIsIGNhaXJvVmVyc2lvbik7XG4gICAgdGhpcy53YWxsZXRQcm92aWRlciA9IHdhbGxldFByb3ZpZGVyO1xuICAgIHRoaXMud2FsbGV0UHJvdmlkZXIub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgKHJlcykgPT4ge1xuICAgICAgaWYgKCFyZXMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuYWRkcmVzcyA9IHJlc1swXS50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICAgIHRoaXMud2FsbGV0UHJvdmlkZXIub24oXCJuZXR3b3JrQ2hhbmdlZFwiLCAocmVzKSA9PiB7XG4gICAgICBpZiAoIXJlcylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5jaGFubmVsLnNldENoYWluSWQocmVzKTtcbiAgICB9KTtcbiAgICB3YWxsZXRQcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIHR5cGU6IFwid2FsbGV0X3JlcXVlc3RBY2NvdW50c1wiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHNpbGVudF9tb2RlOiBmYWxzZVxuICAgICAgfVxuICAgIH0pLnRoZW4oKHJlcykgPT4ge1xuICAgICAgdGhpcy5hZGRyZXNzID0gcmVzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFdBTExFVCBFVkVOVFNcbiAgICovXG4gIG9uQWNjb3VudENoYW5nZShjYWxsYmFjaykge1xuICAgIG9uQWNjb3VudENoYW5nZSh0aGlzLndhbGxldFByb3ZpZGVyLCBjYWxsYmFjayk7XG4gIH1cbiAgb25OZXR3b3JrQ2hhbmdlZChjYWxsYmFjaykge1xuICAgIG9uTmV0d29ya0NoYW5nZWQodGhpcy53YWxsZXRQcm92aWRlciwgY2FsbGJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBXQUxMRVQgU1BFQ0lGSUMgTUVUSE9EU1xuICAgKi9cbiAgcmVxdWVzdEFjY291bnRzKHNpbGVudE1vZGUgPSBmYWxzZSkge1xuICAgIHJldHVybiByZXF1ZXN0QWNjb3VudHModGhpcy53YWxsZXRQcm92aWRlciwgc2lsZW50TW9kZSk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIGdldFBlcm1pc3Npb25zKHRoaXMud2FsbGV0UHJvdmlkZXIpO1xuICB9XG4gIHN3aXRjaFN0YXJrbmV0Q2hhaW4oY2hhaW5JZCkge1xuICAgIHJldHVybiBzd2l0Y2hTdGFya25ldENoYWluKHRoaXMud2FsbGV0UHJvdmlkZXIsIGNoYWluSWQpO1xuICB9XG4gIHdhdGNoQXNzZXQoYXNzZXQpIHtcbiAgICByZXR1cm4gd2F0Y2hBc3NldCh0aGlzLndhbGxldFByb3ZpZGVyLCBhc3NldCk7XG4gIH1cbiAgYWRkU3RhcmtuZXRDaGFpbihjaGFpbikge1xuICAgIHJldHVybiBhZGRTdGFya25ldENoYWluKHRoaXMud2FsbGV0UHJvdmlkZXIsIGNoYWluKTtcbiAgfVxuICAvKipcbiAgICogQUNDT1VOVCBNRVRIT0RTXG4gICAqL1xuICBleGVjdXRlKGNhbGxzKSB7XG4gICAgY29uc3QgdHhDYWxscyA9IFtdLmNvbmNhdChjYWxscykubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3QgeyBjb250cmFjdEFkZHJlc3MsIGVudHJ5cG9pbnQsIGNhbGxkYXRhIH0gPSBpdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgZW50cnlfcG9pbnQ6IGVudHJ5cG9pbnQsXG4gICAgICAgIGNhbGxkYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGNhbGxzOiB0eENhbGxzXG4gICAgfTtcbiAgICByZXR1cm4gYWRkSW52b2tlVHJhbnNhY3Rpb24odGhpcy53YWxsZXRQcm92aWRlciwgcGFyYW1zKTtcbiAgfVxuICBkZWNsYXJlKHBheWxvYWQpIHtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RQYXlsb2FkID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IHBDb250cmFjdCA9IHBheWxvYWQuY29udHJhY3Q7XG4gICAgY29uc3QgY2Fpcm8xQ29udHJhY3QgPSB7XG4gICAgICAuLi5wQ29udHJhY3QsXG4gICAgICBhYmk6IHN0cmluZ2lmeTIocENvbnRyYWN0LmFiaSlcbiAgICB9O1xuICAgIGlmICghZGVjbGFyZUNvbnRyYWN0UGF5bG9hZC5jb21waWxlZENsYXNzSGFzaCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJjb21waWxlZENsYXNzSGFzaCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogZGVjbGFyZUNvbnRyYWN0UGF5bG9hZC5jb21waWxlZENsYXNzSGFzaCxcbiAgICAgIGNvbnRyYWN0X2NsYXNzOiBjYWlybzFDb250cmFjdFxuICAgIH07XG4gICAgcmV0dXJuIGFkZERlY2xhcmVUcmFuc2FjdGlvbih0aGlzLndhbGxldFByb3ZpZGVyLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGRlcGxveShwYXlsb2FkKSB7XG4gICAgY29uc3QgeyBjYWxscywgYWRkcmVzc2VzIH0gPSBidWlsZFVEQ0NhbGwocGF5bG9hZCwgdGhpcy5hZGRyZXNzKTtcbiAgICBjb25zdCBpbnZva2VSZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZShjYWxscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmludm9rZVJlc3BvbnNlLFxuICAgICAgY29udHJhY3RfYWRkcmVzczogYWRkcmVzc2VzXG4gICAgfTtcbiAgfVxuICBzaWduTWVzc2FnZSh0eXBlZERhdGEpIHtcbiAgICByZXR1cm4gc2lnbk1lc3NhZ2UodGhpcy53YWxsZXRQcm92aWRlciwgdHlwZWREYXRhKTtcbiAgfVxuICAvLyBUT0RPOiBNSVNTSU5HIEVTVElNQVRFU1xufTtcblxuLy8gc3JjL3V0aWxzL2V2ZW50cy9pbmRleC50c1xudmFyIGV2ZW50c19leHBvcnRzID0ge307XG5fX2V4cG9ydChldmVudHNfZXhwb3J0cywge1xuICBnZXRBYmlFdmVudHM6ICgpID0+IGdldEFiaUV2ZW50cyxcbiAgcGFyc2VFdmVudHM6ICgpID0+IHBhcnNlRXZlbnRzXG59KTtcbmZ1bmN0aW9uIGdldEFiaUV2ZW50cyhhYmkpIHtcbiAgcmV0dXJuIGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcImV2ZW50XCIgJiYgKGFiaUVudHJ5LnNpemUgfHwgYWJpRW50cnkua2luZCAhPT0gXCJlbnVtXCIpKS5yZWR1Y2UoKGFjYywgYWJpRW50cnkpID0+IHtcbiAgICBjb25zdCBlbnRyeU5hbWUgPSBhYmlFbnRyeS5uYW1lLnNsaWNlKGFiaUVudHJ5Lm5hbWUubGFzdEluZGV4T2YoXCI6XCIpICsgMSk7XG4gICAgY29uc3QgYWJpRW50cnlNb2QgPSB7IC4uLmFiaUVudHJ5IH07XG4gICAgYWJpRW50cnlNb2QubmFtZSA9IGVudHJ5TmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjLFxuICAgICAgW2FkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShlbnRyeU5hbWUpKS50b1N0cmluZygxNikpXTogYWJpRW50cnlNb2RcbiAgICB9O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBwYXJzZUV2ZW50cyhwcm92aWRlclJlY2VpdmVkRXZlbnRzLCBhYmlFdmVudHMsIGFiaVN0cnVjdHMsIGFiaUVudW1zKSB7XG4gIGNvbnN0IHJldCA9IHByb3ZpZGVyUmVjZWl2ZWRFdmVudHMuZmxhdCgpLnJlZHVjZSgoYWNjLCByZWNFdmVudCkgPT4ge1xuICAgIGNvbnN0IGFiaUV2ZW50ID0gYWJpRXZlbnRzW3JlY0V2ZW50LmtleXNbMF1dO1xuICAgIGlmICghYWJpRXZlbnQpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0ge307XG4gICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV0gPSB7fTtcbiAgICByZWNFdmVudC5rZXlzLnNoaWZ0KCk7XG4gICAgY29uc3Qga2V5c0l0ZXIgPSByZWNFdmVudC5rZXlzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBkYXRhSXRlciA9IHJlY0V2ZW50LmRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGFiaUV2ZW50S2V5cyA9IGFiaUV2ZW50Lm1lbWJlcnM/LmZpbHRlcigoaXQpID0+IGl0LmtpbmQgPT09IFwia2V5XCIpIHx8IGFiaUV2ZW50LmtleXM7XG4gICAgY29uc3QgYWJpRXZlbnREYXRhID0gYWJpRXZlbnQubWVtYmVycz8uZmlsdGVyKChpdCkgPT4gaXQua2luZCA9PT0gXCJkYXRhXCIpIHx8IGFiaUV2ZW50LmRhdGE7XG4gICAgYWJpRXZlbnRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1ba2V5Lm5hbWVdID0gcmVzcG9uc2VQYXJzZXIoXG4gICAgICAgIGtleXNJdGVyLFxuICAgICAgICBrZXksXG4gICAgICAgIGFiaVN0cnVjdHMsXG4gICAgICAgIGFiaUVudW1zLFxuICAgICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBhYmlFdmVudERhdGEuZm9yRWFjaCgoZGF0YSkgPT4ge1xuICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1bZGF0YS5uYW1lXSA9IHJlc3BvbnNlUGFyc2VyKFxuICAgICAgICBkYXRhSXRlcixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgYWJpU3RydWN0cyxcbiAgICAgICAgYWJpRW51bXMsXG4gICAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdXG4gICAgICApO1xuICAgIH0pO1xuICAgIGFjYy5wdXNoKHBhcnNlZEV2ZW50KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIHNyYy9jb250cmFjdC9kZWZhdWx0LnRzXG52YXIgc3BsaXRBcmdzQW5kT3B0aW9ucyA9IChhcmdzKSA9PiB7XG4gIGNvbnN0IG9wdGlvbnMgPSBbXG4gICAgXCJibG9ja0lkZW50aWZpZXJcIixcbiAgICBcInBhcnNlUmVxdWVzdFwiLFxuICAgIFwicGFyc2VSZXNwb25zZVwiLFxuICAgIFwiZm9ybWF0UmVzcG9uc2VcIixcbiAgICBcIm1heEZlZVwiLFxuICAgIFwibm9uY2VcIixcbiAgICBcInNpZ25hdHVyZVwiLFxuICAgIFwiYWRkcmVzc1NhbHRcIlxuICBdO1xuICBjb25zdCBsYXN0QXJnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICBpZiAodHlwZW9mIGxhc3RBcmcgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5zb21lKCh4KSA9PiB4IGluIGxhc3RBcmcpKSB7XG4gICAgcmV0dXJuIHsgYXJncywgb3B0aW9uczogYXJncy5wb3AoKSB9O1xuICB9XG4gIHJldHVybiB7IGFyZ3MgfTtcbn07XG5mdW5jdGlvbiBidWlsZENhbGwoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICByZXR1cm4gY29udHJhY3QuY2FsbChmdW5jdGlvbkFiaS5uYW1lLCBwYXJhbXMuYXJncywge1xuICAgICAgcGFyc2VSZXF1ZXN0OiB0cnVlLFxuICAgICAgcGFyc2VSZXNwb25zZTogdHJ1ZSxcbiAgICAgIC4uLnBhcmFtcy5vcHRpb25zXG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZEludm9rZShjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzcGxpdEFyZ3NBbmRPcHRpb25zKGFyZ3MpO1xuICAgIHJldHVybiBjb250cmFjdC5pbnZva2UoZnVuY3Rpb25BYmkubmFtZSwgcGFyYW1zLmFyZ3MsIHtcbiAgICAgIHBhcnNlUmVxdWVzdDogdHJ1ZSxcbiAgICAgIC4uLnBhcmFtcy5vcHRpb25zXG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZERlZmF1bHQoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIGlmIChmdW5jdGlvbkFiaS5zdGF0ZU11dGFiaWxpdHkgPT09IFwidmlld1wiIHx8IGZ1bmN0aW9uQWJpLnN0YXRlX211dGFiaWxpdHkgPT09IFwidmlld1wiKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ2FsbChjb250cmFjdCwgZnVuY3Rpb25BYmkpO1xuICB9XG4gIHJldHVybiBidWlsZEludm9rZShjb250cmFjdCwgZnVuY3Rpb25BYmkpO1xufVxuZnVuY3Rpb24gYnVpbGRQb3B1bGF0ZShjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY29udHJhY3QucG9wdWxhdGUoZnVuY3Rpb25BYmkubmFtZSwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZEVzdGltYXRlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBjb250cmFjdC5lc3RpbWF0ZShmdW5jdGlvbkFiaS5uYW1lLCBhcmdzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENhbGxkYXRhKGFyZ3MsIGNhbGxiYWNrKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIFwiX19jb21waWxlZF9fXCIgaW4gYXJncylcbiAgICByZXR1cm4gYXJncztcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgQXJyYXkuaXNBcnJheShhcmdzWzBdKSAmJiBcIl9fY29tcGlsZWRfX1wiIGluIGFyZ3NbMF0pXG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIHJldHVybiBjYWxsYmFjaygpO1xufVxudmFyIENvbnRyYWN0ID0gY2xhc3Mge1xuICBhYmk7XG4gIGFkZHJlc3M7XG4gIHByb3ZpZGVyT3JBY2NvdW50O1xuICBkZXBsb3lUcmFuc2FjdGlvbkhhc2g7XG4gIHN0cnVjdHM7XG4gIGV2ZW50cztcbiAgZnVuY3Rpb25zO1xuICBjYWxsU3RhdGljO1xuICBwb3B1bGF0ZVRyYW5zYWN0aW9uO1xuICBlc3RpbWF0ZUZlZTtcbiAgY2FsbERhdGE7XG4gIC8qKlxuICAgKiBDb250cmFjdCBjbGFzcyB0byBoYW5kbGUgY29udHJhY3QgbWV0aG9kc1xuICAgKlxuICAgKiBAcGFyYW0gYWJpIC0gQWJpIG9mIHRoZSBjb250cmFjdCBvYmplY3RcbiAgICogQHBhcmFtIGFkZHJlc3MgKG9wdGlvbmFsKSAtIGFkZHJlc3MgdG8gY29ubmVjdCB0b1xuICAgKiBAcGFyYW0gcHJvdmlkZXJPckFjY291bnQgKG9wdGlvbmFsKSAtIFByb3ZpZGVyIG9yIEFjY291bnQgdG8gYXR0YWNoIHRvXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhYmksIGFkZHJlc3MsIHByb3ZpZGVyT3JBY2NvdW50ID0gZGVmYXVsdFByb3ZpZGVyKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcyAmJiBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm92aWRlck9yQWNjb3VudCA9IHByb3ZpZGVyT3JBY2NvdW50O1xuICAgIHRoaXMuY2FsbERhdGEgPSBuZXcgQ2FsbERhdGEoYWJpKTtcbiAgICB0aGlzLnN0cnVjdHMgPSBDYWxsRGF0YS5nZXRBYmlTdHJ1Y3QoYWJpKTtcbiAgICB0aGlzLmV2ZW50cyA9IGdldEFiaUV2ZW50cyhhYmkpO1xuICAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUFiaVBhcnNlcihhYmkpO1xuICAgIHRoaXMuYWJpID0gcGFyc2VyLmdldExlZ2FjeUZvcm1hdCgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgZnVuY3Rpb25zOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBjYWxsU3RhdGljOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBlc3RpbWF0ZUZlZTogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9XG4gICAgfSk7XG4gICAgdGhpcy5hYmkuZm9yRWFjaCgoYWJpRWxlbWVudCkgPT4ge1xuICAgICAgaWYgKGFiaUVsZW1lbnQudHlwZSAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhYmlFbGVtZW50Lm5hbWU7XG4gICAgICBpZiAoIXRoaXNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGREZWZhdWx0KHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmZ1bmN0aW9uc1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmZ1bmN0aW9ucywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGREZWZhdWx0KHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5jYWxsU3RhdGljLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZENhbGwodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkUG9wdWxhdGUodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZXN0aW1hdGVGZWVbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lc3RpbWF0ZUZlZSwgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRFc3RpbWF0ZSh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhdHRhY2goYWRkcmVzcykge1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gIH1cbiAgY29ubmVjdChwcm92aWRlck9yQWNjb3VudCkge1xuICAgIHRoaXMucHJvdmlkZXJPckFjY291bnQgPSBwcm92aWRlck9yQWNjb3VudDtcbiAgfVxuICBhc3luYyBkZXBsb3llZCgpIHtcbiAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXJPckFjY291bnQud2FpdEZvclRyYW5zYWN0aW9uKHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhc3luYyBjYWxsKG1ldGhvZCwgYXJncyA9IFtdLCB7XG4gICAgcGFyc2VSZXF1ZXN0ID0gdHJ1ZSxcbiAgICBwYXJzZVJlc3BvbnNlID0gdHJ1ZSxcbiAgICBmb3JtYXRSZXNwb25zZSA9IHZvaWQgMCxcbiAgICBibG9ja0lkZW50aWZpZXIgPSB2b2lkIDBcbiAgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJDQUxMXCIgLyogQ0FMTCAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuY29tcGlsZShtZXRob2QsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiQ2FsbCBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5jYWxsQ29udHJhY3QoXG4gICAgICB7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YSxcbiAgICAgICAgZW50cnlwb2ludDogbWV0aG9kXG4gICAgICB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgKS50aGVuKChpdCkgPT4ge1xuICAgICAgaWYgKCFwYXJzZVJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBpdDtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXRSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRGF0YS5mb3JtYXQobWV0aG9kLCBpdCwgZm9ybWF0UmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEucGFyc2UobWV0aG9kLCBpdCk7XG4gICAgfSk7XG4gIH1cbiAgaW52b2tlKG1ldGhvZCwgYXJncyA9IFtdLCB7IHBhcnNlUmVxdWVzdCA9IHRydWUsIG1heEZlZSwgbm9uY2UsIHNpZ25hdHVyZSB9ID0ge30pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldENhbGxkYXRhKGFyZ3MsICgpID0+IHtcbiAgICAgIGlmIChwYXJzZVJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIklOVk9LRVwiIC8qIElOVk9LRSAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuY29tcGlsZShtZXRob2QsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiSW52b2tlIHNraXBwZWQgcGFyc2luZyBidXQgcHJvdmlkZWQgcmF3QXJncywgcG9zc2libGUgbWFsZnVuY3Rpb24gcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH0pO1xuICAgIGNvbnN0IGludm9jYXRpb24gPSB7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGNhbGxkYXRhLFxuICAgICAgZW50cnlwb2ludDogbWV0aG9kXG4gICAgfTtcbiAgICBpZiAoXCJleGVjdXRlXCIgaW4gdGhpcy5wcm92aWRlck9yQWNjb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuZXhlY3V0ZShpbnZvY2F0aW9uLCB2b2lkIDAsIHtcbiAgICAgICAgbWF4RmVlLFxuICAgICAgICBub25jZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghbm9uY2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbmNlIGlzIHJlcXVpcmVkIHdoZW4gaW52b2tpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGFuIGFjY291bnRgKTtcbiAgICBjb25zb2xlLndhcm4oYEludm9raW5nICR7bWV0aG9kfSB3aXRob3V0IGFuIGFjY291bnQuIFRoaXMgd2lsbCBub3Qgd29yayBvbiBhIHB1YmxpYyBub2RlLmApO1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50Lmludm9rZUZ1bmN0aW9uKFxuICAgICAge1xuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICBzaWduYXR1cmVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZShtZXRob2QsIGFyZ3MgPSBbXSkge1xuICAgIGFzc2VydCh0aGlzLmFkZHJlc3MgIT09IG51bGwsIFwiY29udHJhY3QgaXMgbm90IGNvbm5lY3RlZCB0byBhbiBhZGRyZXNzXCIpO1xuICAgIGlmICghZ2V0Q2FsbGRhdGEoYXJncywgKCkgPT4gZmFsc2UpKSB7XG4gICAgICB0aGlzLmNhbGxEYXRhLnZhbGlkYXRlKFwiSU5WT0tFXCIgLyogSU5WT0tFICovLCBtZXRob2QsIGFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBpbnZvY2F0aW9uID0gdGhpcy5wb3B1bGF0ZShtZXRob2QsIGFyZ3MpO1xuICAgIGlmIChcImVzdGltYXRlSW52b2tlRmVlXCIgaW4gdGhpcy5wcm92aWRlck9yQWNjb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuZXN0aW1hdGVJbnZva2VGZWUoaW52b2NhdGlvbik7XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwiQ29udHJhY3QgbXVzdCBiZSBjb25uZWN0ZWQgdG8gdGhlIGFjY291bnQgY29udHJhY3QgdG8gZXN0aW1hdGVcIik7XG4gIH1cbiAgcG9wdWxhdGUobWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldENhbGxkYXRhKGFyZ3MsICgpID0+IHRoaXMuY2FsbERhdGEuY29tcGlsZShtZXRob2QsIGFyZ3MpKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBlbnRyeXBvaW50OiBtZXRob2QsXG4gICAgICBjYWxsZGF0YVxuICAgIH07XG4gIH1cbiAgcGFyc2VFdmVudHMocmVjZWlwdCkge1xuICAgIHJldHVybiBwYXJzZUV2ZW50cyhcbiAgICAgIHJlY2VpcHQuZXZlbnRzPy5maWx0ZXIoXG4gICAgICAgIChldmVudCkgPT4gY2xlYW5IZXgoZXZlbnQuZnJvbV9hZGRyZXNzKSA9PT0gY2xlYW5IZXgodGhpcy5hZGRyZXNzKSxcbiAgICAgICAgW11cbiAgICAgICkgfHwgW10sXG4gICAgICB0aGlzLmV2ZW50cyxcbiAgICAgIHRoaXMuc3RydWN0cyxcbiAgICAgIENhbGxEYXRhLmdldEFiaUVudW0odGhpcy5hYmkpXG4gICAgKTtcbiAgfVxuICBpc0NhaXJvMSgpIHtcbiAgICByZXR1cm4gY2Fpcm9fZXhwb3J0cy5pc0NhaXJvMUFiaSh0aGlzLmFiaSk7XG4gIH1cbiAgYXN5bmMgZ2V0VmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5nZXRDb250cmFjdFZlcnNpb24odGhpcy5hZGRyZXNzKTtcbiAgfVxuICB0eXBlZHYyKHRBYmkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLy8gc3JjL2NvbnRyYWN0L2ludGVyZmFjZS50c1xudmFyIENvbnRyYWN0SW50ZXJmYWNlID0gY2xhc3Mge1xuICBmdW5jdGlvbnM7XG4gIGNhbGxTdGF0aWM7XG4gIHBvcHVsYXRlVHJhbnNhY3Rpb247XG4gIGVzdGltYXRlRmVlO1xufTtcblxuLy8gc3JjL2NvbnRyYWN0L2NvbnRyYWN0RmFjdG9yeS50c1xudmFyIENvbnRyYWN0RmFjdG9yeSA9IGNsYXNzIHtcbiAgY29tcGlsZWRDb250cmFjdDtcbiAgYWNjb3VudDtcbiAgYWJpO1xuICBjbGFzc0hhc2g7XG4gIGNhc207XG4gIGNvbXBpbGVkQ2xhc3NIYXNoO1xuICBDYWxsRGF0YTtcbiAgLyoqXG4gICAqIEBwYXJhbSBwYXJhbXMgQ0ZQYXJhbXNcbiAgICogIC0gY29tcGlsZWRDb250cmFjdDogQ29tcGlsZWRDb250cmFjdDtcbiAgICogIC0gYWNjb3VudDogQWNjb3VudEludGVyZmFjZTtcbiAgICogIC0gY2FzbT86IENhaXJvQXNzZW1ibHk7XG4gICAqICAtIGNsYXNzSGFzaD86IHN0cmluZztcbiAgICogIC0gY29tcGlsZWRDbGFzc0hhc2g/OiBzdHJpbmc7XG4gICAqICAtIGFiaT86IEFiaTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHRoaXMuY29tcGlsZWRDb250cmFjdCA9IHBhcmFtcy5jb21waWxlZENvbnRyYWN0O1xuICAgIHRoaXMuYWNjb3VudCA9IHBhcmFtcy5hY2NvdW50O1xuICAgIHRoaXMuY2FzbSA9IHBhcmFtcy5jYXNtO1xuICAgIHRoaXMuYWJpID0gcGFyYW1zLmFiaSA/PyBwYXJhbXMuY29tcGlsZWRDb250cmFjdC5hYmk7XG4gICAgdGhpcy5jbGFzc0hhc2ggPSBwYXJhbXMuY2xhc3NIYXNoO1xuICAgIHRoaXMuY29tcGlsZWRDbGFzc0hhc2ggPSBwYXJhbXMuY29tcGlsZWRDbGFzc0hhc2g7XG4gICAgdGhpcy5DYWxsRGF0YSA9IG5ldyBDYWxsRGF0YSh0aGlzLmFiaSk7XG4gIH1cbiAgLyoqXG4gICAqIERlcGxveXMgY29udHJhY3QgYW5kIHJldHVybnMgbmV3IGluc3RhbmNlIG9mIHRoZSBDb250cmFjdFxuICAgKlxuICAgKiBJZiBjb250cmFjdCBpcyBub3QgZGVjbGFyZWQgaXQgd2lsbCBmaXJzdCBkZWNsYXJlIGl0LCBhbmQgdGhlbiBkZXBsb3lcbiAgICovXG4gIGFzeW5jIGRlcGxveSguLi5hcmdzKSB7XG4gICAgY29uc3QgeyBhcmdzOiBwYXJhbSwgb3B0aW9ucyA9IHsgcGFyc2VSZXF1ZXN0OiB0cnVlIH0gfSA9IHNwbGl0QXJnc0FuZE9wdGlvbnMoYXJncyk7XG4gICAgY29uc3QgY29uc3RydWN0b3JDYWxsZGF0YSA9IGdldENhbGxkYXRhKHBhcmFtLCAoKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZVJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5DYWxsRGF0YS52YWxpZGF0ZShcIkRFUExPWVwiIC8qIERFUExPWSAqLywgXCJjb25zdHJ1Y3RvclwiLCBwYXJhbSk7XG4gICAgICAgIHJldHVybiB0aGlzLkNhbGxEYXRhLmNvbXBpbGUoXCJjb25zdHJ1Y3RvclwiLCBwYXJhbSk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJDYWxsIHNraXBwZWQgcGFyc2luZyBidXQgcHJvdmlkZWQgcmF3QXJncywgcG9zc2libGUgbWFsZnVuY3Rpb24gcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBkZXBsb3k6IHsgY29udHJhY3RfYWRkcmVzcywgdHJhbnNhY3Rpb25faGFzaCB9XG4gICAgfSA9IGF3YWl0IHRoaXMuYWNjb3VudC5kZWNsYXJlQW5kRGVwbG95KHtcbiAgICAgIGNvbnRyYWN0OiB0aGlzLmNvbXBpbGVkQ29udHJhY3QsXG4gICAgICBjYXNtOiB0aGlzLmNhc20sXG4gICAgICBjbGFzc0hhc2g6IHRoaXMuY2xhc3NIYXNoLFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2g6IHRoaXMuY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgc2FsdDogb3B0aW9ucy5hZGRyZXNzU2FsdFxuICAgIH0pO1xuICAgIGFzc2VydChCb29sZWFuKGNvbnRyYWN0X2FkZHJlc3MpLCBcIkRlcGxveW1lbnQgb2YgdGhlIGNvbnRyYWN0IGZhaWxlZFwiKTtcbiAgICBjb25zdCBjb250cmFjdEluc3RhbmNlID0gbmV3IENvbnRyYWN0KFxuICAgICAgdGhpcy5jb21waWxlZENvbnRyYWN0LmFiaSxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICB0aGlzLmFjY291bnRcbiAgICApO1xuICAgIGNvbnRyYWN0SW5zdGFuY2UuZGVwbG95VHJhbnNhY3Rpb25IYXNoID0gdHJhbnNhY3Rpb25faGFzaDtcbiAgICByZXR1cm4gY29udHJhY3RJbnN0YW5jZTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgdG8gbmV3IEFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIGFjY291bnQgLSBuZXcgQWNjb3VudCB0byBhdHRhY2ggdG9cbiAgICovXG4gIGNvbm5lY3QoYWNjb3VudCkge1xuICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGN1cnJlbnQgYWJpIGFuZCBhY2NvdW50IHRvIHRoZSBuZXcgYWRkcmVzc1xuICAgKi9cbiAgYXR0YWNoKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gbmV3IENvbnRyYWN0KHRoaXMuYWJpLCBhZGRyZXNzLCB0aGlzLmFjY291bnQpO1xuICB9XG4gIC8vIGV0aGVycy5qcycgZ2V0RGVwbG95VHJhbnNhY3Rpb24gY2FuJ3QgYmUgc3VwcG9ydGVkIGFzIGl0IHJlcXVpcmVzIHRoZSBhY2NvdW50IG9yIHNpZ25lciB0byByZXR1cm4gYSBzaWduZWQgdHJhbnNhY3Rpb24gd2hpY2ggaXMgbm90IHBvc3NpYmxlIHdpdGggdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb25cbn07XG5cbi8vIHNyYy91dGlscy9hZGRyZXNzLnRzXG5pbXBvcnQgeyBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXMyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHNcIjtcbmZ1bmN0aW9uIGFkZEFkZHJlc3NQYWRkaW5nKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChyZW1vdmVIZXhQcmVmaXgodG9IZXgoYWRkcmVzcykpLnBhZFN0YXJ0KDY0LCBcIjBcIikpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MoYWRkcmVzcykge1xuICBhc3NlcnRJblJhbmdlKGFkZHJlc3MsIFpFUk8sIEFERFJfQk9VTkQgLSAxbiwgXCJTdGFya25ldCBBZGRyZXNzXCIpO1xuICBjb25zdCByZXN1bHQgPSBhZGRBZGRyZXNzUGFkZGluZyhhZGRyZXNzKTtcbiAgaWYgKCFyZXN1bHQubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezY0fSQvKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQWRkcmVzcyBGb3JtYXRcIik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gIGNvbnN0IGNoYXJzID0gcmVtb3ZlSGV4UHJlZml4KHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpKS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiXCIpO1xuICBjb25zdCBoZXggPSByZW1vdmVIZXhQcmVmaXgoa2VjY2FrQm4oYWRkcmVzcykpO1xuICBjb25zdCBoYXNoZWQgPSBoZXhUb0J5dGVzMihoZXgucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAoaGFzaGVkW2kgPj4gMV0gPj4gNCA+PSA4KSB7XG4gICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gJiAxNSkgPj0gOCkge1xuICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoY2hhcnMuam9pbihcIlwiKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG59XG5cbi8vIHNyYy91dGlscy91cmwudHNcbmltcG9ydCB1cmxqb2luIGZyb20gXCJ1cmwtam9pblwiO1xudmFyIHByb3RvY29sQW5kRG9tYWluUkUgPSAvXig/Olxcdys6KT9cXC9cXC8oXFxTKykkLztcbnZhciBsb2NhbGhvc3REb21haW5SRSA9IC9ebG9jYWxob3N0Wzo/XFxkXSooPzpbXjo/XFxkXVxcUyopPyQvO1xudmFyIG5vbkxvY2FsaG9zdERvbWFpblJFID0gL15bXlxccy5dK1xcLlxcU3syLH0kLztcbmZ1bmN0aW9uIGlzVXJsKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IHMubWF0Y2gocHJvdG9jb2xBbmREb21haW5SRSk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wgPSBtYXRjaFsxXTtcbiAgaWYgKCFldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkgfHwgbm9uTG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBidWlsZFVybChiYXNlVXJsLCBkZWZhdWx0UGF0aCwgdXJsT3JQYXRoKSB7XG4gIHJldHVybiBpc1VybCh1cmxPclBhdGgpID8gdXJsT3JQYXRoIDogdXJsam9pbihiYXNlVXJsLCB1cmxPclBhdGggPz8gZGVmYXVsdFBhdGgpO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBudW1iZXIgPSBudW1fZXhwb3J0cztcbmV4cG9ydCB7XG4gIEFjY291bnQsXG4gIEFjY291bnRJbnRlcmZhY2UsXG4gIEJsb2NrU3RhdHVzLFxuICBCbG9ja1RhZyxcbiAgQ2Fpcm9DdXN0b21FbnVtLFxuICBDYWlyb09wdGlvbixcbiAgQ2Fpcm9PcHRpb25WYXJpYW50LFxuICBDYWlyb1Jlc3VsdCxcbiAgQ2Fpcm9SZXN1bHRWYXJpYW50LFxuICBDYWlyb1VpbnQyNTYsXG4gIENhaXJvVWludDUxMixcbiAgQ2FsbERhdGEsXG4gIENvbnRyYWN0LFxuICBDb250cmFjdEZhY3RvcnksXG4gIENvbnRyYWN0SW50ZXJmYWNlLFxuICBDdXN0b21FcnJvcixcbiAgRW50cnlQb2ludFR5cGUsXG4gIEV0aFNpZ25lcixcbiAgR2F0ZXdheUVycm9yLFxuICBIdHRwRXJyb3IsXG4gIExpYnJhcnlFcnJvcixcbiAgTGl0ZXJhbCxcbiAgUnBjUHJvdmlkZXIyIGFzIFByb3ZpZGVyLFxuICBQcm92aWRlckludGVyZmFjZSxcbiAgYXBpX2V4cG9ydHMgYXMgUlBDLFxuICBycGNfMF82X2V4cG9ydHMgYXMgUlBDMDYsXG4gIHJwY18wXzdfZXhwb3J0cyBhcyBSUEMwNyxcbiAgUmVjZWlwdFR4LFxuICBScGNDaGFubmVsMiBhcyBScGNDaGFubmVsLFxuICBScGNQcm92aWRlcjIgYXMgUnBjUHJvdmlkZXIsXG4gIFNJTVVMQVRJT05fRkxBRyxcbiAgU2lnbmVyLFxuICBTaWduZXJJbnRlcmZhY2UsXG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBUcmFuc2FjdGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25UeXBlLFxuICBUeXBlZERhdGFSZXZpc2lvbixcbiAgVUlOVF8xMjhfTUFYLFxuICBVSU5UXzEyOF9NSU4sXG4gIFVJTlRfMjU2X0hJR0hfTUFYLFxuICBVSU5UXzI1Nl9ISUdIX01JTixcbiAgVUlOVF8yNTZfTE9XX01BWCxcbiAgVUlOVF8yNTZfTE9XX01JTixcbiAgVUlOVF8yNTZfTUFYLFxuICBVSU5UXzI1Nl9NSU4sXG4gIFVJTlRfNTEyX01BWCxcbiAgVUlOVF81MTJfTUlOLFxuICBVaW50LFxuICBWYWxpZGF0ZVR5cGUsXG4gIFdhbGxldEFjY291bnQsXG4gIGFkZEFkZHJlc3NQYWRkaW5nLFxuICBidWlsZFVybCxcbiAgYnl0ZUFycmF5X2V4cG9ydHMgYXMgYnl0ZUFycmF5LFxuICBjYWlyb19leHBvcnRzIGFzIGNhaXJvLFxuICBjb25zdGFudHNfZXhwb3J0cyBhcyBjb25zdGFudHMsXG4gIGNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdCxcbiAgZGVmYXVsdFByb3ZpZGVyLFxuICBlY19leHBvcnRzIGFzIGVjLFxuICBlbmNvZGVfZXhwb3J0cyBhcyBlbmNvZGUsXG4gIGV0aF9leHBvcnRzIGFzIGV0aCxcbiAgZXZlbnRzX2V4cG9ydHMgYXMgZXZlbnRzLFxuICBleHRyYWN0Q29udHJhY3RIYXNoZXMsXG4gIGZpeFByb3RvLFxuICBmaXhTdGFjayxcbiAgZ2V0Q2FsbGRhdGEsXG4gIGdldENoZWNrc3VtQWRkcmVzcyxcbiAgaGFzaF9leHBvcnRzIGFzIGhhc2gsXG4gIGlzU2llcnJhLFxuICBpc1VybCxcbiAganNvbl9leHBvcnRzIGFzIGpzb24sXG4gIG1lcmtsZV9leHBvcnRzIGFzIG1lcmtsZSxcbiAgbnVtX2V4cG9ydHMgYXMgbnVtLFxuICBudW1iZXIsXG4gIHBhcnNlQ2FsbGRhdGFGaWVsZCxcbiAgcGFyc2VVRENFdmVudCxcbiAgcHJvdmlkZXJfZXhwb3J0cyBhcyBwcm92aWRlcixcbiAgc2VsZWN0b3JfZXhwb3J0cyBhcyBzZWxlY3RvcixcbiAgc2hvcnRTdHJpbmdfZXhwb3J0cyBhcyBzaG9ydFN0cmluZyxcbiAgc3BsaXRBcmdzQW5kT3B0aW9ucyxcbiAgc3RhcmtfZXhwb3J0cyBhcyBzdGFyayxcbiAgc3RhcmtuZXRJZF9leHBvcnRzIGFzIHN0YXJrbmV0SWQsXG4gIHRyYW5zYWN0aW9uX2V4cG9ydHMgYXMgdHJhbnNhY3Rpb24sXG4gIHR5cGVkRGF0YV9leHBvcnRzIGFzIHR5cGVkRGF0YSxcbiAgdHlwZXNfZXhwb3J0cyBhcyB0eXBlcyxcbiAgdWludDI1Nl9leHBvcnRzIGFzIHVpbnQyNTYsXG4gIHYyX2V4cG9ydHMgYXMgdjJoYXNoLFxuICB2M19leHBvcnRzIGFzIHYzaGFzaCxcbiAgdmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MsXG4gIHZhbGlkYXRlQ2hlY2tzdW1BZGRyZXNzLFxuICBjb25uZWN0X2V4cG9ydHMgYXMgd2FsbGV0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/dist/index.mjs\n");

/***/ })

};
;