"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/starknet";
exports.ids = ["vendor-chunks/starknet"];
exports.modules = {

/***/ "(ssr)/./node_modules/starknet/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/starknet/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   BlockStatus: () => (/* binding */ BlockStatus),\n/* harmony export */   BlockTag: () => (/* binding */ BlockTag),\n/* harmony export */   CairoCustomEnum: () => (/* binding */ CairoCustomEnum),\n/* harmony export */   CairoOption: () => (/* binding */ CairoOption),\n/* harmony export */   CairoOptionVariant: () => (/* binding */ CairoOptionVariant),\n/* harmony export */   CairoResult: () => (/* binding */ CairoResult),\n/* harmony export */   CairoResultVariant: () => (/* binding */ CairoResultVariant),\n/* harmony export */   CallData: () => (/* binding */ CallData),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory),\n/* harmony export */   ContractInterface: () => (/* binding */ ContractInterface),\n/* harmony export */   CustomError: () => (/* binding */ CustomError),\n/* harmony export */   EntryPointType: () => (/* binding */ EntryPointType),\n/* harmony export */   EthSigner: () => (/* binding */ EthSigner),\n/* harmony export */   GatewayError: () => (/* binding */ GatewayError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LibraryError: () => (/* binding */ LibraryError),\n/* harmony export */   Literal: () => (/* binding */ Literal),\n/* harmony export */   Provider: () => (/* binding */ RpcProvider2),\n/* harmony export */   ProviderInterface: () => (/* binding */ ProviderInterface),\n/* harmony export */   RPC: () => (/* binding */ api_exports),\n/* harmony export */   RpcChannel: () => (/* binding */ RpcChannel),\n/* harmony export */   RpcProvider: () => (/* binding */ RpcProvider2),\n/* harmony export */   SIMULATION_FLAG: () => (/* binding */ SIMULATION_FLAG),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   SignerInterface: () => (/* binding */ SignerInterface),\n/* harmony export */   TransactionExecutionStatus: () => (/* binding */ TransactionExecutionStatus),\n/* harmony export */   TransactionFinalityStatus: () => (/* binding */ TransactionFinalityStatus),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionType: () => (/* binding */ TransactionType),\n/* harmony export */   TypedDataRevision: () => (/* binding */ TypedDataRevision),\n/* harmony export */   Uint: () => (/* binding */ Uint),\n/* harmony export */   ValidateType: () => (/* binding */ ValidateType),\n/* harmony export */   addAddressPadding: () => (/* binding */ addAddressPadding),\n/* harmony export */   buildUrl: () => (/* binding */ buildUrl),\n/* harmony export */   byteArray: () => (/* binding */ byteArray_exports),\n/* harmony export */   cairo: () => (/* binding */ cairo_exports),\n/* harmony export */   constants: () => (/* binding */ constants_exports),\n/* harmony export */   contractClassResponseToLegacyCompiledContract: () => (/* binding */ contractClassResponseToLegacyCompiledContract),\n/* harmony export */   defaultProvider: () => (/* binding */ defaultProvider),\n/* harmony export */   ec: () => (/* binding */ ec_exports),\n/* harmony export */   encode: () => (/* binding */ encode_exports),\n/* harmony export */   eth: () => (/* binding */ eth_exports),\n/* harmony export */   events: () => (/* binding */ events_exports),\n/* harmony export */   extractContractHashes: () => (/* binding */ extractContractHashes),\n/* harmony export */   fixProto: () => (/* binding */ fixProto),\n/* harmony export */   fixStack: () => (/* binding */ fixStack),\n/* harmony export */   getCalldata: () => (/* binding */ getCalldata),\n/* harmony export */   getChecksumAddress: () => (/* binding */ getChecksumAddress),\n/* harmony export */   hash: () => (/* binding */ hash_exports),\n/* harmony export */   isSierra: () => (/* binding */ isSierra),\n/* harmony export */   isUrl: () => (/* binding */ isUrl),\n/* harmony export */   json: () => (/* binding */ json_exports),\n/* harmony export */   merkle: () => (/* binding */ merkle_exports),\n/* harmony export */   num: () => (/* binding */ num_exports),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   parseUDCEvent: () => (/* binding */ parseUDCEvent),\n/* harmony export */   provider: () => (/* binding */ provider_exports),\n/* harmony export */   selector: () => (/* binding */ selector_exports),\n/* harmony export */   shortString: () => (/* binding */ shortString_exports),\n/* harmony export */   splitArgsAndOptions: () => (/* binding */ splitArgsAndOptions),\n/* harmony export */   stark: () => (/* binding */ stark_exports),\n/* harmony export */   starknetId: () => (/* binding */ starknetId_exports),\n/* harmony export */   transaction: () => (/* binding */ transaction_exports),\n/* harmony export */   typedData: () => (/* binding */ typedData_exports),\n/* harmony export */   types: () => (/* binding */ types_exports),\n/* harmony export */   uint256: () => (/* binding */ uint256_exports),\n/* harmony export */   v2hash: () => (/* binding */ v2_exports),\n/* harmony export */   v3hash: () => (/* binding */ v3_exports),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress),\n/* harmony export */   validateChecksumAddress: () => (/* binding */ validateChecksumAddress)\n/* harmony export */ });\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _scure_starknet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/@scure/starknet/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var lossless_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lossless-json */ \"(ssr)/./node_modules/lossless-json/lib/esm/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! isomorphic-fetch */ \"(ssr)/./node_modules/isomorphic-fetch/fetch-npm-node.js\");\n/* harmony import */ var ts_mixer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ts-mixer */ \"(ssr)/./node_modules/ts-mixer/dist/esm/index.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! url-join */ \"(ssr)/./node_modules/url-join/lib/url-join.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\n// src/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n    ADDR_BOUND: ()=>ADDR_BOUND,\n    API_VERSION: ()=>API_VERSION,\n    BaseUrl: ()=>BaseUrl,\n    IS_BROWSER: ()=>IS_BROWSER,\n    MASK_250: ()=>MASK_250,\n    MAX_STORAGE_ITEM_SIZE: ()=>MAX_STORAGE_ITEM_SIZE,\n    NetworkName: ()=>NetworkName,\n    RPC_DEFAULT_VERSION: ()=>RPC_DEFAULT_VERSION,\n    RPC_NODES: ()=>RPC_NODES,\n    StarknetChainId: ()=>StarknetChainId,\n    TEXT_TO_FELT_MAX_LEN: ()=>TEXT_TO_FELT_MAX_LEN,\n    TRANSACTION_VERSION: ()=>ETransactionVersion,\n    TransactionHashPrefix: ()=>TransactionHashPrefix,\n    UDC: ()=>UDC,\n    ZERO: ()=>ZERO\n});\n// src/types/api/index.ts\nvar api_exports = {};\n__export(api_exports, {\n    EBlockTag: ()=>EBlockTag,\n    EDAMode: ()=>EDAMode,\n    EDataAvailabilityMode: ()=>EDataAvailabilityMode,\n    ESimulationFlag: ()=>ESimulationFlag,\n    ETransactionExecutionStatus: ()=>ETransactionExecutionStatus,\n    ETransactionFinalityStatus: ()=>ETransactionFinalityStatus,\n    ETransactionStatus: ()=>ETransactionStatus,\n    ETransactionType: ()=>ETransactionType,\n    ETransactionVersion: ()=>ETransactionVersion,\n    ETransactionVersion2: ()=>ETransactionVersion2,\n    ETransactionVersion3: ()=>ETransactionVersion3,\n    Errors: ()=>errors_exports,\n    JRPC: ()=>jsonrpc_exports,\n    SPEC: ()=>components_exports\n});\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n// src/types/api/rpcspec_0_6/errors.ts\nvar errors_exports = {};\n// src/types/api/rpcspec_0_6/components.ts\nvar components_exports = {};\n// src/types/api/rpcspec_0_6/nonspec.ts\nvar ETransactionType = /* @__PURE__ */ ((ETransactionType2)=>{\n    ETransactionType2[\"DECLARE\"] = \"DECLARE\";\n    ETransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    ETransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    ETransactionType2[\"INVOKE\"] = \"INVOKE\";\n    ETransactionType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    return ETransactionType2;\n})(ETransactionType || {});\nvar ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2)=>{\n    ESimulationFlag2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    ESimulationFlag2[\"SKIP_FEE_CHARGE\"] = \"SKIP_FEE_CHARGE\";\n    return ESimulationFlag2;\n})(ESimulationFlag || {});\nvar ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2)=>{\n    ETransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    ETransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    ETransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionStatus2;\n})(ETransactionStatus || {});\nvar ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2)=>{\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionFinalityStatus2;\n})(ETransactionFinalityStatus || {});\nvar ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2)=>{\n    ETransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    ETransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return ETransactionExecutionStatus2;\n})(ETransactionExecutionStatus || {});\nvar EBlockTag = /* @__PURE__ */ ((EBlockTag2)=>{\n    EBlockTag2[\"LATEST\"] = \"latest\";\n    EBlockTag2[\"PENDING\"] = \"pending\";\n    return EBlockTag2;\n})(EBlockTag || {});\nvar EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode2)=>{\n    EDataAvailabilityMode2[\"L1\"] = \"L1\";\n    EDataAvailabilityMode2[\"L2\"] = \"L2\";\n    return EDataAvailabilityMode2;\n})(EDataAvailabilityMode || {});\nvar EDAMode = /* @__PURE__ */ ((EDAMode3)=>{\n    EDAMode3[EDAMode3[\"L1\"] = 0] = \"L1\";\n    EDAMode3[EDAMode3[\"L2\"] = 1] = \"L2\";\n    return EDAMode3;\n})(EDAMode || {});\nvar ETransactionVersion = /* @__PURE__ */ ((ETransactionVersion4)=>{\n    ETransactionVersion4[\"V0\"] = \"0x0\";\n    ETransactionVersion4[\"V1\"] = \"0x1\";\n    ETransactionVersion4[\"V2\"] = \"0x2\";\n    ETransactionVersion4[\"V3\"] = \"0x3\";\n    ETransactionVersion4[\"F0\"] = \"0x100000000000000000000000000000000\";\n    ETransactionVersion4[\"F1\"] = \"0x100000000000000000000000000000001\";\n    ETransactionVersion4[\"F2\"] = \"0x100000000000000000000000000000002\";\n    ETransactionVersion4[\"F3\"] = \"0x100000000000000000000000000000003\";\n    return ETransactionVersion4;\n})(ETransactionVersion || {});\nvar ETransactionVersion2 = /* @__PURE__ */ ((ETransactionVersion23)=>{\n    ETransactionVersion23[\"V0\"] = \"0x0\";\n    ETransactionVersion23[\"V1\"] = \"0x1\";\n    ETransactionVersion23[\"V2\"] = \"0x2\";\n    ETransactionVersion23[\"F0\"] = \"0x100000000000000000000000000000000\";\n    ETransactionVersion23[\"F1\"] = \"0x100000000000000000000000000000001\";\n    ETransactionVersion23[\"F2\"] = \"0x100000000000000000000000000000002\";\n    return ETransactionVersion23;\n})(ETransactionVersion2 || {});\nvar ETransactionVersion3 = /* @__PURE__ */ ((ETransactionVersion33)=>{\n    ETransactionVersion33[\"V3\"] = \"0x3\";\n    ETransactionVersion33[\"F3\"] = \"0x100000000000000000000000000000003\";\n    return ETransactionVersion33;\n})(ETransactionVersion3 || {});\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n    IS_BROWSER: ()=>IS_BROWSER,\n    addHexPrefix: ()=>addHexPrefix,\n    arrayBufferToString: ()=>arrayBufferToString,\n    atobUniversal: ()=>atobUniversal,\n    btoaUniversal: ()=>btoaUniversal,\n    buf2hex: ()=>buf2hex,\n    calcByteLength: ()=>calcByteLength,\n    padLeft: ()=>padLeft,\n    pascalToSnake: ()=>pascalToSnake,\n    removeHexPrefix: ()=>removeHexPrefix,\n    sanitizeBytes: ()=>sanitizeBytes,\n    sanitizeHex: ()=>sanitizeHex,\n    stringToArrayBuffer: ()=>stringToArrayBuffer,\n    utf8ToArray: ()=>utf8ToArray\n});\n\nvar IS_BROWSER = \"undefined\" !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n    return new Uint8Array(array).reduce((data, byte)=>data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n    return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n    return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n    return _scure_base__WEBPACK_IMPORTED_MODULE_0__.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n    return _scure_base__WEBPACK_IMPORTED_MODULE_0__.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n    return buffer.reduce((r, x)=>r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n    return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n    return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n    const diff = length - str.length;\n    let result = str;\n    if (diff > 0) {\n        const pad = padding.repeat(diff);\n        result = left ? pad + str : str + pad;\n    }\n    return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n    return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n    const { length } = str;\n    const remainder = length % byteSize;\n    return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n    return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n    hex = removeHexPrefix(hex);\n    hex = sanitizeBytes(hex, 2);\n    if (hex) {\n        hex = addHexPrefix(hex);\n    }\n    return hex;\n}\nvar pascalToSnake = (text)=>/[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\n// src/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar API_VERSION = ZERO;\nvar MAX_STORAGE_ITEM_SIZE = 256n;\nvar ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2)=>{\n    BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n    BaseUrl2[\"SN_GOERLI\"] = \"https://alpha4.starknet.io\";\n    BaseUrl2[\"SN_SEPOLIA\"] = \"https://alpha-sepolia.starknet.io\";\n    return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2)=>{\n    NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n    NetworkName2[\"SN_GOERLI\"] = \"SN_GOERLI\";\n    NetworkName2[\"SN_SEPOLIA\"] = \"SN_SEPOLIA\";\n    return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId5)=>{\n    StarknetChainId5[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n    StarknetChainId5[\"SN_GOERLI\"] = \"0x534e5f474f45524c49\";\n    StarknetChainId5[\"SN_SEPOLIA\"] = \"0x534e5f5345504f4c4941\";\n    return StarknetChainId5;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2)=>{\n    TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n    TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n    TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n    TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n    TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n    return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar UDC = {\n    ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n    ENTRYPOINT: \"deployContract\"\n};\nvar RPC_DEFAULT_VERSION = \"v0_6\";\nvar RPC_NODES = {\n    SN_GOERLI: [\n        `https://starknet-testnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n        `https://free-rpc.nethermind.io/goerli-juno/${RPC_DEFAULT_VERSION}`\n    ],\n    SN_MAIN: [\n        `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n        `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`\n    ],\n    SN_SEPOLIA: [\n        `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n        `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`\n    ]\n};\n// src/provider/errors.ts\nfunction fixStack(target, fn = target.constructor) {\n    const { captureStackTrace } = Error;\n    captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n    const { setPrototypeOf } = Object;\n    setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n    constructor(message){\n        super(message);\n        Object.defineProperty(this, \"name\", {\n            value: new.target.name,\n            enumerable: false,\n            configurable: true\n        });\n        fixProto(this, new.target.prototype);\n        fixStack(this);\n    }\n};\nvar LibraryError = class extends CustomError {\n};\nvar GatewayError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\nvar HttpError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n    BlockStatus: ()=>BlockStatus,\n    BlockTag: ()=>BlockTag,\n    EntryPointType: ()=>EntryPointType,\n    Literal: ()=>Literal,\n    RPC: ()=>api_exports,\n    SIMULATION_FLAG: ()=>SIMULATION_FLAG,\n    TransactionExecutionStatus: ()=>TransactionExecutionStatus,\n    TransactionFinalityStatus: ()=>TransactionFinalityStatus,\n    TransactionStatus: ()=>TransactionStatus,\n    TransactionType: ()=>TransactionType,\n    TypedDataRevision: ()=>TypedDataRevision,\n    Uint: ()=>Uint,\n    ValidateType: ()=>ValidateType\n});\n// src/types/account.ts\nvar SIMULATION_FLAG = /* @__PURE__ */ ((SIMULATION_FLAG2)=>{\n    SIMULATION_FLAG2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    SIMULATION_FLAG2[\"SKIP_EXECUTE\"] = \"SKIP_EXECUTE\";\n    return SIMULATION_FLAG2;\n})(SIMULATION_FLAG || {});\n// src/types/calldata.ts\nvar ValidateType = /* @__PURE__ */ ((ValidateType2)=>{\n    ValidateType2[\"DEPLOY\"] = \"DEPLOY\";\n    ValidateType2[\"CALL\"] = \"CALL\";\n    ValidateType2[\"INVOKE\"] = \"INVOKE\";\n    return ValidateType2;\n})(ValidateType || {});\nvar Uint = /* @__PURE__ */ ((Uint2)=>{\n    Uint2[\"u8\"] = \"core::integer::u8\";\n    Uint2[\"u16\"] = \"core::integer::u16\";\n    Uint2[\"u32\"] = \"core::integer::u32\";\n    Uint2[\"u64\"] = \"core::integer::u64\";\n    Uint2[\"u128\"] = \"core::integer::u128\";\n    Uint2[\"u256\"] = \"core::integer::u256\";\n    return Uint2;\n})(Uint || {});\nvar Literal = /* @__PURE__ */ ((Literal2)=>{\n    Literal2[\"ClassHash\"] = \"core::starknet::class_hash::ClassHash\";\n    Literal2[\"ContractAddress\"] = \"core::starknet::contract_address::ContractAddress\";\n    return Literal2;\n})(Literal || {});\n// src/types/lib/contract/index.ts\nvar EntryPointType = /* @__PURE__ */ ((EntryPointType2)=>{\n    EntryPointType2[\"EXTERNAL\"] = \"EXTERNAL\";\n    EntryPointType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    EntryPointType2[\"CONSTRUCTOR\"] = \"CONSTRUCTOR\";\n    return EntryPointType2;\n})(EntryPointType || {});\n// src/types/lib/index.ts\nvar TransactionType = /* @__PURE__ */ ((TransactionType2)=>{\n    TransactionType2[\"DECLARE\"] = \"DECLARE\";\n    TransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    TransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    TransactionType2[\"INVOKE\"] = \"INVOKE_FUNCTION\";\n    return TransactionType2;\n})(TransactionType || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2)=>{\n    TransactionStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    TransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return TransactionStatus2;\n})(TransactionStatus || {});\nvar TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2)=>{\n    TransactionFinalityStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionFinalityStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return TransactionFinalityStatus2;\n})(TransactionFinalityStatus || {});\nvar TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2)=>{\n    TransactionExecutionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    TransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    return TransactionExecutionStatus2;\n})(TransactionExecutionStatus || {});\nvar BlockStatus = /* @__PURE__ */ ((BlockStatus2)=>{\n    BlockStatus2[\"PENDING\"] = \"PENDING\";\n    BlockStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    BlockStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    BlockStatus2[\"REJECTED\"] = \"REJECTED\";\n    return BlockStatus2;\n})(BlockStatus || {});\nvar BlockTag = /* @__PURE__ */ ((BlockTag2)=>{\n    BlockTag2[\"pending\"] = \"pending\";\n    BlockTag2[\"latest\"] = \"latest\";\n    return BlockTag2;\n})(BlockTag || {});\n// src/types/typedData.ts\nvar TypedDataRevision = /* @__PURE__ */ ((TypedDataRevision2)=>{\n    TypedDataRevision2[\"Active\"] = \"1\";\n    TypedDataRevision2[\"Legacy\"] = \"0\";\n    return TypedDataRevision2;\n})(TypedDataRevision || {});\n// src/utils/assert.ts\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failure\");\n    }\n}\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n    addPercent: ()=>addPercent,\n    assertInRange: ()=>assertInRange,\n    bigNumberishArrayToDecimalStringArray: ()=>bigNumberishArrayToDecimalStringArray,\n    bigNumberishArrayToHexadecimalStringArray: ()=>bigNumberishArrayToHexadecimalStringArray,\n    cleanHex: ()=>cleanHex,\n    getDecimalString: ()=>getDecimalString,\n    getHexString: ()=>getHexString,\n    getHexStringArray: ()=>getHexStringArray,\n    hexToBytes: ()=>hexToBytes,\n    hexToDecimalString: ()=>hexToDecimalString,\n    isBigInt: ()=>isBigInt,\n    isHex: ()=>isHex,\n    isStringWholeNumber: ()=>isStringWholeNumber,\n    toBigInt: ()=>toBigInt,\n    toCairoBool: ()=>toCairoBool,\n    toHex: ()=>toHex,\n    toHexString: ()=>toHexString,\n    toStorageKey: ()=>toStorageKey\n});\n\nfunction isHex(hex) {\n    return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n    return BigInt(value);\n}\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\nfunction toHex(number2) {\n    return addHexPrefix(toBigInt(number2).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n    const res = addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n    return res;\n}\nfunction hexToDecimalString(hex) {\n    return BigInt(addHexPrefix(hex)).toString(10);\n}\nvar cleanHex = (hex)=>hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n    const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n    const inputBigInt = BigInt(input);\n    const lowerBoundBigInt = BigInt(lowerBound);\n    const upperBoundBigInt = BigInt(upperBound);\n    assert(inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt, `Message not signable, ${messageSuffix}.`);\n}\nfunction bigNumberishArrayToDecimalStringArray(rawCalldata) {\n    return rawCalldata.map((x)=>toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(rawCalldata) {\n    return rawCalldata.map((x)=>toHex(x));\n}\nvar isStringWholeNumber = (value)=>/^\\d+$/.test(value);\nfunction getDecimalString(value) {\n    if (isHex(value)) {\n        return hexToDecimalString(value);\n    }\n    if (isStringWholeNumber(value)) {\n        return value;\n    }\n    throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexString(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexStringArray(value) {\n    return value.map((el)=>getHexString(el));\n}\nvar toCairoBool = (value)=>(+value).toString();\nfunction hexToBytes(value) {\n    if (!isHex(value)) throw new Error(`${value} need to be a hex-string`);\n    let adaptedValue = removeHexPrefix(value);\n    if (adaptedValue.length % 2 !== 0) {\n        adaptedValue = `0${adaptedValue}`;\n    }\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(adaptedValue);\n}\nfunction addPercent(number2, percent) {\n    const bigIntNum = BigInt(number2);\n    return bigIntNum + bigIntNum * BigInt(percent) / 100n;\n}\n// src/utils/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    keccakBn: ()=>keccakBn,\n    starknetKeccak: ()=>starknetKeccak\n});\n\nfunction keccakBn(value) {\n    const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n    const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n    return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n    return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n    const hash = BigInt(keccakHex(str));\n    return hash & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n    return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    return getSelectorFromName(value);\n}\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n    decodeShortString: ()=>decodeShortString,\n    encodeShortString: ()=>encodeShortString,\n    isASCII: ()=>isASCII,\n    isDecimalString: ()=>isDecimalString,\n    isLongText: ()=>isLongText,\n    isShortString: ()=>isShortString,\n    isShortText: ()=>isShortText,\n    isText: ()=>isText,\n    splitLongString: ()=>splitLongString\n});\nfunction isASCII(str) {\n    return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n    return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n    return /^[0-9]*$/i.test(str);\n}\nfunction isText(val) {\n    return typeof val === \"string\" && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val)=>isText(val) && isShortString(val);\nvar isLongText = (val)=>isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n    const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n    return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (!isShortString(str)) throw new Error(`${str} is too long`);\n    return addHexPrefix(str.replace(/./g, (char)=>char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (isHex(str)) {\n        return removeHexPrefix(str).replace(/.{2}/g, (hex)=>String.fromCharCode(parseInt(hex, 16)));\n    }\n    if (isDecimalString(str)) {\n        return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n    }\n    throw new Error(`${str} is not Hex or decimal`);\n}\n// src/utils/calldata/byteArray.ts\nvar byteArray_exports = {};\n__export(byteArray_exports, {\n    byteArrayFromString: ()=>byteArrayFromString,\n    stringFromByteArray: ()=>stringFromByteArray\n});\nfunction stringFromByteArray(myByteArray) {\n    const pending_word = BigInt(myByteArray.pending_word) === 0n ? \"\" : decodeShortString(toHex(myByteArray.pending_word));\n    return myByteArray.data.reduce((cumuledString, encodedString)=>{\n        const add = BigInt(encodedString) === 0n ? \"\" : decodeShortString(toHex(encodedString));\n        return cumuledString + add;\n    }, \"\") + pending_word;\n}\nfunction byteArrayFromString(myString) {\n    if (myString.length === 0) {\n        return {\n            data: [\n                \"0x00\"\n            ],\n            pending_word: \"0x00\",\n            pending_word_len: 0\n        };\n    }\n    const myShortStrings = splitLongString(myString);\n    const remains = myShortStrings[myShortStrings.length - 1];\n    const myShortStringsEncoded = myShortStrings.map((shortStr)=>encodeShortString(shortStr));\n    if (remains.length === 31) {\n        return {\n            data: myShortStringsEncoded,\n            pending_word: \"0x00\",\n            pending_word_len: 0\n        };\n    }\n    const pendingEncodedWord = myShortStringsEncoded.pop();\n    return {\n        data: myShortStringsEncoded.length === 0 ? [\n            \"0x00\"\n        ] : myShortStringsEncoded,\n        pending_word: pendingEncodedWord,\n        pending_word_len: remains.length\n    };\n}\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n    felt: ()=>felt,\n    getAbiContractVersion: ()=>getAbiContractVersion,\n    getArrayType: ()=>getArrayType,\n    isCairo1Abi: ()=>isCairo1Abi,\n    isCairo1Type: ()=>isCairo1Type,\n    isLen: ()=>isLen,\n    isTypeArray: ()=>isTypeArray,\n    isTypeBool: ()=>isTypeBool,\n    isTypeByteArray: ()=>isTypeByteArray,\n    isTypeBytes31: ()=>isTypeBytes31,\n    isTypeContractAddress: ()=>isTypeContractAddress,\n    isTypeEnum: ()=>isTypeEnum,\n    isTypeEthAddress: ()=>isTypeEthAddress,\n    isTypeFelt: ()=>isTypeFelt,\n    isTypeLiteral: ()=>isTypeLiteral,\n    isTypeNamedTuple: ()=>isTypeNamedTuple,\n    isTypeOption: ()=>isTypeOption,\n    isTypeResult: ()=>isTypeResult,\n    isTypeStruct: ()=>isTypeStruct,\n    isTypeTuple: ()=>isTypeTuple,\n    isTypeUint: ()=>isTypeUint,\n    isTypeUint256: ()=>isTypeUint256,\n    tuple: ()=>tuple,\n    uint256: ()=>uint256\n});\n// src/utils/cairoDataTypes/felt.ts\nfunction CairoFelt(it) {\n    if (isBigInt(it) || typeof it === \"number\" && Number.isInteger(it)) {\n        return it.toString();\n    }\n    if (isText(it)) {\n        if (!isShortString(it)) throw new Error(`${it} is a long string > 31 chars, felt can store short strings, split it to array of short strings`);\n        const encoded = encodeShortString(it);\n        return BigInt(encoded).toString();\n    }\n    if (typeof it === \"string\" && isHex(it)) {\n        return BigInt(it).toString();\n    }\n    if (typeof it === \"string\" && isStringWholeNumber(it)) {\n        return it;\n    }\n    if (typeof it === \"boolean\") {\n        return `${+it}`;\n    }\n    throw new Error(`${it} can't be computed by felt()`);\n}\n// src/utils/cairoDataTypes/uint256.ts\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nvar UINT_256_MIN = 0n;\nvar UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_LOW_MIN = 0n;\nvar UINT_256_HIGH_MIN = 0n;\nvar _CairoUint256 = class {\n    constructor(...arr){\n        if (typeof arr[0] === \"object\" && arr.length === 1 && \"low\" in arr[0] && \"high\" in arr[0]) {\n            const props = _CairoUint256.validateProps(arr[0].low, arr[0].high);\n            this.low = props.low;\n            this.high = props.high;\n        } else if (arr.length === 1) {\n            const bigInt = _CairoUint256.validate(arr[0]);\n            this.low = bigInt & UINT_128_MAX;\n            this.high = bigInt >> 128n;\n        } else if (arr.length === 2) {\n            const props = _CairoUint256.validateProps(arr[0], arr[1]);\n            this.low = props.low;\n            this.high = props.high;\n        } else {\n            throw Error(\"Incorrect constructor parameters\");\n        }\n    }\n    /**\n   * Validate if BigNumberish can be represented as Unit256\n   */ static validate(bigNumberish) {\n        const bigInt = BigInt(bigNumberish);\n        if (bigInt < UINT_256_MIN) throw Error(\"bigNumberish is smaller than UINT_256_MIN\");\n        if (bigInt > UINT_256_MAX) throw new Error(\"bigNumberish is bigger than UINT_256_MAX\");\n        return bigInt;\n    }\n    /**\n   * Validate if low and high can be represented as Unit256\n   */ static validateProps(low, high) {\n        const bigIntLow = BigInt(low);\n        const bigIntHigh = BigInt(high);\n        if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {\n            throw new Error(\"low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX\");\n        }\n        if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {\n            throw new Error(\"high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX\");\n        }\n        return {\n            low: bigIntLow,\n            high: bigIntHigh\n        };\n    }\n    /**\n   * Check if BigNumberish can be represented as Unit256\n   */ static is(bigNumberish) {\n        try {\n            _CairoUint256.validate(bigNumberish);\n        } catch (error) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Check if provided abi type is this data type\n   */ static isAbiType(abiType) {\n        return abiType === _CairoUint256.abiSelector;\n    }\n    /**\n   * Return bigint representation\n   */ toBigInt() {\n        return (this.high << 128n) + this.low;\n    }\n    /**\n   * Return Uint256 structure with HexString props\n   * {low: HexString, high: HexString}\n   */ toUint256HexString() {\n        return {\n            low: addHexPrefix(this.low.toString(16)),\n            high: addHexPrefix(this.high.toString(16))\n        };\n    }\n    /**\n   * Return Uint256 structure with DecimalString props\n   * {low: DecString, high: DecString}\n   */ toUint256DecimalString() {\n        return {\n            low: this.low.toString(10),\n            high: this.high.toString(10)\n        };\n    }\n    /**\n   * Return api requests representation witch is felt array\n   */ toApiRequest() {\n        return [\n            CairoFelt(this.low),\n            CairoFelt(this.high)\n        ];\n    }\n};\nvar CairoUint256 = _CairoUint256;\n__publicField(CairoUint256, \"abiSelector\", \"core::integer::u256\");\n// src/utils/calldata/cairo.ts\nvar isLen = (name)=>/_len$/.test(name);\nvar isTypeFelt = (type)=>type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type)=>/\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type)=>/^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type)=>/\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs)=>type in structs;\nvar isTypeEnum = (type, enums)=>type in enums;\nvar isTypeOption = (type)=>type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type)=>type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type)=>Object.values(Uint).includes(type);\nvar isTypeUint256 = (type)=>CairoUint256.isAbiType(type);\nvar isTypeLiteral = (type)=>Object.values(Literal).includes(type);\nvar isTypeBool = (type)=>type === \"core::bool\";\nvar isTypeContractAddress = (type)=>type === \"core::starknet::contract_address::ContractAddress\";\nvar isTypeEthAddress = (type)=>type === \"core::starknet::eth_address::EthAddress\";\nvar isTypeBytes31 = (type)=>type === \"core::bytes_31::bytes31\";\nvar isTypeByteArray = (type)=>type === \"core::byte_array::ByteArray\";\nvar isCairo1Type = (type)=>type.includes(\"::\");\nvar getArrayType = (type)=>{\n    if (isCairo1Type(type)) {\n        return type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\"));\n    }\n    return type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n    const { cairo } = getAbiContractVersion(abi);\n    if (cairo === void 0) {\n        throw Error(\"Unable to determine Cairo version\");\n    }\n    return cairo === \"1\";\n}\nfunction getAbiContractVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) {\n        return {\n            cairo: \"1\",\n            compiler: \"2\"\n        };\n    }\n    const testFunction = abi.find((it)=>it.type === \"function\" && (it.inputs.length || it.outputs.length));\n    if (!testFunction) {\n        return {\n            cairo: void 0,\n            compiler: void 0\n        };\n    }\n    const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n    if (isCairo1Type(io[0].type)) {\n        return {\n            cairo: \"1\",\n            compiler: \"1\"\n        };\n    }\n    return {\n        cairo: \"0\",\n        compiler: \"0\"\n    };\n}\nvar uint256 = (it)=>{\n    return new CairoUint256(it).toUint256DecimalString();\n};\nvar tuple = (...args)=>({\n        ...args\n    });\nfunction felt(it) {\n    return CairoFelt(it);\n}\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n    /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */ constructor(enumContent){\n        const variantsList = Object.values(enumContent);\n        if (variantsList.length === 0) {\n            throw new Error(\"This Enum must have at least 1 variant\");\n        }\n        const nbActiveVariants = variantsList.filter((content)=>typeof content !== \"undefined\").length;\n        if (nbActiveVariants !== 1) {\n            throw new Error(\"This Enum must have exactly one active variant\");\n        }\n        this.variant = enumContent;\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */ unwrap() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return void 0;\n        }\n        return activeVariant[1];\n    }\n    /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */ activeVariant() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return \"\";\n        }\n        return activeVariant[0];\n    }\n};\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2)=>{\n    CairoOptionVariant2[CairoOptionVariant2[\"Some\"] = 0] = \"Some\";\n    CairoOptionVariant2[CairoOptionVariant2[\"None\"] = 1] = \"None\";\n    return CairoOptionVariant2;\n})(CairoOptionVariant || {});\nvar CairoOption = class {\n    constructor(variant, someContent){\n        if (!(variant in CairoOptionVariant)) {\n            throw new Error(\"Wrong variant : should be CairoOptionVariant.Some or .None.\");\n        }\n        if (variant === 0 /* Some */ ) {\n            if (typeof someContent === \"undefined\") {\n                throw new Error('The creation of a Cairo Option with \"Some\" variant needs a content as input.');\n            }\n            this.Some = someContent;\n            this.None = void 0;\n        } else {\n            this.Some = void 0;\n            this.None = true;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */ unwrap() {\n        if (this.None) {\n            return void 0;\n        }\n        return this.Some;\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */ isSome() {\n        return !(typeof this.Some === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */ isNone() {\n        return this.None === true;\n    }\n};\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2)=>{\n    CairoResultVariant2[CairoResultVariant2[\"Ok\"] = 0] = \"Ok\";\n    CairoResultVariant2[CairoResultVariant2[\"Err\"] = 1] = \"Err\";\n    return CairoResultVariant2;\n})(CairoResultVariant || {});\nvar CairoResult = class {\n    constructor(variant, resultContent){\n        if (!(variant in CairoResultVariant)) {\n            throw new Error(\"Wrong variant : should be CairoResultVariant.Ok or .Err.\");\n        }\n        if (variant === 0 /* Ok */ ) {\n            this.Ok = resultContent;\n            this.Err = void 0;\n        } else {\n            this.Ok = void 0;\n            this.Err = resultContent;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */ unwrap() {\n        if (typeof this.Ok !== \"undefined\") {\n            return this.Ok;\n        }\n        if (typeof this.Err !== \"undefined\") {\n            return this.Err;\n        }\n        throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */ isOk() {\n        return !(typeof this.Ok === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */ isErr() {\n        return !(typeof this.Err === \"undefined\");\n    }\n};\n// src/utils/calldata/formatter.ts\nvar guard = {\n    isBN: (data, type, key)=>{\n        if (!isBigInt(data[key])) throw new Error(`Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`);\n    },\n    unknown: (data, type, key)=>{\n        throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n    }\n};\nfunction formatter(data, type, sameType) {\n    return Object.entries(data).reduce((acc, [key, value])=>{\n        const elType = sameType ?? type[key];\n        if (!(key in type) && !sameType) {\n            acc[key] = value;\n            return acc;\n        }\n        if (elType === \"string\") {\n            if (Array.isArray(data[key])) {\n                const arrayStr = formatter(data[key], data[key].map((_)=>elType));\n                acc[key] = Object.values(arrayStr).join(\"\");\n                return acc;\n            }\n            guard.isBN(data, type, key);\n            acc[key] = decodeShortString(value);\n            return acc;\n        }\n        if (elType === \"number\") {\n            guard.isBN(data, type, key);\n            acc[key] = Number(value);\n            return acc;\n        }\n        if (typeof elType === \"function\") {\n            acc[key] = elType(value);\n            return acc;\n        }\n        if (Array.isArray(elType)) {\n            const arrayObj = formatter(data[key], elType, elType[0]);\n            acc[key] = Object.values(arrayObj);\n            return acc;\n        }\n        if (typeof elType === \"object\") {\n            acc[key] = formatter(data[key], elType);\n            return acc;\n        }\n        guard.unknown(data, type, key);\n        return acc;\n    }, {});\n}\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.reduce((acc, input)=>!isLen(input.name) ? acc + 1 : acc, 0);\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        return this.abi.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi;\n    }\n};\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.length;\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        const intf = this.abi.find((it)=>it.type === \"interface\");\n        return intf.items.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi.flatMap((e)=>{\n            if (e.type === \"interface\") {\n                return e.items;\n            }\n            return e;\n        });\n    }\n};\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n    const version = getAbiVersion(abi);\n    if (version === 0 || version === 1) {\n        return new AbiParser1(abi);\n    }\n    if (version === 2) {\n        return new AbiParser2(abi);\n    }\n    throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) return 2;\n    if (isCairo1Abi(abi)) return 1;\n    return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n    return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n    const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n    const type = namedTuple.substring(name.length + \":\".length);\n    return {\n        name,\n        type\n    };\n}\nfunction parseSubTuple(s) {\n    if (!s.includes(\"(\")) return {\n        subTuple: [],\n        result: s\n    };\n    const subTuple = [];\n    let result = \"\";\n    let i = 0;\n    while(i < s.length){\n        if (s[i] === \"(\") {\n            let counter = 1;\n            const lBracket = i;\n            i++;\n            while(counter){\n                if (s[i] === \")\") counter--;\n                if (s[i] === \"(\") counter++;\n                i++;\n            }\n            subTuple.push(s.substring(lBracket, i));\n            result += \" \";\n            i--;\n        } else {\n            result += s[i];\n        }\n        i++;\n    }\n    return {\n        subTuple,\n        result\n    };\n}\nfunction extractCairo0Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    let recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    if (isTypeNamedTuple(type)) {\n        recomposed = recomposed.reduce((acc, it)=>{\n            return acc.concat(parseNamedTuple(it));\n        }, []);\n    }\n    return recomposed;\n}\nfunction extractCairo1Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    const recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    return recomposed;\n}\nfunction extractTupleMemberTypes(type) {\n    if (isCairo1Type(type)) {\n        return extractCairo1Tuple(type);\n    }\n    return extractCairo0Tuple(type);\n}\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n    return Error(`Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`);\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n    const orderInput = (unorderedItem, abiType)=>{\n        if (isTypeArray(abiType)) {\n            return orderArray(unorderedItem, abiType);\n        }\n        if (isTypeEnum(abiType, enums)) {\n            const abiObj = enums[abiType];\n            return orderEnum(unorderedItem, abiObj);\n        }\n        if (isTypeTuple(abiType)) {\n            return orderTuple(unorderedItem, abiType);\n        }\n        if (isTypeEthAddress(abiType)) {\n            return unorderedItem;\n        }\n        if (isTypeByteArray(abiType)) {\n            return unorderedItem;\n        }\n        if (CairoUint256.isAbiType(abiType)) {\n            const u256 = unorderedItem;\n            if (typeof u256 !== \"object\") {\n                return u256;\n            }\n            if (!(\"low\" in u256 && \"high\" in u256)) {\n                throw errorU256(abiType);\n            }\n            return {\n                low: u256.low,\n                high: u256.high\n            };\n        }\n        if (isTypeStruct(abiType, structs)) {\n            const abiOfStruct = structs[abiType].members;\n            return orderStruct(unorderedItem, abiOfStruct);\n        }\n        return unorderedItem;\n    };\n    const orderStruct = (unorderedObject2, abiObject)=>{\n        const orderedObject2 = abiObject.reduce((orderedObject, abiParam)=>{\n            const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[abiParam.name]\n                });\n            if (unorderedObject2[abiParam.name] === \"undefined\") {\n                if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n                    throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n                }\n            }\n            setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    };\n    function orderArray(myArray, abiParam) {\n        const typeInArray = getArrayType(abiParam);\n        if (typeof myArray === \"string\") {\n            return myArray;\n        }\n        return myArray.map((myElem)=>orderInput(myElem, typeInArray));\n    }\n    function orderTuple(unorderedObject2, abiParam) {\n        const typeList = extractTupleMemberTypes(abiParam);\n        const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index)=>{\n            const myObjKeys = Object.keys(unorderedObject2);\n            const setProperty = (value)=>Object.defineProperty(orderedObject, index.toString(), {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[myObjKeys[index]]\n                });\n            const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n            setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    }\n    const orderEnum = (unorderedObject2, abiObject)=>{\n        if (isTypeResult(abiObject.name)) {\n            const unorderedResult = unorderedObject2;\n            const resultOkType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\",\"));\n            const resultErrType = abiObject.name.substring(abiObject.name.indexOf(\",\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedResult.isOk()) {\n                return new CairoResult(0 /* Ok */ , orderInput(unorderedObject2.unwrap(), resultOkType));\n            }\n            return new CairoResult(1 /* Err */ , orderInput(unorderedObject2.unwrap(), resultErrType));\n        }\n        if (isTypeOption(abiObject.name)) {\n            const unorderedOption = unorderedObject2;\n            const resultSomeType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedOption.isSome()) {\n                return new CairoOption(0 /* Some */ , orderInput(unorderedOption.unwrap(), resultSomeType));\n            }\n            return new CairoOption(1 /* None */ , {});\n        }\n        const unorderedCustomEnum = unorderedObject2;\n        const variants = Object.entries(unorderedCustomEnum.variant);\n        const newEntries = variants.map((variant)=>{\n            if (typeof variant[1] === \"undefined\") {\n                return variant;\n            }\n            const variantType = abiObject.type.substring(abiObject.type.lastIndexOf(\"<\") + 1, abiObject.type.lastIndexOf(\">\"));\n            if (variantType === \"()\") {\n                return variant;\n            }\n            return [\n                variant[0],\n                orderInput(unorderedCustomEnum.unwrap(), variantType)\n            ];\n        });\n        return new CairoCustomEnum(Object.fromEntries(newEntries));\n    };\n    const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam)=>{\n        const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                enumerable: true,\n                value\n            });\n        if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n            return orderedObject;\n        }\n        setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n        return orderedObject;\n    }, {});\n    return finalOrderedObject;\n}\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n    switch(true){\n        case CairoUint256.isAbiType(type):\n            return new CairoUint256(val).toApiRequest();\n        case isTypeBytes31(type):\n            return encodeShortString(val.toString());\n        default:\n            return felt(val);\n    }\n}\nfunction parseTuple(element, typeStr) {\n    const memberTypes = extractTupleMemberTypes(typeStr);\n    const elements = Object.values(element);\n    if (elements.length !== memberTypes.length) {\n        throw Error(`ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`);\n    }\n    return memberTypes.map((it, dx)=>{\n        return {\n            element: elements[dx],\n            type: it.type ?? it\n        };\n    });\n}\nfunction parseByteArray(element) {\n    const myByteArray = byteArrayFromString(element);\n    return [\n        myByteArray.data.length.toString(),\n        ...myByteArray.data.map((bn)=>bn.toString()),\n        myByteArray.pending_word.toString(),\n        myByteArray.pending_word_len.toString()\n    ];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n    if (element === void 0) {\n        throw Error(`Missing parameter for type ${type}`);\n    }\n    if (Array.isArray(element)) {\n        const result = [];\n        result.push(felt(element.length));\n        const arrayType = getArrayType(type);\n        return element.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n        }, result);\n    }\n    if (structs[type] && structs[type].members.length) {\n        if (CairoUint256.isAbiType(type)) {\n            return new CairoUint256(element).toApiRequest();\n        }\n        if (type === \"core::starknet::eth_address::EthAddress\") return parseBaseTypes(type, element);\n        if (type === \"core::byte_array::ByteArray\") return parseByteArray(element);\n        const { members } = structs[type];\n        const subElement = element;\n        return members.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n        }, []);\n    }\n    if (isTypeTuple(type)) {\n        const tupled = parseTuple(element, type);\n        return tupled.reduce((acc, it)=>{\n            const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n            return acc.concat(parsedData);\n        }, []);\n    }\n    if (CairoUint256.isAbiType(type)) {\n        return new CairoUint256(element).toApiRequest();\n    }\n    if (isTypeEnum(type, enums)) {\n        const { variants } = enums[type];\n        if (isTypeOption(type)) {\n            const myOption = element;\n            if (myOption.isSome()) {\n                const listTypeVariant2 = variants.find((variant)=>variant.name === \"Some\");\n                if (typeof listTypeVariant2 === \"undefined\") {\n                    throw Error(`Error in abi : Option has no 'Some' variant.`);\n                }\n                const typeVariantSome = listTypeVariant2.type;\n                if (typeVariantSome === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter2 = parseCalldataValue(myOption.unwrap(), typeVariantSome, structs, enums);\n                if (Array.isArray(parsedParameter2)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter2\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter2\n                ];\n            }\n            return 1..toString();\n        }\n        if (isTypeResult(type)) {\n            const myResult = element;\n            if (myResult.isOk()) {\n                const listTypeVariant3 = variants.find((variant)=>variant.name === \"Ok\");\n                if (typeof listTypeVariant3 === \"undefined\") {\n                    throw Error(`Error in abi : Result has no 'Ok' variant.`);\n                }\n                const typeVariantOk = listTypeVariant3.type;\n                if (typeVariantOk === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter3 = parseCalldataValue(myResult.unwrap(), typeVariantOk, structs, enums);\n                if (Array.isArray(parsedParameter3)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter3\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter3\n                ];\n            }\n            const listTypeVariant2 = variants.find((variant)=>variant.name === \"Err\");\n            if (typeof listTypeVariant2 === \"undefined\") {\n                throw Error(`Error in abi : Result has no 'Err' variant.`);\n            }\n            const typeVariantErr = listTypeVariant2.type;\n            if (typeVariantErr === \"()\") {\n                return 1..toString();\n            }\n            const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n            if (Array.isArray(parsedParameter2)) {\n                return [\n                    1..toString(),\n                    ...parsedParameter2\n                ];\n            }\n            return [\n                1..toString(),\n                parsedParameter2\n            ];\n        }\n        const myEnum = element;\n        const activeVariant = myEnum.activeVariant();\n        const listTypeVariant = variants.find((variant)=>variant.name === activeVariant);\n        if (typeof listTypeVariant === \"undefined\") {\n            throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n        }\n        const typeActiveVariant = listTypeVariant.type;\n        const numActiveVariant = variants.findIndex((variant)=>variant.name === activeVariant);\n        if (typeActiveVariant === \"()\") {\n            return numActiveVariant.toString();\n        }\n        const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n        if (Array.isArray(parsedParameter)) {\n            return [\n                numActiveVariant.toString(),\n                ...parsedParameter\n            ];\n        }\n        return [\n            numActiveVariant.toString(),\n            parsedParameter\n        ];\n    }\n    if (typeof element === \"object\") {\n        throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n    }\n    return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n    const { name, type } = input;\n    let { value } = argsIterator.next();\n    switch(true){\n        case isTypeArray(type):\n            if (!Array.isArray(value) && !isText(value)) {\n                throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n            }\n            if (typeof value === \"string\") {\n                value = splitLongString(value);\n            }\n            return parseCalldataValue(value, input.type, structs, enums);\n        case type === \"core::starknet::eth_address::EthAddress\":\n            return parseBaseTypes(type, value);\n        case isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type):\n            return parseCalldataValue(value, type, structs, enums);\n        case isTypeEnum(type, enums):\n            return parseCalldataValue(value, type, structs, enums);\n        default:\n            return parseBaseTypes(type, value);\n    }\n}\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n    let temp;\n    switch(true){\n        case isTypeBool(type):\n            temp = it.next().value;\n            return Boolean(BigInt(temp));\n        case CairoUint256.isAbiType(type):\n            const low = it.next().value;\n            const high = it.next().value;\n            return new CairoUint256(low, high).toBigInt();\n        case type === \"core::starknet::eth_address::EthAddress\":\n            temp = it.next().value;\n            return BigInt(temp);\n        case type === \"core::bytes_31::bytes31\":\n            temp = it.next().value;\n            return decodeShortString(temp);\n        default:\n            temp = it.next().value;\n            return BigInt(temp);\n    }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n    if (element.type === \"()\") {\n        return {};\n    }\n    if (CairoUint256.isAbiType(element.type)) {\n        const low = responseIterator.next().value;\n        const high = responseIterator.next().value;\n        return new CairoUint256(low, high).toBigInt();\n    }\n    if (isTypeByteArray(element.type)) {\n        const parsedBytes31Arr = [];\n        const bytes31ArrLen = BigInt(responseIterator.next().value);\n        while(parsedBytes31Arr.length < bytes31ArrLen){\n            parsedBytes31Arr.push(toHex(responseIterator.next().value));\n        }\n        const pending_word = toHex(responseIterator.next().value);\n        const pending_word_len = BigInt(responseIterator.next().value);\n        const myByteArray = {\n            data: parsedBytes31Arr,\n            pending_word,\n            pending_word_len\n        };\n        return stringFromByteArray(myByteArray);\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    if (structs && element.type in structs && structs[element.type]) {\n        if (element.type === \"core::starknet::eth_address::EthAddress\") {\n            return parseBaseTypes2(element.type, responseIterator);\n        }\n        return structs[element.type].members.reduce((acc, el)=>{\n            acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (enums && element.type in enums && enums[element.type]) {\n        const variantNum = Number(responseIterator.next().value);\n        const rawEnum = enums[element.type].variants.reduce((acc, variant, num)=>{\n            if (num === variantNum) {\n                acc[variant.name] = parseResponseValue(responseIterator, {\n                    name: \"\",\n                    type: variant.type\n                }, structs, enums);\n                return acc;\n            }\n            acc[variant.name] = void 0;\n            return acc;\n        }, {});\n        if (element.type.startsWith(\"core::option::Option\")) {\n            const content = variantNum === 0 /* Some */  ? rawEnum.Some : void 0;\n            return new CairoOption(variantNum, content);\n        }\n        if (element.type.startsWith(\"core::result::Result\")) {\n            let content;\n            if (variantNum === 0 /* Ok */ ) {\n                content = rawEnum.Ok;\n            } else {\n                content = rawEnum.Err;\n            }\n            return new CairoResult(variantNum, content);\n        }\n        const customEnum = new CairoCustomEnum(rawEnum);\n        return customEnum;\n    }\n    if (isTypeTuple(element.type)) {\n        const memberTypes = extractTupleMemberTypes(element.type);\n        return memberTypes.reduce((acc, it, idx)=>{\n            const name = it?.name ? it.name : idx;\n            const type = it?.type ? it.type : it;\n            const el = {\n                name,\n                type\n            };\n            acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n    const { name, type } = output;\n    let temp;\n    switch(true){\n        case isLen(name):\n            temp = responseIterator.next().value;\n            return BigInt(temp);\n        case structs && type in structs || isTypeTuple(type):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case enums && isTypeEnum(type, enums):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case isTypeArray(type):\n            if (isCairo1Type(type)) {\n                return parseResponseValue(responseIterator, output, structs, enums);\n            }\n            const parsedDataArr = [];\n            if (parsedResult && parsedResult[`${name}_len`]) {\n                const arrLen = parsedResult[`${name}_len`];\n                while(parsedDataArr.length < arrLen){\n                    parsedDataArr.push(parseResponseValue(responseIterator, {\n                        name,\n                        type: output.type.replace(\"*\", \"\")\n                    }, structs, enums));\n                }\n            }\n            return parsedDataArr;\n        default:\n            return parseBaseTypes2(type, responseIterator);\n    }\n}\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input)=>{\n    assert(typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\", `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`);\n    if (typeof parameter === \"string\" && !isHex(parameter)) return;\n    const param = BigInt(parameter.toString(10));\n    assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n};\nvar validateBytes31 = (parameter, input)=>{\n    assert(typeof parameter === \"string\", `Validate: arg ${input.name} should be a string.`);\n    assert(parameter.length < 32, `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`);\n};\nvar validateByteArray = (parameter, input)=>{\n    assert(typeof parameter === \"string\", `Validate: arg ${input.name} should be a string.`);\n};\nvar validateUint = (parameter, input)=>{\n    if (typeof parameter === \"number\") {\n        assert(parameter <= Number.MAX_SAFE_INTEGER, `Validation: Parameter is to large to be typed as Number use (BigInt or String)`);\n    }\n    assert(typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\" || typeof parameter === \"object\" && \"low\" in parameter && \"high\" in parameter, `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`);\n    const param = typeof parameter === \"object\" ? new CairoUint256(parameter).toBigInt() : toBigInt(parameter);\n    switch(input.type){\n        case \"core::integer::u8\" /* u8 */ :\n            assert(param >= 0n && param <= 255n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`);\n            break;\n        case \"core::integer::u16\" /* u16 */ :\n            assert(param >= 0n && param <= 65535n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`);\n            break;\n        case \"core::integer::u32\" /* u32 */ :\n            assert(param >= 0n && param <= 4294967295n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`);\n            break;\n        case \"core::integer::u64\" /* u64 */ :\n            assert(param >= 0n && param <= 2n ** 64n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`);\n            break;\n        case \"core::integer::u128\" /* u128 */ :\n            assert(param >= 0n && param <= 2n ** 128n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`);\n            break;\n        case \"core::integer::u256\" /* u256 */ :\n            assert(param >= 0n && param <= 2n ** 256n - 1n, `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`);\n            break;\n        case \"core::starknet::class_hash::ClassHash\" /* ClassHash */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        case \"core::starknet::contract_address::ContractAddress\" /* ContractAddress */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        default:\n            break;\n    }\n};\nvar validateBool = (parameter, input)=>{\n    assert(typeof parameter === \"boolean\", `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`);\n};\nvar validateStruct = (parameter, input, structs)=>{\n    if (input.type === \"core::integer::u256\" /* u256 */ ) {\n        validateUint(parameter, input);\n        return;\n    }\n    if (input.type === \"core::starknet::eth_address::EthAddress\") {\n        assert(typeof parameter !== \"object\", `EthAddress type is waiting a BigNumberish. Got ${parameter}`);\n        const param = BigInt(parameter.toString(10));\n        assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n        param >= 0n && param <= 2n ** 160n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`);\n        return;\n    }\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`);\n    structs[input.type].members.forEach(({ name })=>{\n        assert(Object.keys(parameter).includes(name), `Validate: arg ${input.name} should have a property ${name}`);\n    });\n};\nvar validateEnum = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`);\n    const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n    const keys = [\n        ...Object.getOwnPropertyNames(parameter),\n        ...methodsKeys\n    ];\n    if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n        return;\n    }\n    if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n        return;\n    }\n    if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n        return;\n    }\n    throw new Error(`Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`);\n};\nvar validateTuple = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);\n};\nvar validateArray = (parameter, input, structs, enums)=>{\n    const baseType = getArrayType(input.type);\n    if (isTypeFelt(baseType) && isLongText(parameter)) {\n        return;\n    }\n    assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n    switch(true){\n        case isTypeFelt(baseType):\n            parameter.forEach((param)=>validateFelt(param, input));\n            break;\n        case isTypeTuple(baseType):\n            parameter.forEach((it)=>validateTuple(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeArray(baseType):\n            parameter.forEach((param)=>validateArray(param, {\n                    name: \"\",\n                    type: baseType\n                }, structs, enums));\n            break;\n        case isTypeStruct(baseType, structs):\n            parameter.forEach((it)=>validateStruct(it, {\n                    name: input.name,\n                    type: baseType\n                }, structs));\n            break;\n        case isTypeEnum(baseType, enums):\n            parameter.forEach((it)=>validateEnum(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeUint(baseType) || isTypeLiteral(baseType):\n            parameter.forEach((param)=>validateUint(param, input));\n            break;\n        case isTypeBool(baseType):\n            parameter.forEach((param)=>validateBool(param, input));\n            break;\n        default:\n            throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n    }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n    abiMethod.inputs.reduce((acc, input)=>{\n        const parameter = args[acc];\n        switch(true){\n            case isLen(input.name):\n                return acc;\n            case isTypeFelt(input.type):\n                validateFelt(parameter, input);\n                break;\n            case isTypeBytes31(input.type):\n                validateBytes31(parameter, input);\n                break;\n            case isTypeUint(input.type) || isTypeLiteral(input.type):\n                validateUint(parameter, input);\n                break;\n            case isTypeBool(input.type):\n                validateBool(parameter, input);\n                break;\n            case isTypeByteArray(input.type):\n                validateByteArray(parameter, input);\n                break;\n            case isTypeArray(input.type):\n                validateArray(parameter, input, structs, enums);\n                break;\n            case isTypeStruct(input.type, structs):\n                validateStruct(parameter, input, structs);\n                break;\n            case isTypeEnum(input.type, enums):\n                validateEnum(parameter, input);\n                break;\n            case isTypeTuple(input.type):\n                validateTuple(parameter, input);\n                break;\n            default:\n                throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n        }\n        return acc + 1;\n    }, 0);\n}\n// src/utils/calldata/index.ts\nvar CallData = class {\n    constructor(abi){\n        this.structs = CallData.getAbiStruct(abi);\n        this.enums = CallData.getAbiEnum(abi);\n        this.parser = createAbiParser(abi);\n        this.abi = this.parser.getLegacyFormat();\n    }\n    /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */ validate(type, method, args = []) {\n        if (type !== \"DEPLOY\" /* DEPLOY */ ) {\n            const invocableFunctionNames = this.abi.filter((abi)=>{\n                if (abi.type !== \"function\") return false;\n                const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n                return type === \"INVOKE\" /* INVOKE */  ? !isView : isView;\n            }).map((abi)=>abi.name);\n            assert(invocableFunctionNames.includes(method), `${type === \"INVOKE\" /* INVOKE */  ? \"invocable\" : \"viewable\"} method not found in abi`);\n        }\n        const abiMethod = this.abi.find((abi)=>type === \"DEPLOY\" /* DEPLOY */  ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\");\n        if (isNoConstructorValid(method, args, abiMethod)) {\n            return;\n        }\n        const inputsLength = this.parser.methodInputsLength(abiMethod);\n        if (args.length !== inputsLength) {\n            throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);\n        }\n        validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */ compile(method, argsCalldata) {\n        const abiMethod = this.abi.find((abiFunction)=>abiFunction.name === method);\n        if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n            return [];\n        }\n        let args;\n        if (Array.isArray(argsCalldata)) {\n            args = argsCalldata;\n        } else {\n            const orderedObject = orderPropsByAbi(argsCalldata, abiMethod.inputs, this.structs, this.enums);\n            args = Object.values(orderedObject);\n            validateFields(abiMethod, args, this.structs, this.enums);\n        }\n        const argsIterator = args[Symbol.iterator]();\n        const callArray = abiMethod.inputs.reduce((acc, input)=>isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)), []);\n        Object.defineProperty(callArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callArray;\n    }\n    /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */ static compile(rawArgs) {\n        const createTree = (obj)=>{\n            const getEntries = (o, prefix = \".\")=>{\n                const oe = Array.isArray(o) ? [\n                    o.length.toString(),\n                    ...o\n                ] : o;\n                return Object.entries(oe).flatMap(([k, v])=>{\n                    let value = v;\n                    if (isLongText(value)) value = byteArrayFromString(value);\n                    if (k === \"entrypoint\") value = getSelectorFromName(value);\n                    const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n                    if (isBigInt(value)) return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                    if (Object(value) === value) {\n                        const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n                        const keys = [\n                            ...Object.getOwnPropertyNames(value),\n                            ...methodsKeys\n                        ];\n                        if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n                            const myOption = value;\n                            const variantNb = myOption.isSome() ? 0 /* Some */  : 1 /* None */ ;\n                            if (myOption.isSome()) return getEntries({\n                                0: variantNb,\n                                1: myOption.unwrap()\n                            }, `${prefix}${kk}.`);\n                            return [\n                                [\n                                    `${prefix}${kk}`,\n                                    felt(variantNb)\n                                ]\n                            ];\n                        }\n                        if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n                            const myResult = value;\n                            const variantNb = myResult.isOk() ? 0 /* Ok */  : 1 /* Err */ ;\n                            return getEntries({\n                                0: variantNb,\n                                1: myResult.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n                            const myEnum = value;\n                            const activeVariant = myEnum.activeVariant();\n                            const listVariants = Object.keys(myEnum.variant);\n                            const activeVariantNb = listVariants.findIndex((variant)=>variant === activeVariant);\n                            if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                                return [\n                                    [\n                                        `${prefix}${kk}`,\n                                        felt(activeVariantNb)\n                                    ]\n                                ];\n                            }\n                            return getEntries({\n                                0: activeVariantNb,\n                                1: myEnum.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        return getEntries(value, `${prefix}${kk}.`);\n                    }\n                    return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                });\n            };\n            const result = Object.fromEntries(getEntries(obj));\n            return result;\n        };\n        let callTreeArray;\n        if (!Array.isArray(rawArgs)) {\n            const callTree = createTree(rawArgs);\n            callTreeArray = Object.values(callTree);\n        } else {\n            const callObj = {\n                ...rawArgs\n            };\n            const callTree = createTree(callObj);\n            callTreeArray = Object.values(callTree);\n        }\n        Object.defineProperty(callTreeArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callTreeArray;\n    }\n    /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */ parse(method, response) {\n        const { outputs } = this.abi.find((abi)=>abi.name === method);\n        const responseIterator = response.flat()[Symbol.iterator]();\n        const parsed = outputs.flat().reduce((acc, output, idx)=>{\n            const propName = output.name ?? idx;\n            acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n            if (acc[propName] && acc[`${propName}_len`]) {\n                delete acc[`${propName}_len`];\n            }\n            return acc;\n        }, {});\n        return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n    }\n    /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */ format(method, response, format) {\n        const parsed = this.parse(method, response);\n        return formatter(parsed, format);\n    }\n    /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */ static getAbiStruct(abi) {\n        return abi.filter((abiEntry)=>abiEntry.type === \"struct\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n    }\n    /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */ static getAbiEnum(abi) {\n        const fullEnumList = abi.filter((abiEntry)=>abiEntry.type === \"enum\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n        delete fullEnumList[\"core::bool\"];\n        return fullEnumList;\n    }\n    /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */ static toCalldata(rawCalldata = []) {\n        return CallData.compile(rawCalldata);\n    }\n    /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */ static toHex(raw = []) {\n        const calldata = CallData.compile(raw);\n        return calldata.map((it)=>toHex(it));\n    }\n    /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */ decodeParameters(typeCairo, response) {\n        const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [\n            typeCairo\n        ];\n        const responseIterator = response.flat()[Symbol.iterator]();\n        const decodedArray = typeCairoArray.map((typeParam)=>responseParser(responseIterator, {\n                name: \"\",\n                type: typeParam\n            }, this.structs, this.enums));\n        return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n    }\n};\n// src/utils/hash/index.ts\nvar hash_exports = {};\n__export(hash_exports, {\n    calculateContractAddressFromHash: ()=>calculateContractAddressFromHash,\n    calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash3,\n    calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash3,\n    calculateInvokeTransactionHash: ()=>calculateInvokeTransactionHash2,\n    computeCompiledClassHash: ()=>computeCompiledClassHash,\n    computeContractClassHash: ()=>computeContractClassHash,\n    computeHashOnElements: ()=>computeHashOnElements2,\n    computeLegacyContractClassHash: ()=>computeLegacyContractClassHash,\n    computePedersenHash: ()=>computePedersenHash,\n    computePedersenHashOnElements: ()=>computePedersenHashOnElements,\n    computePoseidonHash: ()=>computePoseidonHash,\n    computePoseidonHashOnElements: ()=>computePoseidonHashOnElements,\n    computeSierraContractClassHash: ()=>computeSierraContractClassHash,\n    formatSpaces: ()=>formatSpaces,\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    keccakBn: ()=>keccakBn,\n    poseidon: ()=>_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_3__,\n    starknetKeccak: ()=>starknetKeccak\n});\n\n// src/utils/hash/transactionHash/v2.ts\nvar v2_exports = {};\n__export(v2_exports, {\n    calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash,\n    calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash,\n    calculateTransactionHash: ()=>calculateTransactionHash,\n    calculateTransactionHashCommon: ()=>calculateTransactionHashCommon,\n    computeHashOnElements: ()=>computeHashOnElements\n});\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n    starkCurve: ()=>_scure_starknet__WEBPACK_IMPORTED_MODULE_2__,\n    weierstrass: ()=>_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_4__\n});\n\n\n// src/utils/hash/transactionHash/v2.ts\nfunction computeHashOnElements(data) {\n    return [\n        ...data,\n        data.length\n    ].reduce((x, y)=>_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(toBigInt(x), toBigInt(y)), 0).toString();\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n    const calldataHash = computeHashOnElements(calldata);\n    const dataToHash = [\n        txHashPrefix,\n        version,\n        contractAddress,\n        entryPointSelector,\n        calldataHash,\n        maxFee,\n        chainId,\n        ...additionalData\n    ];\n    return computeHashOnElements(dataToHash);\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n    return calculateTransactionHashCommon(\"0x6465636c617265\" /* DECLARE */ , version, senderAddress, 0, [\n        classHash\n    ], maxFee, chainId, [\n        nonce,\n        ...compiledClassHash ? [\n            compiledClassHash\n        ] : []\n    ]);\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n    const calldata = [\n        classHash,\n        salt,\n        ...constructorCalldata\n    ];\n    return calculateTransactionHashCommon(\"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n    return calculateTransactionHashCommon(\"0x696e766f6b65\" /* INVOKE */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\n// src/utils/hash/transactionHash/v3.ts\nvar v3_exports = {};\n__export(v3_exports, {\n    calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash2,\n    calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash2,\n    calculateInvokeTransactionHash: ()=>calculateInvokeTransactionHash,\n    calculateTransactionHashCommon: ()=>calculateTransactionHashCommon2,\n    hashDAMode: ()=>hashDAMode,\n    hashFeeField: ()=>hashFeeField\n});\n\nvar AToBI = (array)=>array.map((it)=>BigInt(it));\nvar DATA_AVAILABILITY_MODE_BITS = 32n;\nvar MAX_AMOUNT_BITS = 64n;\nvar MAX_PRICE_PER_UNIT_BITS = 128n;\nvar RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;\nvar L1_GAS_NAME = BigInt(encodeShortString(\"L1_GAS\"));\nvar L2_GAS_NAME = BigInt(encodeShortString(\"L2_GAS\"));\nfunction hashDAMode(nonceDAMode, feeDAMode) {\n    return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);\n}\nfunction hashFeeField(tip, bounds) {\n    const L1Bound = (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l1_gas.max_price_per_unit);\n    const L2Bound = (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l2_gas.max_price_per_unit);\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n        BigInt(tip),\n        L1Bound,\n        L2Bound\n    ]);\n}\nfunction calculateTransactionHashCommon2(txHashPrefix, version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, additionalData = []) {\n    const feeFieldHash = hashFeeField(tip, resourceBounds);\n    const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);\n    const dataToHash = AToBI([\n        txHashPrefix,\n        version,\n        senderAddress,\n        feeFieldHash,\n        (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(AToBI(paymasterData)),\n        chainId,\n        nonce,\n        dAModeHash,\n        ...AToBI(additionalData)\n    ]);\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(dataToHash));\n}\nfunction calculateDeployAccountTransactionHash2(contractAddress, classHash, compiledConstructorCalldata, salt, version, chainId, nonce, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n    return calculateTransactionHashCommon2(\"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */ , version, contractAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [\n        (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(AToBI(compiledConstructorCalldata)),\n        classHash,\n        salt\n    ]);\n}\nfunction calculateDeclareTransactionHash2(classHash, compiledClassHash, senderAddress, version, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n    return calculateTransactionHashCommon2(\"0x6465636c617265\" /* DECLARE */ , version, senderAddress, chainId, nonce, tip, AToBI(paymasterData), nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [\n        (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(AToBI(accountDeploymentData)),\n        classHash,\n        compiledClassHash\n    ]);\n}\nfunction calculateInvokeTransactionHash(senderAddress, version, compiledCalldata, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n    return calculateTransactionHashCommon2(\"0x696e766f6b65\" /* INVOKE */ , version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [\n        (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(AToBI(accountDeploymentData)),\n        (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(AToBI(compiledCalldata))\n    ]);\n}\n// src/utils/hash/transactionHash/index.ts\nfunction isV3InvokeTx(args) {\n    return [\n        \"0x3\" /* V3 */ ,\n        \"0x100000000000000000000000000000003\" /* F3 */ \n    ].includes(args.version);\n}\nfunction calculateInvokeTransactionHash2(args) {\n    if (isV3InvokeTx(args)) {\n        return calculateInvokeTransactionHash(args.senderAddress, args.version, args.compiledCalldata, args.chainId, args.nonce, args.accountDeploymentData, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);\n    }\n    return calculateTransactionHash(args.senderAddress, args.version, args.compiledCalldata, args.maxFee, args.chainId, args.nonce);\n}\nfunction isV3DeclareTx(args) {\n    return [\n        \"0x3\" /* V3 */ ,\n        \"0x100000000000000000000000000000003\" /* F3 */ \n    ].includes(args.version);\n}\nfunction calculateDeclareTransactionHash3(args) {\n    if (isV3DeclareTx(args)) {\n        return calculateDeclareTransactionHash2(args.classHash, args.compiledClassHash, args.senderAddress, args.version, args.chainId, args.nonce, args.accountDeploymentData, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);\n    }\n    return calculateDeclareTransactionHash(args.classHash, args.senderAddress, args.version, args.maxFee, args.chainId, args.nonce, args.compiledClassHash);\n}\nfunction isV3DeployAccountTx(args) {\n    return [\n        \"0x3\" /* V3 */ ,\n        \"0x100000000000000000000000000000003\" /* F3 */ \n    ].includes(args.version);\n}\nfunction calculateDeployAccountTransactionHash3(args) {\n    if (isV3DeployAccountTx(args)) {\n        return calculateDeployAccountTransactionHash2(args.contractAddress, args.classHash, args.compiledConstructorCalldata, args.salt, args.version, args.chainId, args.nonce, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);\n    }\n    return calculateDeployAccountTransactionHash(args.contractAddress, args.classHash, args.constructorCalldata, args.salt, args.version, args.maxFee, args.chainId, args.nonce);\n}\n// src/utils/hash/classHash.ts\n\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n    parse: ()=>parse2,\n    parseAlwaysAsBig: ()=>parseAlwaysAsBig,\n    stringify: ()=>stringify2,\n    stringifyAlwaysAsBig: ()=>stringifyAlwaysAsBig\n});\n\nvar parseIntAsNumberOrBigInt = (x)=>{\n    if (!lossless_json__WEBPACK_IMPORTED_MODULE_5__.isInteger(x)) return parseFloat(x);\n    const v = parseInt(x, 10);\n    return Number.isSafeInteger(v) ? v : BigInt(x);\n};\nvar parse2 = (x)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.parse(String(x), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (x)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.parse(String(x), void 0, lossless_json__WEBPACK_IMPORTED_MODULE_5__.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n// src/utils/hash/classHash.ts\nfunction computePedersenHash(a, b) {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(BigInt(a), BigInt(b));\n}\nfunction computePoseidonHash(a, b) {\n    return toHex(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHash(BigInt(a), BigInt(b)));\n}\nfunction computeHashOnElements2(data) {\n    return [\n        ...data,\n        data.length\n    ].reduce((x, y)=>_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(BigInt(x), BigInt(y)), 0).toString();\n}\nvar computePedersenHashOnElements = computeHashOnElements2;\nfunction computePoseidonHashOnElements(data) {\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(data.map((x)=>BigInt(x))));\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const constructorCalldataHash = computeHashOnElements2(compiledCalldata);\n    const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n    const hash = computeHashOnElements2([\n        CONTRACT_ADDRESS_PREFIX,\n        deployerAddress,\n        salt,\n        classHash,\n        constructorCalldataHash\n    ]);\n    return toHex(BigInt(hash) % ADDR_BOUND);\n}\nfunction nullSkipReplacer(key, value) {\n    if (key === \"attributes\" || key === \"accessible_scopes\") {\n        return Array.isArray(value) && value.length === 0 ? void 0 : value;\n    }\n    if (key === \"debug_info\") {\n        return null;\n    }\n    return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n    let insideQuotes = false;\n    const newString = [];\n    for (const char of json2){\n        if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n            insideQuotes = !insideQuotes;\n        }\n        if (insideQuotes) {\n            newString.push(char);\n        } else {\n            newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n        }\n    }\n    return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n    const { abi, program } = compiledContract;\n    const contractClass = {\n        abi,\n        program\n    };\n    const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n    return addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    const apiVersion = toHex(API_VERSION);\n    const externalEntryPointsHash = computeHashOnElements2(compiledContract.entry_points_by_type.EXTERNAL.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const l1HandlerEntryPointsHash = computeHashOnElements2(compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const constructorEntryPointHash = computeHashOnElements2(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const builtinsHash = computeHashOnElements2(compiledContract.program.builtins.map((s)=>encodeShortString(s)));\n    const hintedClassHash = computeHintedClassHash(compiledContract);\n    const dataHash = computeHashOnElements2(compiledContract.program.data);\n    return computeHashOnElements2([\n        apiVersion,\n        externalEntryPointsHash,\n        l1HandlerEntryPointsHash,\n        constructorEntryPointHash,\n        builtinsHash,\n        hintedClassHash,\n        dataHash\n    ]);\n}\nfunction hashBuiltins(builtins) {\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(builtins.flatMap((it)=>{\n        return BigInt(encodeShortString(it));\n    }));\n}\nfunction hashEntryPoint(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.offset),\n            hashBuiltins(it.builtins)\n        ];\n    });\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(base);\n}\nfunction computeCompiledClassHash(casm) {\n    const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n    const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n    const bytecode = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(casm.bytecode.map((it)=>BigInt(it)));\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        bytecode\n    ]));\n}\nfunction hashEntryPointSierra(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.function_idx)\n        ];\n    });\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n    const indentString = formatSpaces(stringify2(sierra.abi, null));\n    return BigInt(addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n    const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n    const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n    const abiHash = hashAbi(sierra);\n    const sierraProgram = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(sierra.sierra_program.map((it)=>BigInt(it)));\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        abiHash,\n        sierraProgram\n    ]));\n}\nfunction computeContractClassHash(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    if (\"sierra_program\" in compiledContract) {\n        return computeSierraContractClassHash(compiledContract);\n    }\n    return computeLegacyContractClassHash(compiledContract);\n}\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n    compressProgram: ()=>compressProgram,\n    decompressProgram: ()=>decompressProgram,\n    estimateFeeToBounds: ()=>estimateFeeToBounds,\n    estimatedFeeToMaxFee: ()=>estimatedFeeToMaxFee,\n    formatSignature: ()=>formatSignature,\n    intDAM: ()=>intDAM,\n    makeAddress: ()=>makeAddress,\n    randomAddress: ()=>randomAddress,\n    reduceV2: ()=>reduceV2,\n    signatureToDecimalArray: ()=>signatureToDecimalArray,\n    signatureToHexArray: ()=>signatureToHexArray,\n    toFeeVersion: ()=>toFeeVersion,\n    toTransactionVersion: ()=>toTransactionVersion,\n    v3Details: ()=>v3Details\n});\n\n\nfunction compressProgram(jsonProgram) {\n    const stringified = typeof jsonProgram === \"string\" ? jsonProgram : stringify2(jsonProgram);\n    const compressedProgram = (0,pako__WEBPACK_IMPORTED_MODULE_6__.gzip)(stringified);\n    return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n    if (Array.isArray(base642)) return base642;\n    const decompressed = arrayBufferToString((0,pako__WEBPACK_IMPORTED_MODULE_6__.ungzip)(atobUniversal(base642)));\n    return parse2(decompressed);\n}\nfunction randomAddress() {\n    const randomKeyPair = _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey();\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n    return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n    if (!sig) throw Error(\"formatSignature: provided signature is undefined\");\n    if (Array.isArray(sig)) {\n        return sig.map((it)=>toHex(it));\n    }\n    try {\n        const { r, s } = sig;\n        return [\n            toHex(r),\n            toHex(s)\n        ];\n    } catch (e) {\n        throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n    }\n}\nfunction signatureToDecimalArray(sig) {\n    return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n    return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 0.5) {\n    return addPercent(estimatedFee, overhead * 100);\n}\nfunction estimateFeeToBounds(estimate, amountOverhead = 10, priceOverhead = 50) {\n    if (typeof estimate === \"bigint\") {\n        return {\n            l2_gas: {\n                max_amount: \"0x0\",\n                max_price_per_unit: \"0x0\"\n            },\n            l1_gas: {\n                max_amount: \"0x0\",\n                max_price_per_unit: \"0x0\"\n            }\n        };\n    }\n    if (typeof estimate.gas_consumed === \"undefined\" || typeof estimate.gas_price === \"undefined\") {\n        throw Error(\"estimateFeeToBounds: estimate is undefined\");\n    }\n    const maxUnits = toHex(addPercent(estimate.gas_consumed, amountOverhead));\n    const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));\n    return {\n        l2_gas: {\n            max_amount: \"0x0\",\n            max_price_per_unit: \"0x0\"\n        },\n        l1_gas: {\n            max_amount: maxUnits,\n            max_price_per_unit: maxUnitPrice\n        }\n    };\n}\nfunction intDAM(dam) {\n    if (dam === \"L1\" /* L1 */ ) return 0 /* L1 */ ;\n    if (dam === \"L2\" /* L2 */ ) return 1 /* L2 */ ;\n    throw Error(\"EDAM conversion\");\n}\nfunction toTransactionVersion(defaultVersion, providedVersion) {\n    const providedVersion0xs = providedVersion ? toHex(providedVersion) : void 0;\n    const defaultVersion0xs = toHex(defaultVersion);\n    if (providedVersion && !Object.values(ETransactionVersion).includes(providedVersion0xs)) {\n        throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);\n    }\n    if (!Object.values(ETransactionVersion).includes(defaultVersion0xs)) {\n        throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);\n    }\n    return providedVersion ? providedVersion0xs : defaultVersion0xs;\n}\nfunction toFeeVersion(providedVersion) {\n    if (!providedVersion) return void 0;\n    const version = toHex(providedVersion);\n    if (version === \"0x0\" /* V0 */ ) return \"0x100000000000000000000000000000000\" /* F0 */ ;\n    if (version === \"0x1\" /* V1 */ ) return \"0x100000000000000000000000000000001\" /* F1 */ ;\n    if (version === \"0x2\" /* V2 */ ) return \"0x100000000000000000000000000000002\" /* F2 */ ;\n    if (version === \"0x3\" /* V3 */ ) return \"0x100000000000000000000000000000003\" /* F3 */ ;\n    throw Error(`toFeeVersion: ${version} is not supported`);\n}\nfunction v3Details(details) {\n    return {\n        tip: details.tip || 0,\n        paymasterData: details.paymasterData || [],\n        accountDeploymentData: details.accountDeploymentData || [],\n        nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || \"L1\" /* L1 */ ,\n        feeDataAvailabilityMode: details.feeDataAvailabilityMode || \"L1\" /* L1 */ ,\n        resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO)\n    };\n}\nfunction reduceV2(providedVersion) {\n    if (providedVersion === \"0x100000000000000000000000000000002\" /* F2 */ ) return \"0x100000000000000000000000000000001\" /* F1 */ ;\n    if (providedVersion === \"0x2\" /* V2 */ ) return \"0x1\" /* V1 */ ;\n    return providedVersion;\n}\n// src/utils/contract.ts\nfunction isSierra(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n    const response = {\n        ...payload\n    };\n    if (isSierra(payload.contract)) {\n        if (!payload.compiledClassHash && payload.casm) {\n            response.compiledClassHash = computeCompiledClassHash(payload.casm);\n        }\n        if (!response.compiledClassHash) throw new Error(\"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\");\n    }\n    response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n    if (!response.classHash) throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n    return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n    if (isSierra(ccr)) {\n        throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n    }\n    const contract = ccr;\n    return {\n        ...contract,\n        program: decompressProgram(contract.program)\n    };\n}\n// src/utils/fetchPonyfill.ts\n\nvar fetchPonyfill_default =  false || // use buildin fetch in browser if available\ntypeof global !== \"undefined\" && global.fetch || // use buildin fetch in node, react-native and service worker if available\nisomorphic_fetch__WEBPACK_IMPORTED_MODULE_7__;\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n    Block: ()=>Block,\n    createSierraContractClass: ()=>createSierraContractClass,\n    formatHash: ()=>formatHash,\n    getDefaultNodeUrl: ()=>getDefaultNodeUrl,\n    isPendingBlock: ()=>isPendingBlock,\n    isPendingStateUpdate: ()=>isPendingStateUpdate,\n    isPendingTransaction: ()=>isPendingTransaction,\n    isV3Tx: ()=>isV3Tx,\n    isVersion: ()=>isVersion,\n    parseContract: ()=>parseContract,\n    txIdentifier: ()=>txIdentifier,\n    validBlockTags: ()=>validBlockTags,\n    wait: ()=>wait\n});\nfunction wait(delay) {\n    return new Promise((res)=>{\n        setTimeout(res, delay);\n    });\n}\nfunction createSierraContractClass(contract) {\n    const result = {\n        ...contract\n    };\n    delete result.sierra_program_debug_info;\n    result.abi = formatSpaces(stringify2(contract.abi));\n    result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n    result.sierra_program = compressProgram(result.sierra_program);\n    return result;\n}\nfunction parseContract(contract) {\n    const parsedContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    if (!isSierra(contract)) {\n        return {\n            ...parsedContract,\n            ...\"program\" in parsedContract && {\n                program: compressProgram(parsedContract.program)\n            }\n        };\n    }\n    return createSierraContractClass(parsedContract);\n}\nvar getDefaultNodeUrl = (networkName, mute = false)=>{\n    if (!mute) console.warn(\"Using default public node url, please provide nodeUrl in provider options!\");\n    const nodes = RPC_NODES[networkName ?? \"SN_GOERLI\" /* SN_GOERLI */ ];\n    const randIdx = Math.floor(Math.random() * nodes.length);\n    return nodes[randIdx];\n};\nfunction formatHash(hashValue) {\n    if (typeof hashValue === \"string\") return hashValue;\n    return toHex(hashValue);\n}\nfunction txIdentifier(txHash, txId) {\n    if (!txHash) {\n        return `transactionId=${JSON.stringify(txId)}`;\n    }\n    const hashString = formatHash(txHash);\n    return `transactionHash=${hashString}`;\n}\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n    setIdentifier(__identifier) {\n        if (typeof __identifier === \"string\" && isHex(__identifier)) {\n            this.hash = __identifier;\n        } else if (typeof __identifier === \"bigint\") {\n            this.hash = toHex(__identifier);\n        } else if (typeof __identifier === \"number\") {\n            this.number = __identifier;\n        } else if (typeof __identifier === \"string\" && validBlockTags.includes(__identifier)) {\n            this.tag = __identifier;\n        } else {\n            this.tag = \"pending\" /* pending */ ;\n        }\n    }\n    constructor(_identifier){\n        this.hash = null;\n        this.number = null;\n        this.tag = null;\n        this.valueOf = ()=>this.number;\n        this.toString = ()=>this.hash;\n        this.setIdentifier(_identifier);\n    }\n    // TODO: fix any\n    get queryIdentifier() {\n        if (this.number !== null) {\n            return `blockNumber=${this.number}`;\n        }\n        if (this.hash !== null) {\n            return `blockHash=${this.hash}`;\n        }\n        return `blockNumber=${this.tag}`;\n    }\n    // TODO: fix any\n    get identifier() {\n        if (this.number !== null) {\n            return {\n                block_number: this.number\n            };\n        }\n        if (this.hash !== null) {\n            return {\n                block_hash: this.hash\n            };\n        }\n        return this.tag;\n    }\n    set identifier(_identifier) {\n        this.setIdentifier(_identifier);\n    }\n};\nfunction isV3Tx(details) {\n    const version = details.version ? toHex(details.version) : \"0x3\" /* V3 */ ;\n    return version === \"0x3\" /* V3 */  || version === \"0x100000000000000000000000000000003\" /* F3 */ ;\n}\nfunction isVersion(version, response) {\n    const [majorS, minorS] = version.split(\".\");\n    const [majorR, minorR] = response.split(\".\");\n    return majorS === majorR && minorS === minorR;\n}\nfunction isPendingBlock(response) {\n    return response.status === \"PENDING\";\n}\nfunction isPendingTransaction(response) {\n    return !(\"block_hash\" in response);\n}\nfunction isPendingStateUpdate(response) {\n    return !(\"block_hash\" in response);\n}\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n    fromCallsToExecuteCalldata: ()=>fromCallsToExecuteCalldata,\n    fromCallsToExecuteCalldataWithNonce: ()=>fromCallsToExecuteCalldataWithNonce,\n    fromCallsToExecuteCalldata_cairo1: ()=>fromCallsToExecuteCalldata_cairo1,\n    getExecuteCalldata: ()=>getExecuteCalldata,\n    getVersionsByType: ()=>getVersionsByType,\n    transformCallsToMulticallArrays: ()=>transformCallsToMulticallArrays,\n    transformCallsToMulticallArrays_cairo1: ()=>transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls)=>{\n    const callArray = [];\n    const calldata = [];\n    calls.forEach((call)=>{\n        const data = CallData.compile(call.calldata || []);\n        callArray.push({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            data_offset: calldata.length.toString(),\n            data_len: data.length.toString()\n        });\n        calldata.push(...data);\n    });\n    return {\n        callArray,\n        calldata: CallData.compile({\n            calldata\n        })\n    };\n};\nvar fromCallsToExecuteCalldata = (calls)=>{\n    const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n    const compiledCalls = CallData.compile({\n        callArray\n    });\n    return [\n        ...compiledCalls,\n        ...calldata\n    ];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce)=>{\n    return [\n        ...fromCallsToExecuteCalldata(calls),\n        toBigInt(nonce).toString()\n    ];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls)=>{\n    const callArray = calls.map((call)=>({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            calldata: CallData.compile(call.calldata || [])\n        }));\n    return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls)=>{\n    const orderCalls = calls.map((call)=>({\n            contractAddress: call.contractAddress,\n            entrypoint: call.entrypoint,\n            calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n        }));\n    return CallData.compile({\n        orderCalls\n    });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\")=>{\n    if (cairoVersion === \"1\") {\n        return fromCallsToExecuteCalldata_cairo1(calls);\n    }\n    return fromCallsToExecuteCalldata(calls);\n};\nfunction getVersionsByType(versionType) {\n    return versionType === \"fee\" ? {\n        v1: \"0x100000000000000000000000000000001\" /* F1 */ ,\n        v2: \"0x100000000000000000000000000000002\" /* F2 */ ,\n        v3: \"0x100000000000000000000000000000003\" /* F3 */ \n    } : {\n        v1: \"0x1\" /* V1 */ ,\n        v2: \"0x2\" /* V2 */ ,\n        v3: \"0x3\" /* V3 */ \n    };\n}\n// src/channel/rpc_0_6.ts\nvar defaultOptions = {\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    blockIdentifier: \"pending\" /* pending */ ,\n    retries: 200\n};\nvar RpcChannel = class {\n    // behave like web2 rpc and return when tx is processed\n    constructor(optionsOrProvider){\n        const { nodeUrl, retries, headers, blockIdentifier, chainId, waitMode } = optionsOrProvider || {};\n        if (Object.values(NetworkName).includes(nodeUrl)) {\n            this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n        } else if (nodeUrl) {\n            this.nodeUrl = nodeUrl;\n        } else {\n            this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n        }\n        this.retries = retries || defaultOptions.retries;\n        this.headers = {\n            ...defaultOptions.headers,\n            ...headers\n        };\n        this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n        this.chainId = chainId;\n        this.waitMode = waitMode || false;\n        this.requestId = 0;\n    }\n    fetch(method, params, id = 0) {\n        const rpcRequestBody = {\n            id,\n            jsonrpc: \"2.0\",\n            method,\n            ...params && {\n                params\n            }\n        };\n        return fetchPonyfill_default(this.nodeUrl, {\n            method: \"POST\",\n            body: stringify2(rpcRequestBody),\n            headers: this.headers\n        });\n    }\n    errorHandler(method, params, rpcError, otherError) {\n        if (rpcError) {\n            const { code, message, data } = rpcError;\n            throw new LibraryError(`RPC: ${method} with params ${stringify2(params, null, 2)}\n \n        ${code}: ${message}: ${stringify2(data)}`);\n        }\n        if (otherError instanceof LibraryError) {\n            throw otherError;\n        }\n        if (otherError) {\n            throw Error(otherError.message);\n        }\n    }\n    async fetchEndpoint(method, params) {\n        try {\n            const rawResult = await this.fetch(method, params, this.requestId += 1);\n            const { error, result } = await rawResult.json();\n            this.errorHandler(method, params, error);\n            return result;\n        } catch (error) {\n            this.errorHandler(method, params, error?.response?.data, error);\n            throw error;\n        }\n    }\n    async getChainId() {\n        this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n        return this.chainId;\n    }\n    async getSpecVersion() {\n        this.speckVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n        return this.speckVersion;\n    }\n    getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getNonce\", {\n            contract_address,\n            block_id\n        });\n    }\n    /**\n   * Get the most recent accepted block hash and number\n   */ getBlockLatestAccepted() {\n        return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n    }\n    /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */ getBlockNumber() {\n        return this.fetchEndpoint(\"starknet_blockNumber\");\n    }\n    getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", {\n            block_id\n        });\n    }\n    getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxs\", {\n            block_id\n        });\n    }\n    getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStateUpdate\", {\n            block_id\n        });\n    }\n    getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_traceBlockTransactions\", {\n            block_id\n        });\n    }\n    getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", {\n            block_id\n        });\n    }\n    getTransactionByHash(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n            transaction_hash\n        });\n    }\n    getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", {\n            block_id,\n            index\n        });\n    }\n    getTransactionReceipt(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionReceipt\", {\n            transaction_hash\n        });\n    }\n    getTransactionTrace(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_traceTransaction\", {\n            transaction_hash\n        });\n    }\n    /**\n   * Get the status of a transaction\n   */ getTransactionStatus(transactionHash) {\n        const transaction_hash = toHex(transactionHash);\n        return this.fetchEndpoint(\"starknet_getTransactionStatus\", {\n            transaction_hash\n        });\n    }\n    /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */ simulateTransaction(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true, skipFeeCharge = true } = {}) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const simulationFlags = [];\n        if (skipValidate) simulationFlags.push(api_exports.ESimulationFlag.SKIP_VALIDATE);\n        if (skipFeeCharge) simulationFlags.push(api_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n        return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n            block_id,\n            transactions: invocations.map((it)=>this.buildTransaction(it)),\n            simulation_flags: simulationFlags\n        });\n    }\n    async waitForTransaction(txHash, options) {\n        const transactionHash = toHex(txHash);\n        let { retries } = this;\n        let onchain = false;\n        let isErrorState = false;\n        const retryInterval = options?.retryInterval ?? 5e3;\n        const errorStates = options?.errorStates ?? [\n            api_exports.ETransactionStatus.REJECTED\n        ];\n        const successStates = options?.successStates ?? [\n            api_exports.ETransactionExecutionStatus.SUCCEEDED,\n            api_exports.ETransactionStatus.ACCEPTED_ON_L2,\n            api_exports.ETransactionStatus.ACCEPTED_ON_L1\n        ];\n        let txStatus;\n        while(!onchain){\n            await wait(retryInterval);\n            try {\n                txStatus = await this.getTransactionStatus(transactionHash);\n                const executionStatus = txStatus.execution_status;\n                const finalityStatus = txStatus.finality_status;\n                if (!finalityStatus) {\n                    const error = new Error(\"waiting for transaction status\");\n                    throw error;\n                }\n                if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n                    const message = `${executionStatus}: ${finalityStatus}`;\n                    const error = new Error(message);\n                    error.response = txStatus;\n                    isErrorState = true;\n                    throw error;\n                } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n                    onchain = true;\n                }\n            } catch (error) {\n                if (error instanceof Error && isErrorState) {\n                    throw error;\n                }\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n        }\n        let txReceipt = null;\n        while(txReceipt === null){\n            try {\n                txReceipt = await this.getTransactionReceipt(transactionHash);\n            } catch (error) {\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n            await wait(retryInterval);\n        }\n        return txReceipt;\n    }\n    getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const parsedKey = toStorageKey(key);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStorageAt\", {\n            contract_address,\n            key: parsedKey,\n            block_id\n        });\n    }\n    getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n            block_id,\n            contract_address\n        });\n    }\n    getClass(classHash, blockIdentifier = this.blockIdentifier) {\n        const class_hash = toHex(classHash);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClass\", {\n            class_hash,\n            block_id\n        });\n    }\n    getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassAt\", {\n            block_id,\n            contract_address\n        });\n    }\n    async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n        const block_id = new Block(blockIdentifier).identifier;\n        let flags = {};\n        if (isVersion(\"0.6\", await this.getSpecVersion())) {\n            flags = {\n                simulation_flags: skipValidate ? [\n                    api_exports.ESimulationFlag.SKIP_VALIDATE\n                ] : []\n            };\n        }\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: invocations.map((it)=>this.buildTransaction(it, \"fee\")),\n            block_id,\n            ...flags\n        });\n    }\n    async invoke(functionInvocation, details) {\n        let promise;\n        if (!isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n                invoke_transaction: {\n                    sender_address: functionInvocation.contractAddress,\n                    calldata: CallData.toHex(functionInvocation.calldata),\n                    type: api_exports.ETransactionType.INVOKE,\n                    max_fee: toHex(details.maxFee || 0),\n                    version: \"0x1\" /* V1 */ ,\n                    signature: signatureToHexArray(functionInvocation.signature),\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else {\n            promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n                invoke_transaction: {\n                    type: api_exports.ETransactionType.INVOKE,\n                    sender_address: functionInvocation.contractAddress,\n                    calldata: CallData.toHex(functionInvocation.calldata),\n                    version: \"0x3\" /* V3 */ ,\n                    signature: signatureToHexArray(functionInvocation.signature),\n                    nonce: toHex(details.nonce),\n                    resource_bounds: details.resourceBounds,\n                    tip: toHex(details.tip),\n                    paymaster_data: details.paymasterData.map((it)=>toHex(it)),\n                    account_deployment_data: details.accountDeploymentData.map((it)=>toHex(it)),\n                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n                    fee_data_availability_mode: details.feeDataAvailabilityMode\n                }\n            });\n        }\n        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n    }\n    async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n        let promise;\n        if (!isSierra(contract) && !isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: api_exports.ETransactionType.DECLARE,\n                    contract_class: {\n                        program: contract.program,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    version: \"0x1\" /* V1 */ ,\n                    max_fee: toHex(details.maxFee || 0),\n                    signature: signatureToHexArray(signature),\n                    sender_address: senderAddress,\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else if (isSierra(contract) && !isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: api_exports.ETransactionType.DECLARE,\n                    contract_class: {\n                        sierra_program: decompressProgram(contract.sierra_program),\n                        contract_class_version: contract.contract_class_version,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    compiled_class_hash: compiledClassHash || \"\",\n                    version: \"0x2\" /* V2 */ ,\n                    max_fee: toHex(details.maxFee || 0),\n                    signature: signatureToHexArray(signature),\n                    sender_address: senderAddress,\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else if (isSierra(contract) && isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: api_exports.ETransactionType.DECLARE,\n                    sender_address: senderAddress,\n                    compiled_class_hash: compiledClassHash || \"\",\n                    version: \"0x3\" /* V3 */ ,\n                    signature: signatureToHexArray(signature),\n                    nonce: toHex(details.nonce),\n                    contract_class: {\n                        sierra_program: decompressProgram(contract.sierra_program),\n                        contract_class_version: contract.contract_class_version,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    resource_bounds: details.resourceBounds,\n                    tip: toHex(details.tip),\n                    paymaster_data: details.paymasterData.map((it)=>toHex(it)),\n                    account_deployment_data: details.accountDeploymentData.map((it)=>toHex(it)),\n                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n                    fee_data_availability_mode: details.feeDataAvailabilityMode\n                }\n            });\n        } else {\n            throw Error(\"declare unspotted parameters\");\n        }\n        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n    }\n    async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        let promise;\n        if (!isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n                deploy_account_transaction: {\n                    constructor_calldata: CallData.toHex(constructorCalldata || []),\n                    class_hash: toHex(classHash),\n                    contract_address_salt: toHex(addressSalt || 0),\n                    type: api_exports.ETransactionType.DEPLOY_ACCOUNT,\n                    max_fee: toHex(details.maxFee || 0),\n                    version: \"0x1\" /* V1 */ ,\n                    signature: signatureToHexArray(signature),\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else {\n            promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n                deploy_account_transaction: {\n                    type: api_exports.ETransactionType.DEPLOY_ACCOUNT,\n                    version: \"0x3\" /* V3 */ ,\n                    signature: signatureToHexArray(signature),\n                    nonce: toHex(details.nonce),\n                    contract_address_salt: toHex(addressSalt || 0),\n                    constructor_calldata: CallData.toHex(constructorCalldata || []),\n                    class_hash: toHex(classHash),\n                    resource_bounds: details.resourceBounds,\n                    tip: toHex(details.tip),\n                    paymaster_data: details.paymasterData.map((it)=>toHex(it)),\n                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n                    fee_data_availability_mode: details.feeDataAvailabilityMode\n                }\n            });\n        }\n        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n    }\n    callContract(call, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_call\", {\n            request: {\n                contract_address: call.contractAddress,\n                entry_point_selector: getSelectorFromName(call.entrypoint),\n                calldata: CallData.toHex(call.calldata)\n            },\n            block_id\n        });\n    }\n    /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */ estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n        const { from_address, to_address, entry_point_selector, payload } = message;\n        const formattedMessage = {\n            from_address: toHex(from_address),\n            to_address: toHex(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n            message: formattedMessage,\n            block_id\n        });\n    }\n    /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */ getSyncingStats() {\n        return this.fetchEndpoint(\"starknet_syncing\");\n    }\n    /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */ getEvents(eventFilter) {\n        return this.fetchEndpoint(\"starknet_getEvents\", {\n            filter: eventFilter\n        });\n    }\n    buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        let details;\n        if (!isV3Tx(invocation)) {\n            details = {\n                signature: signatureToHexArray(invocation.signature),\n                nonce: toHex(invocation.nonce),\n                max_fee: toHex(invocation.maxFee || 0)\n            };\n        } else {\n            details = {\n                signature: signatureToHexArray(invocation.signature),\n                nonce: toHex(invocation.nonce),\n                resource_bounds: invocation.resourceBounds,\n                tip: toHex(invocation.tip),\n                paymaster_data: invocation.paymasterData.map((it)=>toHex(it)),\n                nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n                fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n                account_deployment_data: invocation.accountDeploymentData.map((it)=>toHex(it))\n            };\n        }\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                // v0 v1 v3\n                type: api_exports.ETransactionType.INVOKE,\n                // TODO: Diff between sequencer and rpc invoke type\n                sender_address: invocation.contractAddress,\n                calldata: CallData.toHex(invocation.calldata),\n                version: toHex(invocation.version || defaultVersions.v3),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    ...details\n                };\n            }\n            return {\n                // Cairo 1 - v2 v3\n                type: invocation.type,\n                contract_class: {\n                    ...invocation.contract,\n                    sierra_program: decompressProgram(invocation.contract.sierra_program)\n                },\n                compiled_class_hash: invocation.compiledClassHash || \"\",\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v3),\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            const { account_deployment_data, ...restDetails } = details;\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v3),\n                ...restDetails\n            };\n        }\n        throw Error(\"RPC buildTransaction received unknown TransactionType\");\n    }\n};\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n    parseGetBlockResponse(res) {\n        return {\n            status: \"PENDING\",\n            ...res\n        };\n    }\n    parseTransactionReceipt(res) {\n        if (\"actual_fee\" in res && typeof res.actual_fee === \"string\") {\n            return {\n                ...res,\n                actual_fee: {\n                    amount: res.actual_fee,\n                    unit: \"FRI\"\n                }\n            };\n        }\n        return res;\n    }\n    parseFeeEstimateResponse(res) {\n        const val = res[0];\n        return {\n            overall_fee: toBigInt(val.overall_fee),\n            gas_consumed: toBigInt(val.gas_consumed),\n            gas_price: toBigInt(val.gas_price),\n            unit: val.unit,\n            suggestedMaxFee: estimatedFeeToMaxFee(val.overall_fee),\n            resourceBounds: estimateFeeToBounds(val)\n        };\n    }\n    parseFeeEstimateBulkResponse(res) {\n        return res.map((val)=>({\n                overall_fee: toBigInt(val.overall_fee),\n                gas_consumed: toBigInt(val.gas_consumed),\n                gas_price: toBigInt(val.gas_price),\n                unit: val.unit,\n                suggestedMaxFee: estimatedFeeToMaxFee(val.overall_fee),\n                resourceBounds: estimateFeeToBounds(val)\n            }));\n    }\n    parseSimulateTransactionResponse(res) {\n        return res.map((it)=>{\n            return {\n                ...it,\n                suggestedMaxFee: estimatedFeeToMaxFee(BigInt(it.fee_estimation.overall_fee)),\n                resourceBounds: estimateFeeToBounds(it.fee_estimation)\n            };\n        });\n    }\n    parseContractClassResponse(res) {\n        return {\n            ...res,\n            abi: typeof res.abi === \"string\" ? JSON.parse(res.abi) : res.abi\n        };\n    }\n};\n// src/provider/rpc.ts\nvar RpcProvider = class {\n    constructor(optionsOrProvider){\n        this.responseParser = new RPCResponseParser();\n        this.getStateUpdate = this.getBlockStateUpdate;\n        if (optionsOrProvider && \"channel\" in optionsOrProvider) {\n            this.channel = optionsOrProvider.channel;\n        } else {\n            this.channel = new RpcChannel({\n                ...optionsOrProvider,\n                waitMode: false\n            });\n        }\n    }\n    fetch(method, params, id = 0) {\n        return this.channel.fetch(method, params, id);\n    }\n    async getChainId() {\n        return this.channel.getChainId();\n    }\n    async getSpecVersion() {\n        return this.channel.getSpecVersion();\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier) {\n        return this.channel.getNonceForAddress(contractAddress, blockIdentifier);\n    }\n    async getBlock(blockIdentifier) {\n        return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);\n    }\n    /**\n   * Get the most recent accepted block hash and number\n   */ async getBlockLatestAccepted() {\n        return this.channel.getBlockLatestAccepted();\n    }\n    /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */ async getBlockNumber() {\n        return this.channel.getBlockNumber();\n    }\n    async getBlockWithTxHashes(blockIdentifier) {\n        return this.channel.getBlockWithTxHashes(blockIdentifier);\n    }\n    async getBlockWithTxs(blockIdentifier) {\n        return this.channel.getBlockWithTxs(blockIdentifier);\n    }\n    async getBlockStateUpdate(blockIdentifier) {\n        return this.channel.getBlockStateUpdate(blockIdentifier);\n    }\n    async getBlockTransactionsTraces(blockIdentifier) {\n        return this.channel.getBlockTransactionsTraces(blockIdentifier);\n    }\n    async getBlockTransactionCount(blockIdentifier) {\n        return this.channel.getBlockTransactionCount(blockIdentifier);\n    }\n    /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.pending); (will be removed in next minor version)\n   * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);\n   */ async getPendingTransactions() {\n        const { transactions } = await this.getBlockWithTxHashes(\"pending\" /* pending */ ).then(this.responseParser.parseGetBlockResponse);\n        return Promise.all(transactions.map((it)=>this.getTransactionByHash(it)));\n    }\n    async getTransaction(txHash) {\n        return this.channel.getTransactionByHash(txHash);\n    }\n    async getTransactionByHash(txHash) {\n        return this.channel.getTransactionByHash(txHash);\n    }\n    async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n        return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);\n    }\n    async getTransactionReceipt(txHash) {\n        return this.channel.getTransactionReceipt(txHash).then(this.responseParser.parseTransactionReceipt);\n    }\n    async getTransactionTrace(txHash) {\n        return this.channel.getTransactionTrace(txHash);\n    }\n    /**\n   * Get the status of a transaction\n   */ async getTransactionStatus(transactionHash) {\n        return this.channel.getTransactionStatus(transactionHash);\n    }\n    /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */ async getSimulateTransaction(invocations, options) {\n        return this.channel.simulateTransaction(invocations, options).then(this.responseParser.parseSimulateTransactionResponse);\n    }\n    async waitForTransaction(txHash, options) {\n        return this.channel.waitForTransaction(txHash, options);\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier) {\n        return this.channel.getStorageAt(contractAddress, key, blockIdentifier);\n    }\n    async getClassHashAt(contractAddress, blockIdentifier) {\n        return this.channel.getClassHashAt(contractAddress, blockIdentifier);\n    }\n    async getClassByHash(classHash) {\n        return this.getClass(classHash);\n    }\n    async getClass(classHash, blockIdentifier) {\n        return this.channel.getClass(classHash, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n    }\n    async getClassAt(contractAddress, blockIdentifier) {\n        return this.channel.getClassAt(contractAddress, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n    }\n    async getContractVersion(contractAddress, classHash, { blockIdentifier = this.channel.blockIdentifier, compiler = true } = {}) {\n        let contractClass;\n        if (contractAddress) {\n            contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n        } else if (classHash) {\n            contractClass = await this.getClass(classHash, blockIdentifier);\n        } else {\n            throw Error(\"getContractVersion require contractAddress or classHash\");\n        }\n        if (isSierra(contractClass)) {\n            if (compiler) {\n                const abiTest = getAbiContractVersion(contractClass.abi);\n                return {\n                    cairo: \"1\",\n                    compiler: abiTest.compiler\n                };\n            }\n            return {\n                cairo: \"1\",\n                compiler: void 0\n            };\n        }\n        return {\n            cairo: \"0\",\n            compiler: \"0\"\n        };\n    }\n    /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */ async getEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n    }\n    async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n        return this.channel.getEstimateFee([\n            {\n                type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n                ...invocation,\n                ...invocationDetails\n            }\n        ], {\n            blockIdentifier,\n            skipValidate\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeclareEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n        return this.channel.getEstimateFee([\n            {\n                type: \"DECLARE\" /* DECLARE */ ,\n                ...invocation,\n                ...details\n            }\n        ], {\n            blockIdentifier,\n            skipValidate\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeployAccountEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n        return this.channel.getEstimateFee([\n            {\n                type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n                ...invocation,\n                ...details\n            }\n        ], {\n            blockIdentifier,\n            skipValidate\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getEstimateFeeBulk(invocations, options) {\n        return this.channel.getEstimateFee(invocations, options).then(this.responseParser.parseFeeEstimateBulkResponse);\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.channel.invoke(functionInvocation, details);\n    }\n    async declareContract(transaction, details) {\n        return this.channel.declare(transaction, details);\n    }\n    async deployAccountContract(transaction, details) {\n        return this.channel.deployAccount(transaction, details);\n    }\n    async callContract(call, blockIdentifier) {\n        return this.channel.callContract(call, blockIdentifier);\n    }\n    /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */ async estimateMessageFee(message, blockIdentifier) {\n        return this.channel.estimateMessageFee(message, blockIdentifier);\n    }\n    /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */ async getSyncingStats() {\n        return this.channel.getSyncingStats();\n    }\n    /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */ async getEvents(eventFilter) {\n        return this.channel.getEvents(eventFilter);\n    }\n};\n// src/provider/extensions/default.ts\n\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n    StarknetIdContract: ()=>StarknetIdContract,\n    getStarknetIdContract: ()=>getStarknetIdContract,\n    useDecoded: ()=>useDecoded,\n    useEncoded: ()=>useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"这来\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n    let k = 0;\n    while(str.endsWith(bigAlphabet[bigAlphabet.length - 1])){\n        str = str.substring(0, str.length - 1);\n        k += 1;\n    }\n    return [\n        str,\n        k\n    ];\n}\nfunction useDecoded(encoded) {\n    let decoded = \"\";\n    encoded.forEach((subdomain)=>{\n        while(subdomain !== ZERO){\n            const code = subdomain % basicSizePlusOne;\n            subdomain /= basicSizePlusOne;\n            if (code === BigInt(basicAlphabet.length)) {\n                const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n                if (nextSubdomain === ZERO) {\n                    const code2 = subdomain % bigAlphabetSizePlusOne;\n                    subdomain = nextSubdomain;\n                    if (code2 === ZERO) decoded += basicAlphabet[0];\n                    else decoded += bigAlphabet[Number(code2) - 1];\n                } else {\n                    const code2 = subdomain % bigAlphabetSize;\n                    decoded += bigAlphabet[Number(code2)];\n                    subdomain /= bigAlphabetSize;\n                }\n            } else decoded += basicAlphabet[Number(code)];\n        }\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n        decoded += \".\";\n    });\n    if (!decoded) {\n        return decoded;\n    }\n    return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n    let encoded = BigInt(0);\n    let multiplier = BigInt(1);\n    if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n        const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n        decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n    } else {\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n    }\n    for(let i = 0; i < decoded.length; i += 1){\n        const char = decoded[i];\n        const index = basicAlphabet.indexOf(char);\n        const bnIndex = BigInt(basicAlphabet.indexOf(char));\n        if (index !== -1) {\n            if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n                encoded += multiplier * basicAlphabetSize;\n                multiplier *= basicSizePlusOne;\n                multiplier *= basicSizePlusOne;\n            } else {\n                encoded += multiplier * bnIndex;\n                multiplier *= basicSizePlusOne;\n            }\n        } else if (bigAlphabet.indexOf(char) !== -1) {\n            encoded += multiplier * basicAlphabetSize;\n            multiplier *= basicSizePlusOne;\n            const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n            encoded += multiplier * BigInt(newid);\n            multiplier *= bigAlphabetSize;\n        }\n    }\n    return encoded;\n}\nvar StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2)=>{\n    StarknetIdContract2[\"MAINNET\"] = \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\";\n    StarknetIdContract2[\"TESTNET\"] = \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\";\n    return StarknetIdContract2;\n})(StarknetIdContract || {});\nfunction getStarknetIdContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\" /* MAINNET */ ;\n        case \"0x534e5f474f45524c49\" /* SN_GOERLI */ :\n            return \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\" /* TESTNET */ ;\n        default:\n            throw new Error(\"Starknet.id is not yet deployed on this network\");\n    }\n}\n// src/provider/extensions/starknetId.ts\nvar StarknetId = class {\n    async getStarkName(address, StarknetIdContract2) {\n        return StarknetId.getStarkName(// After Mixin, this is ProviderInterface\n        this, address, StarknetIdContract2);\n    }\n    async getAddressFromStarkName(name, StarknetIdContract2) {\n        return StarknetId.getAddressFromStarkName(// After Mixin, this is ProviderInterface\n        this, name, StarknetIdContract2);\n    }\n    static async getStarkName(provider, address, StarknetIdContract2) {\n        const chainId = await provider.getChainId();\n        const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n        try {\n            const hexDomain = await provider.callContract({\n                contractAddress: contract,\n                entrypoint: \"address_to_domain\",\n                calldata: CallData.compile({\n                    address\n                })\n            });\n            const decimalDomain = hexDomain.map((element)=>BigInt(element)).slice(1);\n            const stringDomain = useDecoded(decimalDomain);\n            if (!stringDomain) {\n                throw Error(\"Starkname not found\");\n            }\n            return stringDomain;\n        } catch (e) {\n            if (e instanceof Error && e.message === \"Starkname not found\") {\n                throw e;\n            }\n            throw Error(\"Could not get stark name\");\n        }\n    }\n    static async getAddressFromStarkName(provider, name, StarknetIdContract2) {\n        const chainId = await provider.getChainId();\n        const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n        try {\n            const addressData = await provider.callContract({\n                contractAddress: contract,\n                entrypoint: \"domain_to_address\",\n                calldata: CallData.compile({\n                    domain: [\n                        useEncoded(name.replace(\".stark\", \"\")).toString(10)\n                    ]\n                })\n            });\n            return addressData[0];\n        } catch  {\n            throw Error(\"Could not get address from stark name\");\n        }\n    }\n};\n// src/provider/extensions/default.ts\nvar RpcProvider2 = class extends (0,ts_mixer__WEBPACK_IMPORTED_MODULE_8__.Mixin)(RpcProvider, StarknetId) {\n};\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n// src/provider/index.ts\nvar defaultProvider = new RpcProvider({\n    default: true\n});\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n    TypedDataRevision: ()=>TypedDataRevision,\n    byteArrayFromString: ()=>byteArrayFromString2,\n    encodeData: ()=>encodeData,\n    encodeType: ()=>encodeType,\n    encodeValue: ()=>encodeValue,\n    getDependencies: ()=>getDependencies,\n    getMessageHash: ()=>getMessageHash,\n    getStructHash: ()=>getStructHash,\n    getTypeHash: ()=>getTypeHash,\n    isMerkleTreeType: ()=>isMerkleTreeType,\n    prepareSelector: ()=>prepareSelector\n});\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n    MerkleTree: ()=>MerkleTree,\n    proofMerklePath: ()=>proofMerklePath\n});\nvar MerkleTree = class {\n    constructor(leafHashes, hashMethod = computePedersenHash){\n        this.branches = [];\n        this.hashMethod = hashMethod;\n        this.leaves = leafHashes;\n        this.root = this.build(leafHashes);\n    }\n    /**\n   * Create Merkle tree\n   * @param leaves hex-string array\n   * @returns format: hex-string; Merkle tree root\n   */ build(leaves) {\n        if (leaves.length === 1) {\n            return leaves[0];\n        }\n        if (leaves.length !== this.leaves.length) {\n            this.branches.push(leaves);\n        }\n        const newLeaves = [];\n        for(let i = 0; i < leaves.length; i += 2){\n            if (i + 1 === leaves.length) {\n                newLeaves.push(MerkleTree.hash(leaves[i], \"0x0\", this.hashMethod));\n            } else {\n                newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n            }\n        }\n        return this.build(newLeaves);\n    }\n    /**\n   * Create hash from ordered a and b, Pedersen hash default\n   * @returns format: hex-string\n   */ static hash(a, b, hashMethod = computePedersenHash) {\n        const [aSorted, bSorted] = [\n            BigInt(a),\n            BigInt(b)\n        ].sort((x, y)=>x >= y ? 1 : -1);\n        return hashMethod(aSorted, bSorted);\n    }\n    /**\n   * Return path to leaf\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns format: hex-string array\n   */ getProof(leaf, branch = this.leaves, hashPath = []) {\n        const index = branch.indexOf(leaf);\n        if (index === -1) {\n            throw new Error(\"leaf not found\");\n        }\n        if (branch.length === 1) {\n            return hashPath;\n        }\n        const isLeft = index % 2 === 0;\n        const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n        const newHashPath = [\n            ...hashPath,\n            neededBranch\n        ];\n        const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b)=>b.length === branch.length);\n        const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [\n            this.root\n        ];\n        return this.getProof(MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod), nextBranch, newHashPath);\n    }\n};\nfunction proofMerklePath(root, leaf, path, hashMethod = computePedersenHash) {\n    if (path.length === 0) {\n        return root === leaf;\n    }\n    const [next, ...rest] = path;\n    return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n// src/utils/typedData.ts\nvar presetTypes = {\n    u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n    TokenAmount: JSON.parse('[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'),\n    NftId: JSON.parse('[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]')\n};\nvar revisionConfiguration = {\n    [\"1\" /* Active */ ]: {\n        domain: \"StarknetDomain\",\n        hashMethod: computePoseidonHashOnElements,\n        hashMerkleMethod: computePoseidonHash,\n        escapeTypeString: (s)=>`\"${s}\"`,\n        presetTypes\n    },\n    [\"0\" /* Legacy */ ]: {\n        domain: \"StarkNetDomain\",\n        hashMethod: computePedersenHashOnElements,\n        hashMerkleMethod: computePedersenHash,\n        escapeTypeString: (s)=>s,\n        presetTypes: {}\n    }\n};\nfunction byteArrayFromString2(targetString) {\n    const shortStrings = splitLongString(targetString);\n    const remainder = shortStrings[shortStrings.length - 1];\n    const shortStringsEncoded = shortStrings.map(encodeShortString);\n    const [pendingWord, pendingWordLength] = remainder === void 0 || remainder.length === 31 ? [\n        \"0x00\",\n        0\n    ] : [\n        shortStringsEncoded.pop(),\n        remainder.length\n    ];\n    return {\n        data: shortStringsEncoded.length === 0 ? [\n            \"0x00\"\n        ] : shortStringsEncoded,\n        pending_word: pendingWord,\n        pending_word_len: pendingWordLength\n    };\n}\nfunction identifyRevision({ types, domain }) {\n    if (revisionConfiguration[\"1\" /* Active */ ].domain in types && domain.revision === \"1\" /* Active */ ) return \"1\" /* Active */ ;\n    if (revisionConfiguration[\"0\" /* Legacy */ ].domain in types && (domain.revision ?? \"0\" /* Legacy */ ) === \"0\" /* Legacy */ ) return \"0\" /* Legacy */ ;\n    return void 0;\n}\nfunction getHex(value) {\n    try {\n        return toHex(value);\n    } catch (e) {\n        if (typeof value === \"string\") {\n            return toHex(encodeShortString(value));\n        }\n        throw new Error(`Invalid BigNumberish: ${value}`);\n    }\n}\nfunction validateTypedData(data) {\n    const typedData = data;\n    return Boolean(typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData));\n}\nfunction prepareSelector(selector) {\n    return isHex(selector) ? selector : getSelectorFromName(selector);\n}\nfunction isMerkleTreeType(type) {\n    return type.type === \"merkletree\";\n}\nfunction getDependencies(types, type, dependencies = [], contains = \"\", revision = \"0\" /* Legacy */ ) {\n    if (type[type.length - 1] === \"*\") {\n        type = type.slice(0, -1);\n    } else if (revision === \"1\" /* Active */ ) {\n        if (type === \"enum\") {\n            type = contains;\n        } else if (type.match(/^\\(.*\\)$/)) {\n            type = type.slice(1, -1);\n        }\n    }\n    if (dependencies.includes(type) || !types[type]) {\n        return dependencies;\n    }\n    return [\n        type,\n        ...types[type].reduce((previous, t)=>[\n                ...previous,\n                ...getDependencies(types, t.type, previous, t.contains, revision).filter((dependency)=>!previous.includes(dependency))\n            ], [])\n    ];\n}\nfunction getMerkleTreeType(types, ctx) {\n    if (ctx.parent && ctx.key) {\n        const parentType = types[ctx.parent];\n        const merkleType = parentType.find((t)=>t.name === ctx.key);\n        const isMerkleTree = isMerkleTreeType(merkleType);\n        if (!isMerkleTree) {\n            throw new Error(`${ctx.key} is not a merkle tree`);\n        }\n        if (merkleType.contains.endsWith(\"*\")) {\n            throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n        }\n        return merkleType.contains;\n    }\n    return \"raw\";\n}\nfunction encodeType(types, type, revision = \"0\" /* Legacy */ ) {\n    const [primary, ...dependencies] = getDependencies(types, type, void 0, void 0, revision);\n    const newTypes = !primary ? [] : [\n        primary,\n        ...dependencies.sort()\n    ];\n    const esc = revisionConfiguration[revision].escapeTypeString;\n    return newTypes.map((dependency)=>{\n        const dependencyElements = types[dependency].map((t)=>{\n            const targetType = t.type === \"enum\" && revision === \"1\" /* Active */  ? t.contains : t.type;\n            const typeString = targetType.match(/^\\(.*\\)$/) ? `(${targetType.slice(1, -1).split(\",\").map((e)=>e ? esc(e) : e).join(\",\")})` : esc(targetType);\n            return `${esc(t.name)}:${typeString}`;\n        });\n        return `${esc(dependency)}(${dependencyElements})`;\n    }).join(\"\");\n}\nfunction getTypeHash(types, type, revision = \"0\" /* Legacy */ ) {\n    return getSelectorFromName(encodeType(types, type, revision));\n}\nfunction encodeValue(types, type, data, ctx = {}, revision = \"0\" /* Legacy */ ) {\n    if (types[type]) {\n        return [\n            type,\n            getStructHash(types, type, data, revision)\n        ];\n    }\n    if (revisionConfiguration[revision].presetTypes[type]) {\n        return [\n            type,\n            getStructHash(revisionConfiguration[revision].presetTypes, type, data, revision)\n        ];\n    }\n    if (type.endsWith(\"*\")) {\n        const hashes = data.map((entry)=>encodeValue(types, type.slice(0, -1), entry, void 0, revision)[1]);\n        return [\n            type,\n            revisionConfiguration[revision].hashMethod(hashes)\n        ];\n    }\n    switch(type){\n        case \"enum\":\n            {\n                if (revision === \"1\" /* Active */ ) {\n                    const [variantKey, variantData] = Object.entries(data)[0];\n                    const parentType = types[ctx.parent][0];\n                    const enumType = types[parentType.contains];\n                    const variantType = enumType.find((t)=>t.name === variantKey);\n                    const variantIndex = enumType.indexOf(variantType);\n                    const encodedSubtypes = variantType.type.slice(1, -1).split(\",\").map((subtype, index)=>{\n                        if (!subtype) return subtype;\n                        const subtypeData = variantData[index];\n                        return encodeValue(types, subtype, subtypeData, void 0, revision)[1];\n                    });\n                    return [\n                        type,\n                        revisionConfiguration[revision].hashMethod([\n                            variantIndex,\n                            ...encodedSubtypes\n                        ])\n                    ];\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"merkletree\":\n            {\n                const merkleTreeType = getMerkleTreeType(types, ctx);\n                const structHashes = data.map((struct)=>{\n                    return encodeValue(types, merkleTreeType, struct, void 0, revision)[1];\n                });\n                const { root } = new MerkleTree(structHashes, revisionConfiguration[revision].hashMerkleMethod);\n                return [\n                    \"felt\",\n                    root\n                ];\n            }\n        case \"selector\":\n            {\n                return [\n                    \"felt\",\n                    prepareSelector(data)\n                ];\n            }\n        case \"string\":\n            {\n                if (revision === \"1\" /* Active */ ) {\n                    const byteArray = byteArrayFromString2(data);\n                    const elements = [\n                        byteArray.data.length,\n                        ...byteArray.data,\n                        byteArray.pending_word,\n                        byteArray.pending_word_len\n                    ];\n                    return [\n                        type,\n                        revisionConfiguration[revision].hashMethod(elements)\n                    ];\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"felt\":\n        case \"bool\":\n        case \"u128\":\n        case \"i128\":\n        case \"ContractAddress\":\n        case \"ClassHash\":\n        case \"timestamp\":\n        case \"shortstring\":\n            return [\n                type,\n                getHex(data)\n            ];\n        default:\n            {\n                if (revision === \"1\" /* Active */ ) {\n                    throw new Error(`Unsupported type: ${type}`);\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n    }\n}\nfunction encodeData(types, type, data, revision = \"0\" /* Legacy */ ) {\n    const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n    const [returnTypes, values] = targetType.reduce(([ts, vs], field)=>{\n        if (data[field.name] === void 0 || data[field.name] === null && field.type !== \"enum\") {\n            throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n        }\n        const value = data[field.name];\n        const ctx = {\n            parent: type,\n            key: field.name\n        };\n        const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n        return [\n            [\n                ...ts,\n                t\n            ],\n            [\n                ...vs,\n                encodedValue\n            ]\n        ];\n    }, [\n        [\n            \"felt\"\n        ],\n        [\n            getTypeHash(types, type, revision)\n        ]\n    ]);\n    return [\n        returnTypes,\n        values\n    ];\n}\nfunction getStructHash(types, type, data, revision = \"0\" /* Legacy */ ) {\n    return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\nfunction getMessageHash(typedData, account) {\n    if (!validateTypedData(typedData)) {\n        throw new Error(\"Typed data does not match JSON schema\");\n    }\n    const revision = identifyRevision(typedData);\n    const { domain, hashMethod } = revisionConfiguration[revision];\n    const message = [\n        encodeShortString(\"StarkNet Message\"),\n        getStructHash(typedData.types, domain, typedData.domain, revision),\n        account,\n        getStructHash(typedData.types, typedData.primaryType, typedData.message, revision)\n    ];\n    return hashMethod(message);\n}\n// src/signer/default.ts\nvar Signer = class {\n    constructor(pk = _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey()){\n        this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n    }\n    async getPubKey() {\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.getStarkKey(this.pk);\n    }\n    async signMessage(typedData, accountAddress) {\n        const msgHash = getMessageHash(typedData, accountAddress);\n        return this.signRaw(msgHash);\n    }\n    async signTransaction(transactions, details) {\n        const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n        let msgHash;\n        if (Object.values(ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateInvokeTransactionHash2({\n                ...det,\n                senderAddress: det.walletAddress,\n                compiledCalldata,\n                version: det.version\n            });\n        } else if (Object.values(ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateInvokeTransactionHash2({\n                ...det,\n                senderAddress: det.walletAddress,\n                compiledCalldata,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signTransaction version\");\n        }\n        return this.signRaw(msgHash);\n    }\n    async signDeployAccountTransaction(details) {\n        const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n        let msgHash;\n        if (Object.values(ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeployAccountTransactionHash3({\n                ...det,\n                salt: det.addressSalt,\n                constructorCalldata: compiledConstructorCalldata,\n                version: det.version\n            });\n        } else if (Object.values(ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeployAccountTransactionHash3({\n                ...det,\n                salt: det.addressSalt,\n                compiledConstructorCalldata,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signDeployAccountTransaction version\");\n        }\n        return this.signRaw(msgHash);\n    }\n    async signDeclareTransaction(details) {\n        let msgHash;\n        if (Object.values(ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeclareTransactionHash3({\n                ...det,\n                version: det.version\n            });\n        } else if (Object.values(ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeclareTransactionHash3({\n                ...det,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signDeclareTransaction version\");\n        }\n        return this.signRaw(msgHash);\n    }\n    async signRaw(msgHash) {\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n};\n// src/signer/ethSigner.ts\n\n// src/utils/eth.ts\nvar eth_exports = {};\n__export(eth_exports, {\n    ethRandomPrivateKey: ()=>ethRandomPrivateKey\n});\n\nfunction ethRandomPrivateKey() {\n    return sanitizeHex(buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.utils.randomPrivateKey()));\n}\n// src/signer/ethSigner.ts\nvar EthSigner = class {\n    // hex string without 0x and odd number of characters\n    constructor(pk = ethRandomPrivateKey()){\n        this.pk = pk instanceof Uint8Array ? removeHexPrefix(sanitizeHex(buf2hex(pk))) : removeHexPrefix(sanitizeHex(toHex(pk)));\n    }\n    async getPubKey() {\n        return addHexPrefix(buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.getPublicKey(this.pk)));\n    }\n    async signMessage(typedData, accountAddress) {\n        const msgHash = getMessageHash(typedData, accountAddress);\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n    }\n    async signTransaction(transactions, details) {\n        const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n        let msgHash;\n        if (Object.values(ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateInvokeTransactionHash2({\n                ...det,\n                senderAddress: det.walletAddress,\n                compiledCalldata,\n                version: det.version\n            });\n        } else if (Object.values(ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateInvokeTransactionHash2({\n                ...det,\n                senderAddress: det.walletAddress,\n                compiledCalldata,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signTransaction version\");\n        }\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n    }\n    async signDeployAccountTransaction(details) {\n        const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n        let msgHash;\n        if (Object.values(ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeployAccountTransactionHash3({\n                ...det,\n                salt: det.addressSalt,\n                constructorCalldata: compiledConstructorCalldata,\n                version: det.version\n            });\n        } else if (Object.values(ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeployAccountTransactionHash3({\n                ...det,\n                salt: det.addressSalt,\n                compiledConstructorCalldata,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signDeployAccountTransaction version\");\n        }\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n    }\n    async signDeclareTransaction(details) {\n        let msgHash;\n        if (Object.values(ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeclareTransactionHash3({\n                ...det,\n                version: det.version\n            });\n        } else if (Object.values(ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeclareTransactionHash3({\n                ...det,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signDeclareTransaction version\");\n        }\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n    }\n};\n// src/utils/events.ts\nfunction parseUDCEvent(txReceipt) {\n    if (!txReceipt.events) {\n        throw new Error(\"UDC emitted event is empty\");\n    }\n    const event = txReceipt.events.find((it)=>cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)) || {\n        data: []\n    };\n    return {\n        transaction_hash: txReceipt.transaction_hash,\n        contract_address: event.data[0],\n        address: event.data[0],\n        deployer: event.data[1],\n        unique: event.data[2],\n        classHash: event.data[3],\n        calldata_len: event.data[4],\n        calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n        salt: event.data[event.data.length - 1]\n    };\n}\n// src/account/default.ts\nvar Account = class extends RpcProvider2 {\n    constructor(providerOrOptions, address, pkOrSigner, cairoVersion, transactionVersion = \"0x2\" /* V2 */ ){\n        super(providerOrOptions);\n        this.deploySelf = this.deployAccount;\n        this.address = address.toLowerCase();\n        this.signer = typeof pkOrSigner === \"string\" || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n        if (cairoVersion) {\n            this.cairoVersion = cairoVersion.toString();\n        }\n        this.transactionVersion = transactionVersion;\n    }\n    // provided version or contract based preferred transactionVersion\n    getPreferredVersion(type12, type3) {\n        if (this.transactionVersion === \"0x3\" /* V3 */ ) return type3;\n        if (this.transactionVersion === \"0x2\" /* V2 */ ) return type12;\n        return \"0x3\" /* V3 */ ;\n    }\n    async getNonce(blockIdentifier) {\n        return super.getNonceForAddress(this.address, blockIdentifier);\n    }\n    async getNonceSafe(nonce) {\n        try {\n            return toBigInt(nonce ?? await this.getNonce());\n        } catch (error) {\n            return 0n;\n        }\n    }\n    /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */ async getCairoVersion(classHash) {\n        if (!this.cairoVersion) {\n            const { cairo } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n            this.cairoVersion = cairo;\n        }\n        return this.cairoVersion;\n    }\n    async estimateFee(calls, estimateFeeDetails = {}) {\n        return this.estimateInvokeFee(calls, estimateFeeDetails);\n    }\n    async estimateInvokeFee(calls, details = {}) {\n        const { nonce: providedNonce, blockIdentifier, version: providedVersion } = details;\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = toTransactionVersion(this.getPreferredVersion(\"0x100000000000000000000000000000001\" /* F1 */ , \"0x100000000000000000000000000000003\" /* F3 */ ), toFeeVersion(providedVersion));\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            ...v3Details(details),\n            walletAddress: this.address,\n            nonce,\n            maxFee: ZERO,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const invocation = await this.buildInvocation(transactions, signerDetails);\n        return super.getInvokeEstimateFee({\n            ...invocation\n        }, {\n            ...v3Details(details),\n            version,\n            nonce\n        }, blockIdentifier, details.skipValidate);\n    }\n    async estimateDeclareFee(payload, details = {}) {\n        const { blockIdentifier, nonce: providedNonce, version: providedVersion } = details;\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = toTransactionVersion(!isSierra(payload.contract) ? \"0x100000000000000000000000000000001\" /* F1 */  : this.getPreferredVersion(\"0x100000000000000000000000000000002\" /* F2 */ , \"0x100000000000000000000000000000003\" /* F3 */ ), toFeeVersion(providedVersion));\n        const chainId = await this.getChainId();\n        const declareContractTransaction = await this.buildDeclarePayload(payload, {\n            ...v3Details(details),\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            maxFee: ZERO,\n            cairoVersion: void 0\n        });\n        return super.getDeclareEstimateFee(declareContractTransaction, {\n            ...v3Details(details),\n            version,\n            nonce\n        }, blockIdentifier, details.skipValidate);\n    }\n    async estimateAccountDeployFee({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress }, details = {}) {\n        const { blockIdentifier, version: providedVersion } = details;\n        const version = toTransactionVersion(this.getPreferredVersion(\"0x100000000000000000000000000000001\" /* F1 */ , \"0x100000000000000000000000000000003\" /* F3 */ ), toFeeVersion(providedVersion));\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const payload = await this.buildAccountDeployPayload({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            contractAddress\n        }, {\n            ...v3Details(details),\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            // unused parameter\n            maxFee: ZERO,\n            cairoVersion: void 0\n        });\n        return super.getDeployAccountEstimateFee({\n            ...payload\n        }, {\n            ...v3Details(details),\n            version,\n            nonce\n        }, blockIdentifier, details.skipValidate);\n    }\n    async estimateDeployFee(payload, details = {}) {\n        const calls = this.buildUDCContractPayload(payload);\n        return this.estimateInvokeFee(calls, details);\n    }\n    async estimateFeeBulk(invocations, details = {}) {\n        const { nonce, blockIdentifier, version } = details;\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            ...v3Details(details),\n            versions: [\n                \"0x100000000000000000000000000000001\" /* F1 */ ,\n                // non-sierra\n                toTransactionVersion(this.getPreferredVersion(\"0x100000000000000000000000000000002\" /* F2 */ , \"0x100000000000000000000000000000003\" /* F3 */ ), version)\n            ],\n            nonce,\n            blockIdentifier\n        });\n        return super.getEstimateFeeBulk(accountInvocations, {\n            blockIdentifier,\n            skipValidate: details.skipValidate\n        });\n    }\n    async simulateTransaction(invocations, details = {}) {\n        const { nonce, blockIdentifier, skipValidate, skipExecute, version } = details;\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            ...v3Details(details),\n            versions: [\n                \"0x1\" /* V1 */ ,\n                // non-sierra\n                toTransactionVersion(this.getPreferredVersion(\"0x2\" /* V2 */ , \"0x3\" /* V3 */ ), version)\n            ],\n            nonce,\n            blockIdentifier\n        });\n        return super.getSimulateTransaction(accountInvocations, {\n            blockIdentifier,\n            skipValidate,\n            skipExecute\n        });\n    }\n    async execute(calls, abis = void 0, details = {}) {\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(details.nonce ?? await this.getNonce());\n        const version = toTransactionVersion(this.getPreferredVersion(\"0x1\" /* V1 */ , \"0x3\" /* V3 */ ), // TODO: does this depend on cairo version ?\n        details.version);\n        const estimate = await this.getUniversalSuggestedFee(version, {\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            payload: calls\n        }, {\n            ...details,\n            version\n        });\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            ...v3Details(details),\n            resourceBounds: estimate.resourceBounds,\n            walletAddress: this.address,\n            nonce,\n            maxFee: estimate.maxFee,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const signature = await this.signer.signTransaction(transactions, signerDetails, abis);\n        const calldata = getExecuteCalldata(transactions, await this.getCairoVersion());\n        return this.invokeFunction({\n            contractAddress: this.address,\n            calldata,\n            signature\n        }, {\n            ...v3Details(details),\n            resourceBounds: estimate.resourceBounds,\n            nonce,\n            maxFee: estimate.maxFee,\n            version\n        });\n    }\n    /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */ async declareIfNot(payload, transactionsDetail = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        try {\n            await this.getClassByHash(declareContractPayload.classHash);\n        } catch (error) {\n            return this.declare(payload, transactionsDetail);\n        }\n        return {\n            transaction_hash: \"\",\n            class_hash: declareContractPayload.classHash\n        };\n    }\n    async declare(payload, details = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        const { nonce, version: providedVersion } = details;\n        const version = toTransactionVersion(!isSierra(payload.contract) ? \"0x1\" /* V1 */  : this.getPreferredVersion(\"0x2\" /* V2 */ , \"0x3\" /* V3 */ ), providedVersion);\n        const estimate = await this.getUniversalSuggestedFee(version, {\n            type: \"DECLARE\" /* DECLARE */ ,\n            payload: declareContractPayload\n        }, {\n            ...details,\n            version\n        });\n        const declareDetails = {\n            ...v3Details(details),\n            resourceBounds: estimate.resourceBounds,\n            maxFee: estimate.maxFee,\n            nonce: toBigInt(nonce ?? await this.getNonce()),\n            version,\n            chainId: await this.getChainId(),\n            walletAddress: this.address,\n            cairoVersion: void 0\n        };\n        const declareContractTransaction = await this.buildDeclarePayload(declareContractPayload, declareDetails);\n        return this.declareContract(declareContractTransaction, declareDetails);\n    }\n    async deploy(payload, details = {}) {\n        const params = [].concat(payload).map((it)=>{\n            const { classHash, salt, unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            const deploySalt = salt ?? randomAddress();\n            return {\n                call: {\n                    contractAddress: UDC.ADDRESS,\n                    entrypoint: UDC.ENTRYPOINT,\n                    calldata: [\n                        classHash,\n                        deploySalt,\n                        toCairoBool(unique),\n                        compiledConstructorCallData.length,\n                        ...compiledConstructorCallData\n                    ]\n                },\n                address: calculateContractAddressFromHash(unique ? _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(this.address, deploySalt) : deploySalt, classHash, compiledConstructorCallData, unique ? UDC.ADDRESS : 0)\n            };\n        });\n        const calls = params.map((it)=>it.call);\n        const addresses = params.map((it)=>it.address);\n        const invokeResponse = await this.execute(calls, void 0, details);\n        return {\n            ...invokeResponse,\n            contract_address: addresses\n        };\n    }\n    async deployContract(payload, details = {}) {\n        const deployTx = await this.deploy(payload, details);\n        const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n        return parseUDCEvent(txReceipt);\n    }\n    async declareAndDeploy(payload, details = {}) {\n        const { constructorCalldata, salt, unique } = payload;\n        let declare = await this.declareIfNot(payload, details);\n        if (declare.transaction_hash !== \"\") {\n            const tx = await this.waitForTransaction(declare.transaction_hash);\n            declare = {\n                ...declare,\n                ...tx\n            };\n        }\n        const deploy = await this.deployContract({\n            classHash: declare.class_hash,\n            salt,\n            unique,\n            constructorCalldata\n        }, details);\n        return {\n            declare: {\n                ...declare\n            },\n            deploy\n        };\n    }\n    async deployAccount({ classHash, constructorCalldata = [], addressSalt = 0, contractAddress: providedContractAddress }, details = {}) {\n        const version = toTransactionVersion(this.getPreferredVersion(\"0x1\" /* V1 */ , \"0x3\" /* V3 */ ), details.version);\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const estimate = await this.getUniversalSuggestedFee(version, {\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            payload: {\n                classHash,\n                constructorCalldata: compiledCalldata,\n                addressSalt,\n                contractAddress\n            }\n        }, details);\n        const signature = await this.signer.signDeployAccountTransaction({\n            ...v3Details(details),\n            classHash,\n            constructorCalldata: compiledCalldata,\n            contractAddress,\n            addressSalt,\n            chainId,\n            resourceBounds: estimate.resourceBounds,\n            maxFee: estimate.maxFee,\n            version,\n            nonce\n        });\n        return this.deployAccountContract({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            signature\n        }, {\n            ...v3Details(details),\n            nonce,\n            resourceBounds: estimate.resourceBounds,\n            maxFee: estimate.maxFee,\n            version\n        });\n    }\n    async signMessage(typedData) {\n        return this.signer.signMessage(typedData, this.address);\n    }\n    async hashMessage(typedData) {\n        return getMessageHash(typedData, this.address);\n    }\n    async verifyMessageHash(hash, signature) {\n        try {\n            const resp = await this.callContract({\n                contractAddress: this.address,\n                entrypoint: \"isValidSignature\",\n                calldata: CallData.compile({\n                    hash: toBigInt(hash).toString(),\n                    signature: formatSignature(signature)\n                })\n            });\n            if (BigInt(resp[0]) === 0n) {\n                return false;\n            }\n            return true;\n        } catch (err) {\n            if ([\n                \"argent/invalid-signature\",\n                \"is invalid, with respect to the public key\"\n            ].some((errMessage)=>err.message.includes(errMessage))) {\n                return false;\n            }\n            throw Error(`Signature verification request is rejected by the network: ${err}`);\n        }\n    }\n    async verifyMessage(typedData, signature) {\n        const hash = await this.hashMessage(typedData);\n        return this.verifyMessageHash(hash, signature);\n    }\n    /*\n   * Support methods\n   */ async getUniversalSuggestedFee(version, { type, payload }, details) {\n        let maxFee = 0;\n        let resourceBounds = estimateFeeToBounds(ZERO);\n        if (version === \"0x3\" /* V3 */ ) {\n            resourceBounds = details.resourceBounds ?? (await this.getSuggestedFee({\n                type,\n                payload\n            }, details)).resourceBounds;\n        } else {\n            maxFee = details.maxFee ?? (await this.getSuggestedFee({\n                type,\n                payload\n            }, details)).suggestedMaxFee;\n        }\n        return {\n            maxFee,\n            resourceBounds\n        };\n    }\n    async getSuggestedFee({ type, payload }, details) {\n        let feeEstimate;\n        switch(type){\n            case \"INVOKE_FUNCTION\" /* INVOKE */ :\n                feeEstimate = await this.estimateInvokeFee(payload, details);\n                break;\n            case \"DECLARE\" /* DECLARE */ :\n                feeEstimate = await this.estimateDeclareFee(payload, details);\n                break;\n            case \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ :\n                feeEstimate = await this.estimateAccountDeployFee(payload, details);\n                break;\n            case \"DEPLOY\" /* DEPLOY */ :\n                feeEstimate = await this.estimateDeployFee(payload, details);\n                break;\n            default:\n                feeEstimate = {\n                    gas_consumed: 0n,\n                    gas_price: 0n,\n                    overall_fee: ZERO,\n                    unit: \"FRI\",\n                    suggestedMaxFee: ZERO,\n                    resourceBounds: estimateFeeToBounds(ZERO)\n                };\n                break;\n        }\n        return feeEstimate;\n    }\n    async buildInvocation(call, details) {\n        const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n        const signature = await this.signer.signTransaction(call, details);\n        return {\n            ...v3Details(details),\n            contractAddress: this.address,\n            calldata,\n            signature\n        };\n    }\n    async buildDeclarePayload(payload, details) {\n        const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n        const compressedCompiledContract = parseContract(contract);\n        if (typeof compiledClassHash === \"undefined\" && (details.version === \"0x100000000000000000000000000000003\" /* F3 */  || details.version === \"0x3\" /* V3 */ )) {\n            throw Error(\"V3 Transaction work with Cairo1 Contracts and require compiledClassHash\");\n        }\n        const signature = await this.signer.signDeclareTransaction({\n            ...details,\n            ...v3Details(details),\n            classHash,\n            compiledClassHash,\n            // TODO: TS Nekuzi da v2 nemora imat a v3 mora i da je throvano ako nije definiran\n            senderAddress: details.walletAddress\n        });\n        return {\n            senderAddress: details.walletAddress,\n            signature,\n            contract: compressedCompiledContract,\n            compiledClassHash\n        };\n    }\n    async buildAccountDeployPayload({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress: providedContractAddress }, details) {\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const signature = await this.signer.signDeployAccountTransaction({\n            ...details,\n            ...v3Details(details),\n            classHash,\n            contractAddress,\n            addressSalt,\n            constructorCalldata: compiledCalldata\n        });\n        return {\n            ...v3Details(details),\n            classHash,\n            addressSalt,\n            constructorCalldata: compiledCalldata,\n            signature\n        };\n    }\n    buildUDCContractPayload(payload) {\n        const calls = [].concat(payload).map((it)=>{\n            const { classHash, salt = \"0\", unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            return {\n                contractAddress: UDC.ADDRESS,\n                entrypoint: UDC.ENTRYPOINT,\n                calldata: [\n                    classHash,\n                    salt,\n                    toCairoBool(unique),\n                    compiledConstructorCallData.length,\n                    ...compiledConstructorCallData\n                ]\n            };\n        });\n        return calls;\n    }\n    async accountInvocationsFactory(invocations, details) {\n        const { nonce, blockIdentifier } = details;\n        const safeNonce = await this.getNonceSafe(nonce);\n        const chainId = await this.getChainId();\n        const versions = details.versions.map((it)=>toTransactionVersion(it));\n        const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n        const cairoVersion = invocations[0].type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */  ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n        return Promise.all([].concat(invocations).map(async (transaction, index)=>{\n            const txPayload = \"payload\" in transaction ? transaction.payload : transaction;\n            const signerDetails = {\n                ...v3Details(details),\n                walletAddress: this.address,\n                nonce: toBigInt(Number(safeNonce) + index),\n                maxFee: ZERO,\n                chainId,\n                cairoVersion,\n                version: \"\"\n            };\n            const common = {\n                type: transaction.type,\n                nonce: toBigInt(Number(safeNonce) + index),\n                blockIdentifier,\n                version: \"\"\n            };\n            if (transaction.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n                const versionX = reduceV2(versions[1]);\n                signerDetails.version = versionX;\n                common.version = versionX;\n                const payload = await this.buildInvocation([].concat(txPayload), signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction.type === \"DEPLOY\" /* DEPLOY */ ) {\n                const versionX = reduceV2(versions[1]);\n                signerDetails.version = versionX;\n                common.version = versionX;\n                const calls = this.buildUDCContractPayload(txPayload);\n                const payload = await this.buildInvocation(calls, signerDetails);\n                return {\n                    ...common,\n                    ...payload,\n                    type: \"INVOKE_FUNCTION\" /* INVOKE */ \n                };\n            }\n            if (transaction.type === \"DECLARE\" /* DECLARE */ ) {\n                const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];\n                signerDetails.version = versionX;\n                common.version = versionX;\n                const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n                const versionX = reduceV2(versions[1]);\n                signerDetails.version = versionX;\n                common.version = versionX;\n                const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n        }));\n    }\n    async getStarkName(address = this.address, StarknetIdContract2) {\n        return super.getStarkName(address, StarknetIdContract2);\n    }\n};\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n    getAbiEvents: ()=>getAbiEvents,\n    parseEvents: ()=>parseEvents\n});\nfunction getAbiEvents(abi) {\n    return abi.filter((abiEntry)=>abiEntry.type === \"event\" && (abiEntry.size || abiEntry.kind !== \"enum\")).reduce((acc, abiEntry)=>{\n        const entryName = abiEntry.name.slice(abiEntry.name.lastIndexOf(\":\") + 1);\n        const abiEntryMod = {\n            ...abiEntry\n        };\n        abiEntryMod.name = entryName;\n        return {\n            ...acc,\n            [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n        };\n    }, {});\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n    const ret = providerReceivedEvents.flat().reduce((acc, recEvent)=>{\n        const abiEvent = abiEvents[recEvent.keys[0]];\n        if (!abiEvent) {\n            return acc;\n        }\n        const parsedEvent = {};\n        parsedEvent[abiEvent.name] = {};\n        recEvent.keys.shift();\n        const keysIter = recEvent.keys[Symbol.iterator]();\n        const dataIter = recEvent.data[Symbol.iterator]();\n        const abiEventKeys = abiEvent.members?.filter((it)=>it.kind === \"key\") || abiEvent.keys;\n        const abiEventData = abiEvent.members?.filter((it)=>it.kind === \"data\") || abiEvent.data;\n        abiEventKeys.forEach((key)=>{\n            parsedEvent[abiEvent.name][key.name] = responseParser(keysIter, key, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        abiEventData.forEach((data)=>{\n            parsedEvent[abiEvent.name][data.name] = responseParser(dataIter, data, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        acc.push(parsedEvent);\n        return acc;\n    }, []);\n    return ret;\n}\n// src/contract/default.ts\nvar splitArgsAndOptions = (args)=>{\n    const options = [\n        \"blockIdentifier\",\n        \"parseRequest\",\n        \"parseResponse\",\n        \"formatResponse\",\n        \"maxFee\",\n        \"nonce\",\n        \"signature\",\n        \"addressSalt\"\n    ];\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === \"object\" && options.some((x)=>x in lastArg)) {\n        return {\n            args,\n            options: args.pop()\n        };\n    }\n    return {\n        args\n    };\n};\nfunction buildCall(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.call(functionAbi.name, params.args, {\n            parseRequest: true,\n            parseResponse: true,\n            ...params.options\n        });\n    };\n}\nfunction buildInvoke(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.invoke(functionAbi.name, params.args, {\n            parseRequest: true,\n            ...params.options\n        });\n    };\n}\nfunction buildDefault(contract, functionAbi) {\n    if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n        return buildCall(contract, functionAbi);\n    }\n    return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n    return function(...args) {\n        return contract.populate(functionAbi.name, args);\n    };\n}\nfunction buildEstimate(contract, functionAbi) {\n    return function(...args) {\n        return contract.estimate(functionAbi.name, args);\n    };\n}\nfunction getCalldata(args, callback) {\n    if (Array.isArray(args) && \"__compiled__\" in args) return args;\n    if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0]) return args[0];\n    return callback();\n}\nvar Contract = class {\n    /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */ constructor(abi, address, providerOrAccount = defaultProvider){\n        this.address = address && address.toLowerCase();\n        this.providerOrAccount = providerOrAccount;\n        this.callData = new CallData(abi);\n        this.structs = CallData.getAbiStruct(abi);\n        this.events = getAbiEvents(abi);\n        const parser = createAbiParser(abi);\n        this.abi = parser.getLegacyFormat();\n        const options = {\n            enumerable: true,\n            value: {},\n            writable: false\n        };\n        Object.defineProperties(this, {\n            functions: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            callStatic: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            populateTransaction: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            estimateFee: {\n                enumerable: true,\n                value: {},\n                writable: false\n            }\n        });\n        this.abi.forEach((abiElement)=>{\n            if (abiElement.type !== \"function\") return;\n            const signature = abiElement.name;\n            if (!this[signature]) {\n                Object.defineProperty(this, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.functions[signature]) {\n                Object.defineProperty(this.functions, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.callStatic[signature]) {\n                Object.defineProperty(this.callStatic, signature, {\n                    ...options,\n                    value: buildCall(this, abiElement)\n                });\n            }\n            if (!this.populateTransaction[signature]) {\n                Object.defineProperty(this.populateTransaction, signature, {\n                    ...options,\n                    value: buildPopulate(this, abiElement)\n                });\n            }\n            if (!this.estimateFee[signature]) {\n                Object.defineProperty(this.estimateFee, signature, {\n                    ...options,\n                    value: buildEstimate(this, abiElement)\n                });\n            }\n        });\n    }\n    attach(address) {\n        this.address = address;\n    }\n    connect(providerOrAccount) {\n        this.providerOrAccount = providerOrAccount;\n    }\n    async deployed() {\n        if (this.deployTransactionHash) {\n            await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n            this.deployTransactionHash = void 0;\n        }\n        return this;\n    }\n    async call(method, args = [], { parseRequest = true, parseResponse = true, formatResponse = void 0, blockIdentifier = void 0 } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"CALL\" /* CALL */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        return this.providerOrAccount.callContract({\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        }, blockIdentifier).then((it)=>{\n            if (!parseResponse) {\n                return it;\n            }\n            if (formatResponse) {\n                return this.callData.format(method, it, formatResponse);\n            }\n            return this.callData.parse(method, it);\n        });\n    }\n    invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        const invocation = {\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        };\n        if (\"execute\" in this.providerOrAccount) {\n            return this.providerOrAccount.execute(invocation, void 0, {\n                maxFee,\n                nonce\n            });\n        }\n        if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n        console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n        return this.providerOrAccount.invokeFunction({\n            ...invocation,\n            signature\n        }, {\n            nonce\n        });\n    }\n    async estimate(method, args = []) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        if (!getCalldata(args, ()=>false)) {\n            this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n        }\n        const invocation = this.populate(method, args);\n        if (\"estimateInvokeFee\" in this.providerOrAccount) {\n            return this.providerOrAccount.estimateInvokeFee(invocation);\n        }\n        throw Error(\"Contract must be connected to the account contract to estimate\");\n    }\n    populate(method, args = []) {\n        const calldata = getCalldata(args, ()=>this.callData.compile(method, args));\n        return {\n            contractAddress: this.address,\n            entrypoint: method,\n            calldata\n        };\n    }\n    parseEvents(receipt) {\n        return parseEvents(receipt.events?.filter((event)=>cleanHex(event.from_address) === cleanHex(this.address), []) || [], this.events, this.structs, CallData.getAbiEnum(this.abi));\n    }\n    isCairo1() {\n        return cairo_exports.isCairo1Abi(this.abi);\n    }\n    async getVersion() {\n        return this.providerOrAccount.getContractVersion(this.address);\n    }\n    typedv1(tAbi) {\n        return this;\n    }\n    typedv2(tAbi) {\n        return this;\n    }\n};\n// src/contract/interface.ts\nvar ContractInterface = class {\n};\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n    /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */ constructor(params){\n        this.compiledContract = params.compiledContract;\n        this.account = params.account;\n        this.casm = params.casm;\n        this.abi = params.abi ?? params.compiledContract.abi;\n        this.classHash = params.classHash;\n        this.compiledClassHash = params.compiledClassHash;\n        this.CallData = new CallData(this.abi);\n    }\n    /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */ async deploy(...args) {\n        const { args: param, options = {\n            parseRequest: true\n        } } = splitArgsAndOptions(args);\n        const constructorCalldata = getCalldata(param, ()=>{\n            if (options.parseRequest) {\n                this.CallData.validate(\"DEPLOY\" /* DEPLOY */ , \"constructor\", param);\n                return this.CallData.compile(\"constructor\", param);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return param;\n        });\n        const { deploy: { contract_address, transaction_hash } } = await this.account.declareAndDeploy({\n            contract: this.compiledContract,\n            casm: this.casm,\n            classHash: this.classHash,\n            compiledClassHash: this.compiledClassHash,\n            constructorCalldata,\n            salt: options.addressSalt\n        });\n        assert(Boolean(contract_address), \"Deployment of the contract failed\");\n        const contractInstance = new Contract(this.compiledContract.abi, contract_address, this.account);\n        contractInstance.deployTransactionHash = transaction_hash;\n        return contractInstance;\n    }\n    /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */ connect(account) {\n        this.account = account;\n        return this;\n    }\n    /**\n   * Attaches current abi and account to the new address\n   */ attach(address) {\n        return new Contract(this.abi, address, this.account);\n    }\n};\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n    UINT_128_MAX: ()=>UINT_128_MAX,\n    UINT_256_MAX: ()=>UINT_256_MAX,\n    bnToUint256: ()=>bnToUint256,\n    isUint256: ()=>isUint256,\n    uint256ToBN: ()=>uint256ToBN\n});\nfunction uint256ToBN(uint2562) {\n    return new CairoUint256(uint2562).toBigInt();\n}\nfunction isUint256(bn) {\n    return CairoUint256.is(bn);\n}\nfunction bnToUint256(bn) {\n    return new CairoUint256(bn).toUint256HexString();\n}\n// src/utils/address.ts\n\nfunction addAddressPadding(address) {\n    return addHexPrefix(removeHexPrefix(toHex(address)).padStart(64, \"0\"));\n}\nfunction validateAndParseAddress(address) {\n    assertInRange(address, ZERO, ADDR_BOUND - 1n, \"Starknet Address\");\n    const result = addAddressPadding(address);\n    if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n        throw new Error(\"Invalid Address Format\");\n    }\n    return result;\n}\nfunction getChecksumAddress(address) {\n    const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n    const hex = removeHexPrefix(keccakBn(address));\n    const hashed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(hex.padStart(64, \"0\"));\n    for(let i = 0; i < chars.length; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 15) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n    return getChecksumAddress(address) === address;\n}\n// src/utils/url.ts\n\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nfunction isUrl(s) {\n    if (!s) {\n        return false;\n    }\n    if (typeof s !== \"string\") {\n        return false;\n    }\n    const match = s.match(protocolAndDomainRE);\n    if (!match) {\n        return false;\n    }\n    const everythingAfterProtocol = match[1];\n    if (!everythingAfterProtocol) {\n        return false;\n    }\n    if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n        return true;\n    }\n    return false;\n}\nfunction buildUrl(baseUrl, defaultPath, urlOrPath) {\n    return isUrl(urlOrPath) ? urlOrPath : url_join__WEBPACK_IMPORTED_MODULE_10__(baseUrl, urlOrPath ?? defaultPath);\n}\n// src/index.ts\nvar number = num_exports;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZlosVUFBVVcsUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRU4sWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSVEsZ0JBQWdCLENBQUNYLEtBQUtDLEtBQUtDO0lBQzdCSCxnQkFBZ0JDLEtBQUssT0FBT0MsUUFBUSxXQUFXQSxNQUFNLEtBQUtBLEtBQUtDO0lBQy9ELE9BQU9BO0FBQ1Q7QUFFQSxtQkFBbUI7QUFDbkIsSUFBSVUsb0JBQW9CLENBQUM7QUFDekJOLFNBQVNNLG1CQUFtQjtJQUMxQkMsWUFBWSxJQUFNQTtJQUNsQkMsYUFBYSxJQUFNQTtJQUNuQkMsU0FBUyxJQUFNQTtJQUNmQyxZQUFZLElBQU1BO0lBQ2xCQyxVQUFVLElBQU1BO0lBQ2hCQyx1QkFBdUIsSUFBTUE7SUFDN0JDLGFBQWEsSUFBTUE7SUFDbkJDLHFCQUFxQixJQUFNQTtJQUMzQkMsV0FBVyxJQUFNQTtJQUNqQkMsaUJBQWlCLElBQU1BO0lBQ3ZCQyxzQkFBc0IsSUFBTUE7SUFDNUJDLHFCQUFxQixJQUFNQztJQUMzQkMsdUJBQXVCLElBQU1BO0lBQzdCQyxLQUFLLElBQU1BO0lBQ1hDLE1BQU0s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LENBQUM7SUFDZCxJQUFJLENBQUNBLEdBQUc7UUFDTixPQUFPO0lBQ1Q7SUFDQSxJQUFJLE9BQU9BLE1BQU0sVUFBVTtRQUN6QixPQUFPO0lBQ1Q7SUFDQSxNQUFNM0osUUFBUTJKLEVBQUUzSixLQUFLLENBQUM2K0I7SUFDdEIsSUFBSSxDQUFDNytCLE9BQU87UUFDVixPQUFPO0lBQ1Q7SUFDQSxNQUFNaS9CLDBCQUEwQmovQixLQUFLLENBQUMsRUFBRTtJQUN4QyxJQUFJLENBQUNpL0IseUJBQXlCO1FBQzVCLE9BQU87SUFDVDtJQUNBLElBQUlILGtCQUFrQnJtQyxJQUFJLENBQUN3bUMsNEJBQTRCRixxQkFBcUJ0bUMsSUFBSSxDQUFDd21DLDBCQUEwQjtRQUN6RyxPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTQyxTQUFTQyxPQUFPLEVBQUVDLFdBQVcsRUFBRUMsU0FBUztJQUMvQyxPQUFPTCxNQUFNSyxhQUFhQSxZQUFZVCxzQ0FBT0EsQ0FBQ08sU0FBU0UsYUFBYUQ7QUFDdEU7QUFFQSxlQUFlO0FBQ2YsSUFBSXBkLFNBQVMvbEI7QUEyRVgsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYWlyby1ib2lsZXJwbGF0ZS1yZWFjdC1uZXh0Ly4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L2Rpc3QvaW5kZXgubWpzP2NlOTciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgY29uc3RhbnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbnN0YW50c19leHBvcnRzLCB7XG4gIEFERFJfQk9VTkQ6ICgpID0+IEFERFJfQk9VTkQsXG4gIEFQSV9WRVJTSU9OOiAoKSA9PiBBUElfVkVSU0lPTixcbiAgQmFzZVVybDogKCkgPT4gQmFzZVVybCxcbiAgSVNfQlJPV1NFUjogKCkgPT4gSVNfQlJPV1NFUixcbiAgTUFTS18yNTA6ICgpID0+IE1BU0tfMjUwLFxuICBNQVhfU1RPUkFHRV9JVEVNX1NJWkU6ICgpID0+IE1BWF9TVE9SQUdFX0lURU1fU0laRSxcbiAgTmV0d29ya05hbWU6ICgpID0+IE5ldHdvcmtOYW1lLFxuICBSUENfREVGQVVMVF9WRVJTSU9OOiAoKSA9PiBSUENfREVGQVVMVF9WRVJTSU9OLFxuICBSUENfTk9ERVM6ICgpID0+IFJQQ19OT0RFUyxcbiAgU3RhcmtuZXRDaGFpbklkOiAoKSA9PiBTdGFya25ldENoYWluSWQsXG4gIFRFWFRfVE9fRkVMVF9NQVhfTEVOOiAoKSA9PiBURVhUX1RPX0ZFTFRfTUFYX0xFTixcbiAgVFJBTlNBQ1RJT05fVkVSU0lPTjogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbixcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4OiAoKSA9PiBUcmFuc2FjdGlvbkhhc2hQcmVmaXgsXG4gIFVEQzogKCkgPT4gVURDLFxuICBaRVJPOiAoKSA9PiBaRVJPXG59KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9pbmRleC50c1xudmFyIGFwaV9leHBvcnRzID0ge307XG5fX2V4cG9ydChhcGlfZXhwb3J0cywge1xuICBFQmxvY2tUYWc6ICgpID0+IEVCbG9ja1RhZyxcbiAgRURBTW9kZTogKCkgPT4gRURBTW9kZSxcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlOiAoKSA9PiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gIEVTaW11bGF0aW9uRmxhZzogKCkgPT4gRVNpbXVsYXRpb25GbGFnLFxuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBFVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uVHlwZTogKCkgPT4gRVRyYW5zYWN0aW9uVHlwZSxcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbixcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI6ICgpID0+IEVUcmFuc2FjdGlvblZlcnNpb24yLFxuICBFVHJhbnNhY3Rpb25WZXJzaW9uMzogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbjMsXG4gIEVycm9yczogKCkgPT4gZXJyb3JzX2V4cG9ydHMsXG4gIEpSUEM6ICgpID0+IGpzb25ycGNfZXhwb3J0cyxcbiAgU1BFQzogKCkgPT4gY29tcG9uZW50c19leHBvcnRzXG59KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9qc29ucnBjL2luZGV4LnRzXG52YXIganNvbnJwY19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvZXJyb3JzLnRzXG52YXIgZXJyb3JzX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGNzcGVjXzBfNi9jb21wb25lbnRzLnRzXG52YXIgY29tcG9uZW50c19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvbm9uc3BlYy50c1xudmFyIEVUcmFuc2FjdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25UeXBlMikgPT4ge1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFQ0xBUkVcIl0gPSBcIkRFQ0xBUkVcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCJERVBMT1lfQUNDT1VOVFwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIklOVk9LRVwiXSA9IFwiSU5WT0tFXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiTDFfSEFORExFUlwiXSA9IFwiTDFfSEFORExFUlwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uVHlwZTI7XG59KShFVHJhbnNhY3Rpb25UeXBlIHx8IHt9KTtcbnZhciBFU2ltdWxhdGlvbkZsYWcgPSAvKiBAX19QVVJFX18gKi8gKChFU2ltdWxhdGlvbkZsYWcyKSA9PiB7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX1ZBTElEQVRFXCJdID0gXCJTS0lQX1ZBTElEQVRFXCI7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX0ZFRV9DSEFSR0VcIl0gPSBcIlNLSVBfRkVFX0NIQVJHRVwiO1xuICByZXR1cm4gRVNpbXVsYXRpb25GbGFnMjtcbn0pKEVTaW11bGF0aW9uRmxhZyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25TdGF0dXMyO1xufSkoRVRyYW5zYWN0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czI7XG59KShFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiU1VDQ0VFREVEXCJdID0gXCJTVUNDRUVERURcIjtcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMjtcbn0pKEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyB8fCB7fSk7XG52YXIgRUJsb2NrVGFnID0gLyogQF9fUFVSRV9fICovICgoRUJsb2NrVGFnMikgPT4ge1xuICBFQmxvY2tUYWcyW1wiTEFURVNUXCJdID0gXCJsYXRlc3RcIjtcbiAgRUJsb2NrVGFnMltcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgcmV0dXJuIEVCbG9ja1RhZzI7XG59KShFQmxvY2tUYWcgfHwge30pO1xudmFyIEVEYXRhQXZhaWxhYmlsaXR5TW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVEYXRhQXZhaWxhYmlsaXR5TW9kZTIpID0+IHtcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlMltcIkwxXCJdID0gXCJMMVwiO1xuICBFRGF0YUF2YWlsYWJpbGl0eU1vZGUyW1wiTDJcIl0gPSBcIkwyXCI7XG4gIHJldHVybiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUyO1xufSkoRURhdGFBdmFpbGFiaWxpdHlNb2RlIHx8IHt9KTtcbnZhciBFREFNb2RlID0gLyogQF9fUFVSRV9fICovICgoRURBTW9kZTMpID0+IHtcbiAgRURBTW9kZTNbRURBTW9kZTNbXCJMMVwiXSA9IDBdID0gXCJMMVwiO1xuICBFREFNb2RlM1tFREFNb2RlM1tcIkwyXCJdID0gMV0gPSBcIkwyXCI7XG4gIHJldHVybiBFREFNb2RlMztcbn0pKEVEQU1vZGUgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvblZlcnNpb24gPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25WZXJzaW9uNCkgPT4ge1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uNFtcIlYwXCJdID0gXCIweDBcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjRbXCJWMVwiXSA9IFwiMHgxXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb240W1wiVjJcIl0gPSBcIjB4MlwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uNFtcIlYzXCJdID0gXCIweDNcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjRbXCJGMFwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjRbXCJGMVwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjRbXCJGMlwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjRbXCJGM1wiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblZlcnNpb240O1xufSkoRVRyYW5zYWN0aW9uVmVyc2lvbiB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uVmVyc2lvbjIgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25WZXJzaW9uMjMpID0+IHtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjIzW1wiVjBcIl0gPSBcIjB4MFwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMjNbXCJWMVwiXSA9IFwiMHgxXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24yM1tcIlYyXCJdID0gXCIweDJcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjIzW1wiRjBcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24yM1tcIkYxXCJdID0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMjNbXCJGMlwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblZlcnNpb24yMztcbn0pKEVUcmFuc2FjdGlvblZlcnNpb24yIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25WZXJzaW9uMyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvblZlcnNpb24zMykgPT4ge1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMzNbXCJWM1wiXSA9IFwiMHgzXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24zM1tcIkYzXCJdID0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM1wiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uVmVyc2lvbjMzO1xufSkoRVRyYW5zYWN0aW9uVmVyc2lvbjMgfHwge30pO1xuXG4vLyBzcmMvdXRpbHMvZW5jb2RlLnRzXG52YXIgZW5jb2RlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVuY29kZV9leHBvcnRzLCB7XG4gIElTX0JST1dTRVI6ICgpID0+IElTX0JST1dTRVIsXG4gIGFkZEhleFByZWZpeDogKCkgPT4gYWRkSGV4UHJlZml4LFxuICBhcnJheUJ1ZmZlclRvU3RyaW5nOiAoKSA9PiBhcnJheUJ1ZmZlclRvU3RyaW5nLFxuICBhdG9iVW5pdmVyc2FsOiAoKSA9PiBhdG9iVW5pdmVyc2FsLFxuICBidG9hVW5pdmVyc2FsOiAoKSA9PiBidG9hVW5pdmVyc2FsLFxuICBidWYyaGV4OiAoKSA9PiBidWYyaGV4LFxuICBjYWxjQnl0ZUxlbmd0aDogKCkgPT4gY2FsY0J5dGVMZW5ndGgsXG4gIHBhZExlZnQ6ICgpID0+IHBhZExlZnQsXG4gIHBhc2NhbFRvU25ha2U6ICgpID0+IHBhc2NhbFRvU25ha2UsXG4gIHJlbW92ZUhleFByZWZpeDogKCkgPT4gcmVtb3ZlSGV4UHJlZml4LFxuICBzYW5pdGl6ZUJ5dGVzOiAoKSA9PiBzYW5pdGl6ZUJ5dGVzLFxuICBzYW5pdGl6ZUhleDogKCkgPT4gc2FuaXRpemVIZXgsXG4gIHN0cmluZ1RvQXJyYXlCdWZmZXI6ICgpID0+IHN0cmluZ1RvQXJyYXlCdWZmZXIsXG4gIHV0ZjhUb0FycmF5OiAoKSA9PiB1dGY4VG9BcnJheVxufSk7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBTVFJJTkdfWkVSTyA9IFwiMFwiO1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb1N0cmluZyhhcnJheSkge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpLnJlZHVjZSgoZGF0YSwgYnl0ZSkgPT4gZGF0YSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSksIFwiXCIpO1xufVxuZnVuY3Rpb24gdXRmOFRvQXJyYXkoc3RyKSB7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlCdWZmZXIoc3RyKSB7XG4gIHJldHVybiB1dGY4VG9BcnJheShzdHIpO1xufVxuZnVuY3Rpb24gYXRvYlVuaXZlcnNhbChhKSB7XG4gIHJldHVybiBiYXNlNjQuZGVjb2RlKGEpO1xufVxuZnVuY3Rpb24gYnRvYVVuaXZlcnNhbChiKSB7XG4gIHJldHVybiBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGIpKTtcbn1cbmZ1bmN0aW9uIGJ1ZjJoZXgoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIucmVkdWNlKChyLCB4KSA9PiByICsgeC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUhleFByZWZpeChoZXgpIHtcbiAgcmV0dXJuIGhleC5yZXBsYWNlKC9eMHgvaSwgXCJcIik7XG59XG5mdW5jdGlvbiBhZGRIZXhQcmVmaXgoaGV4KSB7XG4gIHJldHVybiBgMHgke3JlbW92ZUhleFByZWZpeChoZXgpfWA7XG59XG5mdW5jdGlvbiBwYWRTdHJpbmcoc3RyLCBsZW5ndGgsIGxlZnQsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICBjb25zdCBkaWZmID0gbGVuZ3RoIC0gc3RyLmxlbmd0aDtcbiAgbGV0IHJlc3VsdCA9IHN0cjtcbiAgaWYgKGRpZmYgPiAwKSB7XG4gICAgY29uc3QgcGFkID0gcGFkZGluZy5yZXBlYXQoZGlmZik7XG4gICAgcmVzdWx0ID0gbGVmdCA/IHBhZCArIHN0ciA6IHN0ciArIHBhZDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFkTGVmdChzdHIsIGxlbmd0aCwgcGFkZGluZyA9IFNUUklOR19aRVJPKSB7XG4gIHJldHVybiBwYWRTdHJpbmcoc3RyLCBsZW5ndGgsIHRydWUsIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gY2FsY0J5dGVMZW5ndGgoc3RyLCBieXRlU2l6ZSA9IDgpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IHN0cjtcbiAgY29uc3QgcmVtYWluZGVyID0gbGVuZ3RoICUgYnl0ZVNpemU7XG4gIHJldHVybiByZW1haW5kZXIgPyAobGVuZ3RoIC0gcmVtYWluZGVyKSAvIGJ5dGVTaXplICogYnl0ZVNpemUgKyBieXRlU2l6ZSA6IGxlbmd0aDtcbn1cbmZ1bmN0aW9uIHNhbml0aXplQnl0ZXMoc3RyLCBieXRlU2l6ZSA9IDgsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICByZXR1cm4gcGFkTGVmdChzdHIsIGNhbGNCeXRlTGVuZ3RoKHN0ciwgYnl0ZVNpemUpLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplSGV4KGhleCkge1xuICBoZXggPSByZW1vdmVIZXhQcmVmaXgoaGV4KTtcbiAgaGV4ID0gc2FuaXRpemVCeXRlcyhoZXgsIDIpO1xuICBpZiAoaGV4KSB7XG4gICAgaGV4ID0gYWRkSGV4UHJlZml4KGhleCk7XG4gIH1cbiAgcmV0dXJuIGhleDtcbn1cbnZhciBwYXNjYWxUb1NuYWtlID0gKHRleHQpID0+IC9bYS16XS8udGVzdCh0ZXh0KSA/IHRleHQuc3BsaXQoLyg/PVtBLVpdKS8pLmpvaW4oXCJfXCIpLnRvVXBwZXJDYXNlKCkgOiB0ZXh0O1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgVEVYVF9UT19GRUxUX01BWF9MRU4gPSAzMTtcbnZhciBaRVJPID0gMG47XG52YXIgTUFTS18yNTAgPSAybiAqKiAyNTBuIC0gMW47XG52YXIgQVBJX1ZFUlNJT04gPSBaRVJPO1xudmFyIE1BWF9TVE9SQUdFX0lURU1fU0laRSA9IDI1Nm47XG52YXIgQUREUl9CT1VORCA9IDJuICoqIDI1MW4gLSBNQVhfU1RPUkFHRV9JVEVNX1NJWkU7XG52YXIgQmFzZVVybCA9IC8qIEBfX1BVUkVfXyAqLyAoKEJhc2VVcmwyKSA9PiB7XG4gIEJhc2VVcmwyW1wiU05fTUFJTlwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1tYWlubmV0LnN0YXJrbmV0LmlvXCI7XG4gIEJhc2VVcmwyW1wiU05fR09FUkxJXCJdID0gXCJodHRwczovL2FscGhhNC5zdGFya25ldC5pb1wiO1xuICBCYXNlVXJsMltcIlNOX1NFUE9MSUFcIl0gPSBcImh0dHBzOi8vYWxwaGEtc2Vwb2xpYS5zdGFya25ldC5pb1wiO1xuICByZXR1cm4gQmFzZVVybDI7XG59KShCYXNlVXJsIHx8IHt9KTtcbnZhciBOZXR3b3JrTmFtZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ldHdvcmtOYW1lMikgPT4ge1xuICBOZXR3b3JrTmFtZTJbXCJTTl9NQUlOXCJdID0gXCJTTl9NQUlOXCI7XG4gIE5ldHdvcmtOYW1lMltcIlNOX0dPRVJMSVwiXSA9IFwiU05fR09FUkxJXCI7XG4gIE5ldHdvcmtOYW1lMltcIlNOX1NFUE9MSUFcIl0gPSBcIlNOX1NFUE9MSUFcIjtcbiAgcmV0dXJuIE5ldHdvcmtOYW1lMjtcbn0pKE5ldHdvcmtOYW1lIHx8IHt9KTtcbnZhciBTdGFya25ldENoYWluSWQgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldENoYWluSWQ1KSA9PiB7XG4gIFN0YXJrbmV0Q2hhaW5JZDVbXCJTTl9NQUlOXCJdID0gXCIweDUzNGU1ZjRkNDE0OTRlXCI7XG4gIFN0YXJrbmV0Q2hhaW5JZDVbXCJTTl9HT0VSTElcIl0gPSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCI7XG4gIFN0YXJrbmV0Q2hhaW5JZDVbXCJTTl9TRVBPTElBXCJdID0gXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCI7XG4gIHJldHVybiBTdGFya25ldENoYWluSWQ1O1xufSkoU3RhcmtuZXRDaGFpbklkIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkhhc2hQcmVmaXggPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkhhc2hQcmVmaXgyKSA9PiB7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERUNMQVJFXCJdID0gXCIweDY0NjU2MzZjNjE3MjY1XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERVBMT1lcIl0gPSBcIjB4NjQ2NTcwNmM2Zjc5XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERVBMT1lfQUNDT1VOVFwiXSA9IFwiMHg2NDY1NzA2YzZmNzk1ZjYxNjM2MzZmNzU2ZTc0XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJJTlZPS0VcIl0gPSBcIjB4Njk2ZTc2NmY2YjY1XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJMMV9IQU5ETEVSXCJdID0gXCIweDZjMzE1ZjY4NjE2ZTY0NmM2NTcyXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyO1xufSkoVHJhbnNhY3Rpb25IYXNoUHJlZml4IHx8IHt9KTtcbnZhciBVREMgPSB7XG4gIEFERFJFU1M6IFwiMHgwNDFhNzhlNzQxZTVhZjJmZWMzNGI2OTU2NzliYzY4OTE3NDI0MzlmN2FmYjg0ODRlY2Q3NzY2NjYxYWQwMmJmXCIsXG4gIEVOVFJZUE9JTlQ6IFwiZGVwbG95Q29udHJhY3RcIlxufTtcbnZhciBSUENfREVGQVVMVF9WRVJTSU9OID0gXCJ2MF82XCI7XG52YXIgUlBDX05PREVTID0ge1xuICBTTl9HT0VSTEk6IFtcbiAgICBgaHR0cHM6Ly9zdGFya25ldC10ZXN0bmV0LnB1YmxpYy5ibGFzdGFwaS5pby9ycGMvJHtSUENfREVGQVVMVF9WRVJTSU9OfWAsXG4gICAgYGh0dHBzOi8vZnJlZS1ycGMubmV0aGVybWluZC5pby9nb2VybGktanVuby8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YFxuICBdLFxuICBTTl9NQUlOOiBbXG4gICAgYGh0dHBzOi8vc3RhcmtuZXQtbWFpbm5ldC5wdWJsaWMuYmxhc3RhcGkuaW8vcnBjLyR7UlBDX0RFRkFVTFRfVkVSU0lPTn1gLFxuICAgIGBodHRwczovL2ZyZWUtcnBjLm5ldGhlcm1pbmQuaW8vbWFpbm5ldC1qdW5vLyR7UlBDX0RFRkFVTFRfVkVSU0lPTn1gXG4gIF0sXG4gIFNOX1NFUE9MSUE6IFtcbiAgICBgaHR0cHM6Ly9zdGFya25ldC1zZXBvbGlhLnB1YmxpYy5ibGFzdGFwaS5pby9ycGMvJHtSUENfREVGQVVMVF9WRVJTSU9OfWAsXG4gICAgYGh0dHBzOi8vZnJlZS1ycGMubmV0aGVybWluZC5pby9zZXBvbGlhLWp1bm8vJHtSUENfREVGQVVMVF9WRVJTSU9OfWBcbiAgXVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2Vycm9ycy50c1xuZnVuY3Rpb24gZml4U3RhY2sodGFyZ2V0LCBmbiA9IHRhcmdldC5jb25zdHJ1Y3Rvcikge1xuICBjb25zdCB7IGNhcHR1cmVTdGFja1RyYWNlIH0gPSBFcnJvcjtcbiAgY2FwdHVyZVN0YWNrVHJhY2UgJiYgY2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0LCBmbik7XG59XG5mdW5jdGlvbiBmaXhQcm90byh0YXJnZXQsIHByb3RvdHlwZSkge1xuICBjb25zdCB7IHNldFByb3RvdHlwZU9mIH0gPSBPYmplY3Q7XG4gIHNldFByb3RvdHlwZU9mID8gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90b3R5cGUpIDogdGFyZ2V0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbn1cbnZhciBDdXN0b21FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICB2YWx1ZTogbmV3LnRhcmdldC5uYW1lLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBmaXhQcm90byh0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgZml4U3RhY2sodGhpcyk7XG4gIH1cbn07XG52YXIgTGlicmFyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBDdXN0b21FcnJvciB7XG59O1xudmFyIEdhdGV3YXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgTGlicmFyeUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JDb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gIH1cbn07XG52YXIgSHR0cEVycm9yID0gY2xhc3MgZXh0ZW5kcyBMaWJyYXJ5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvckNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL2luZGV4LnRzXG52YXIgdHlwZXNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZXNfZXhwb3J0cywge1xuICBCbG9ja1N0YXR1czogKCkgPT4gQmxvY2tTdGF0dXMsXG4gIEJsb2NrVGFnOiAoKSA9PiBCbG9ja1RhZyxcbiAgRW50cnlQb2ludFR5cGU6ICgpID0+IEVudHJ5UG9pbnRUeXBlLFxuICBMaXRlcmFsOiAoKSA9PiBMaXRlcmFsLFxuICBSUEM6ICgpID0+IGFwaV9leHBvcnRzLFxuICBTSU1VTEFUSU9OX0ZMQUc6ICgpID0+IFNJTVVMQVRJT05fRkxBRyxcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBUcmFuc2FjdGlvblN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uVHlwZTogKCkgPT4gVHJhbnNhY3Rpb25UeXBlLFxuICBUeXBlZERhdGFSZXZpc2lvbjogKCkgPT4gVHlwZWREYXRhUmV2aXNpb24sXG4gIFVpbnQ6ICgpID0+IFVpbnQsXG4gIFZhbGlkYXRlVHlwZTogKCkgPT4gVmFsaWRhdGVUeXBlXG59KTtcblxuLy8gc3JjL3R5cGVzL2FjY291bnQudHNcbnZhciBTSU1VTEFUSU9OX0ZMQUcgPSAvKiBAX19QVVJFX18gKi8gKChTSU1VTEFUSU9OX0ZMQUcyKSA9PiB7XG4gIFNJTVVMQVRJT05fRkxBRzJbXCJTS0lQX1ZBTElEQVRFXCJdID0gXCJTS0lQX1ZBTElEQVRFXCI7XG4gIFNJTVVMQVRJT05fRkxBRzJbXCJTS0lQX0VYRUNVVEVcIl0gPSBcIlNLSVBfRVhFQ1VURVwiO1xuICByZXR1cm4gU0lNVUxBVElPTl9GTEFHMjtcbn0pKFNJTVVMQVRJT05fRkxBRyB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9jYWxsZGF0YS50c1xudmFyIFZhbGlkYXRlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFZhbGlkYXRlVHlwZTIpID0+IHtcbiAgVmFsaWRhdGVUeXBlMltcIkRFUExPWVwiXSA9IFwiREVQTE9ZXCI7XG4gIFZhbGlkYXRlVHlwZTJbXCJDQUxMXCJdID0gXCJDQUxMXCI7XG4gIFZhbGlkYXRlVHlwZTJbXCJJTlZPS0VcIl0gPSBcIklOVk9LRVwiO1xuICByZXR1cm4gVmFsaWRhdGVUeXBlMjtcbn0pKFZhbGlkYXRlVHlwZSB8fCB7fSk7XG52YXIgVWludCA9IC8qIEBfX1BVUkVfXyAqLyAoKFVpbnQyKSA9PiB7XG4gIFVpbnQyW1widThcIl0gPSBcImNvcmU6OmludGVnZXI6OnU4XCI7XG4gIFVpbnQyW1widTE2XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MTZcIjtcbiAgVWludDJbXCJ1MzJcIl0gPSBcImNvcmU6OmludGVnZXI6OnUzMlwiO1xuICBVaW50MltcInU2NFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTY0XCI7XG4gIFVpbnQyW1widTEyOFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiO1xuICBVaW50MltcInUyNTZcIl0gPSBcImNvcmU6OmludGVnZXI6OnUyNTZcIjtcbiAgcmV0dXJuIFVpbnQyO1xufSkoVWludCB8fCB7fSk7XG52YXIgTGl0ZXJhbCA9IC8qIEBfX1BVUkVfXyAqLyAoKExpdGVyYWwyKSA9PiB7XG4gIExpdGVyYWwyW1wiQ2xhc3NIYXNoXCJdID0gXCJjb3JlOjpzdGFya25ldDo6Y2xhc3NfaGFzaDo6Q2xhc3NIYXNoXCI7XG4gIExpdGVyYWwyW1wiQ29udHJhY3RBZGRyZXNzXCJdID0gXCJjb3JlOjpzdGFya25ldDo6Y29udHJhY3RfYWRkcmVzczo6Q29udHJhY3RBZGRyZXNzXCI7XG4gIHJldHVybiBMaXRlcmFsMjtcbn0pKExpdGVyYWwgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvbGliL2NvbnRyYWN0L2luZGV4LnRzXG52YXIgRW50cnlQb2ludFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFbnRyeVBvaW50VHlwZTIpID0+IHtcbiAgRW50cnlQb2ludFR5cGUyW1wiRVhURVJOQUxcIl0gPSBcIkVYVEVSTkFMXCI7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkwxX0hBTkRMRVJcIl0gPSBcIkwxX0hBTkRMRVJcIjtcbiAgRW50cnlQb2ludFR5cGUyW1wiQ09OU1RSVUNUT1JcIl0gPSBcIkNPTlNUUlVDVE9SXCI7XG4gIHJldHVybiBFbnRyeVBvaW50VHlwZTI7XG59KShFbnRyeVBvaW50VHlwZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9saWIvaW5kZXgudHNcbnZhciBUcmFuc2FjdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvblR5cGUyKSA9PiB7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJERUNMQVJFXCJdID0gXCJERUNMQVJFXCI7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZX0FDQ09VTlRcIl0gPSBcIkRFUExPWV9BQ0NPVU5UXCI7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJJTlZPS0VcIl0gPSBcIklOVk9LRV9GVU5DVElPTlwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlMjtcbn0pKFRyYW5zYWN0aW9uVHlwZSB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25TdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvblN0YXR1czIpID0+IHtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiTk9UX1JFQ0VJVkVEXCJdID0gXCJOT1RfUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXMyO1xufSkoVHJhbnNhY3Rpb25TdGF0dXMgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMikgPT4ge1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIk5PVF9SRUNFSVZFRFwiXSA9IFwiTk9UX1JFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMjtcbn0pKFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyKSA9PiB7XG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJSRVZFUlRFRFwiXSA9IFwiUkVWRVJURURcIjtcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiU1VDQ0VFREVEXCJdID0gXCJTVUNDRUVERURcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMjtcbn0pKFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBCbG9ja1N0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEJsb2NrU3RhdHVzMikgPT4ge1xuICBCbG9ja1N0YXR1czJbXCJQRU5ESU5HXCJdID0gXCJQRU5ESU5HXCI7XG4gIEJsb2NrU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICBCbG9ja1N0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgQmxvY2tTdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIHJldHVybiBCbG9ja1N0YXR1czI7XG59KShCbG9ja1N0YXR1cyB8fCB7fSk7XG52YXIgQmxvY2tUYWcgPSAvKiBAX19QVVJFX18gKi8gKChCbG9ja1RhZzIpID0+IHtcbiAgQmxvY2tUYWcyW1wicGVuZGluZ1wiXSA9IFwicGVuZGluZ1wiO1xuICBCbG9ja1RhZzJbXCJsYXRlc3RcIl0gPSBcImxhdGVzdFwiO1xuICByZXR1cm4gQmxvY2tUYWcyO1xufSkoQmxvY2tUYWcgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvdHlwZWREYXRhLnRzXG52YXIgVHlwZWREYXRhUmV2aXNpb24gPSAvKiBAX19QVVJFX18gKi8gKChUeXBlZERhdGFSZXZpc2lvbjIpID0+IHtcbiAgVHlwZWREYXRhUmV2aXNpb24yW1wiQWN0aXZlXCJdID0gXCIxXCI7XG4gIFR5cGVkRGF0YVJldmlzaW9uMltcIkxlZ2FjeVwiXSA9IFwiMFwiO1xuICByZXR1cm4gVHlwZWREYXRhUmV2aXNpb24yO1xufSkoVHlwZWREYXRhUmV2aXNpb24gfHwge30pO1xuXG4vLyBzcmMvdXRpbHMvYXNzZXJ0LnRzXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJBc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvbnVtLnRzXG52YXIgbnVtX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG51bV9leHBvcnRzLCB7XG4gIGFkZFBlcmNlbnQ6ICgpID0+IGFkZFBlcmNlbnQsXG4gIGFzc2VydEluUmFuZ2U6ICgpID0+IGFzc2VydEluUmFuZ2UsXG4gIGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXk6ICgpID0+IGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXksXG4gIGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5OiAoKSA9PiBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheSxcbiAgY2xlYW5IZXg6ICgpID0+IGNsZWFuSGV4LFxuICBnZXREZWNpbWFsU3RyaW5nOiAoKSA9PiBnZXREZWNpbWFsU3RyaW5nLFxuICBnZXRIZXhTdHJpbmc6ICgpID0+IGdldEhleFN0cmluZyxcbiAgZ2V0SGV4U3RyaW5nQXJyYXk6ICgpID0+IGdldEhleFN0cmluZ0FycmF5LFxuICBoZXhUb0J5dGVzOiAoKSA9PiBoZXhUb0J5dGVzLFxuICBoZXhUb0RlY2ltYWxTdHJpbmc6ICgpID0+IGhleFRvRGVjaW1hbFN0cmluZyxcbiAgaXNCaWdJbnQ6ICgpID0+IGlzQmlnSW50LFxuICBpc0hleDogKCkgPT4gaXNIZXgsXG4gIGlzU3RyaW5nV2hvbGVOdW1iZXI6ICgpID0+IGlzU3RyaW5nV2hvbGVOdW1iZXIsXG4gIHRvQmlnSW50OiAoKSA9PiB0b0JpZ0ludCxcbiAgdG9DYWlyb0Jvb2w6ICgpID0+IHRvQ2Fpcm9Cb29sLFxuICB0b0hleDogKCkgPT4gdG9IZXgsXG4gIHRvSGV4U3RyaW5nOiAoKSA9PiB0b0hleFN0cmluZyxcbiAgdG9TdG9yYWdlS2V5OiAoKSA9PiB0b1N0b3JhZ2VLZXlcbn0pO1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzTm9ibGUgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuZnVuY3Rpb24gaXNIZXgoaGV4KSB7XG4gIHJldHVybiAvXjB4WzAtOWEtZl0qJC9pLnRlc3QoaGV4KTtcbn1cbmZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIjtcbn1cbmZ1bmN0aW9uIHRvSGV4KG51bWJlcjIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCh0b0JpZ0ludChudW1iZXIyKS50b1N0cmluZygxNikpO1xufVxudmFyIHRvSGV4U3RyaW5nID0gdG9IZXg7XG5mdW5jdGlvbiB0b1N0b3JhZ2VLZXkobnVtYmVyMikge1xuICBjb25zdCByZXMgPSBhZGRIZXhQcmVmaXgodG9CaWdJbnQobnVtYmVyMikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCBcIjBcIikpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gaGV4VG9EZWNpbWFsU3RyaW5nKGhleCkge1xuICByZXR1cm4gQmlnSW50KGFkZEhleFByZWZpeChoZXgpKS50b1N0cmluZygxMCk7XG59XG52YXIgY2xlYW5IZXggPSAoaGV4KSA9PiBoZXgudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eKDB4KTArLywgXCIkMVwiKTtcbmZ1bmN0aW9uIGFzc2VydEluUmFuZ2UoaW5wdXQsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIGlucHV0TmFtZSA9IFwiXCIpIHtcbiAgY29uc3QgbWVzc2FnZVN1ZmZpeCA9IGlucHV0TmFtZSA9PT0gXCJcIiA/IFwiaW52YWxpZCBsZW5ndGhcIiA6IGBpbnZhbGlkICR7aW5wdXROYW1lfSBsZW5ndGhgO1xuICBjb25zdCBpbnB1dEJpZ0ludCA9IEJpZ0ludChpbnB1dCk7XG4gIGNvbnN0IGxvd2VyQm91bmRCaWdJbnQgPSBCaWdJbnQobG93ZXJCb3VuZCk7XG4gIGNvbnN0IHVwcGVyQm91bmRCaWdJbnQgPSBCaWdJbnQodXBwZXJCb3VuZCk7XG4gIGFzc2VydChcbiAgICBpbnB1dEJpZ0ludCA+PSBsb3dlckJvdW5kQmlnSW50ICYmIGlucHV0QmlnSW50IDw9IHVwcGVyQm91bmRCaWdJbnQsXG4gICAgYE1lc3NhZ2Ugbm90IHNpZ25hYmxlLCAke21lc3NhZ2VTdWZmaXh9LmBcbiAgKTtcbn1cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXkocmF3Q2FsbGRhdGEpIHtcbiAgcmV0dXJuIHJhd0NhbGxkYXRhLm1hcCgoeCkgPT4gdG9CaWdJbnQoeCkudG9TdHJpbmcoMTApKTtcbn1cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5KHJhd0NhbGxkYXRhKSB7XG4gIHJldHVybiByYXdDYWxsZGF0YS5tYXAoKHgpID0+IHRvSGV4KHgpKTtcbn1cbnZhciBpc1N0cmluZ1dob2xlTnVtYmVyID0gKHZhbHVlKSA9PiAvXlxcZCskLy50ZXN0KHZhbHVlKTtcbmZ1bmN0aW9uIGdldERlY2ltYWxTdHJpbmcodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiBoZXhUb0RlY2ltYWxTdHJpbmcodmFsdWUpO1xuICB9XG4gIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7dmFsdWV9IG5lZWQgdG8gYmUgaGV4LXN0cmluZyBvciB3aG9sZS1udW1iZXItc3RyaW5nYCk7XG59XG5mdW5jdGlvbiBnZXRIZXhTdHJpbmcodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdG9IZXhTdHJpbmcodmFsdWUpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHt2YWx1ZX0gbmVlZCB0byBiZSBoZXgtc3RyaW5nIG9yIHdob2xlLW51bWJlci1zdHJpbmdgKTtcbn1cbmZ1bmN0aW9uIGdldEhleFN0cmluZ0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoKGVsKSA9PiBnZXRIZXhTdHJpbmcoZWwpKTtcbn1cbnZhciB0b0NhaXJvQm9vbCA9ICh2YWx1ZSkgPT4gKCt2YWx1ZSkudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgaWYgKCFpc0hleCh2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3ZhbHVlfSBuZWVkIHRvIGJlIGEgaGV4LXN0cmluZ2ApO1xuICBsZXQgYWRhcHRlZFZhbHVlID0gcmVtb3ZlSGV4UHJlZml4KHZhbHVlKTtcbiAgaWYgKGFkYXB0ZWRWYWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgYWRhcHRlZFZhbHVlID0gYDAke2FkYXB0ZWRWYWx1ZX1gO1xuICB9XG4gIHJldHVybiBoZXhUb0J5dGVzTm9ibGUoYWRhcHRlZFZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFkZFBlcmNlbnQobnVtYmVyMiwgcGVyY2VudCkge1xuICBjb25zdCBiaWdJbnROdW0gPSBCaWdJbnQobnVtYmVyMik7XG4gIHJldHVybiBiaWdJbnROdW0gKyBiaWdJbnROdW0gKiBCaWdJbnQocGVyY2VudCkgLyAxMDBuO1xufVxuXG4vLyBzcmMvdXRpbHMvc2VsZWN0b3IudHNcbnZhciBzZWxlY3Rvcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChzZWxlY3Rvcl9leHBvcnRzLCB7XG4gIGdldFNlbGVjdG9yOiAoKSA9PiBnZXRTZWxlY3RvcixcbiAgZ2V0U2VsZWN0b3JGcm9tTmFtZTogKCkgPT4gZ2V0U2VsZWN0b3JGcm9tTmFtZSxcbiAga2VjY2FrQm46ICgpID0+IGtlY2Nha0JuLFxuICBzdGFya25ldEtlY2NhazogKCkgPT4gc3RhcmtuZXRLZWNjYWtcbn0pO1xuaW1wb3J0IHsga2VjY2FrIH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuZnVuY3Rpb24ga2VjY2FrQm4odmFsdWUpIHtcbiAgY29uc3QgaGV4V2l0aG91dFByZWZpeCA9IHJlbW92ZUhleFByZWZpeCh0b0hleChCaWdJbnQodmFsdWUpKSk7XG4gIGNvbnN0IGV2ZW5IZXggPSBoZXhXaXRob3V0UHJlZml4Lmxlbmd0aCAlIDIgPT09IDAgPyBoZXhXaXRob3V0UHJlZml4IDogYDAke2hleFdpdGhvdXRQcmVmaXh9YDtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChrZWNjYWsoaGV4VG9CeXRlcyhhZGRIZXhQcmVmaXgoZXZlbkhleCkpKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24ga2VjY2FrSGV4KHN0cikge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGtlY2Nhayh1dGY4VG9BcnJheShzdHIpKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gc3RhcmtuZXRLZWNjYWsoc3RyKSB7XG4gIGNvbnN0IGhhc2ggPSBCaWdJbnQoa2VjY2FrSGV4KHN0cikpO1xuICByZXR1cm4gaGFzaCAmIE1BU0tfMjUwO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0b3JGcm9tTmFtZShmdW5jTmFtZSkge1xuICByZXR1cm4gdG9IZXgoc3RhcmtuZXRLZWNjYWsoZnVuY05hbWUpKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKHZhbHVlKSB7XG4gIGlmIChpc0hleCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3RyaW5nV2hvbGVOdW1iZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRvSGV4U3RyaW5nKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZ2V0U2VsZWN0b3JGcm9tTmFtZSh2YWx1ZSk7XG59XG5cbi8vIHNyYy91dGlscy9zaG9ydFN0cmluZy50c1xudmFyIHNob3J0U3RyaW5nX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNob3J0U3RyaW5nX2V4cG9ydHMsIHtcbiAgZGVjb2RlU2hvcnRTdHJpbmc6ICgpID0+IGRlY29kZVNob3J0U3RyaW5nLFxuICBlbmNvZGVTaG9ydFN0cmluZzogKCkgPT4gZW5jb2RlU2hvcnRTdHJpbmcsXG4gIGlzQVNDSUk6ICgpID0+IGlzQVNDSUksXG4gIGlzRGVjaW1hbFN0cmluZzogKCkgPT4gaXNEZWNpbWFsU3RyaW5nLFxuICBpc0xvbmdUZXh0OiAoKSA9PiBpc0xvbmdUZXh0LFxuICBpc1Nob3J0U3RyaW5nOiAoKSA9PiBpc1Nob3J0U3RyaW5nLFxuICBpc1Nob3J0VGV4dDogKCkgPT4gaXNTaG9ydFRleHQsXG4gIGlzVGV4dDogKCkgPT4gaXNUZXh0LFxuICBzcGxpdExvbmdTdHJpbmc6ICgpID0+IHNwbGl0TG9uZ1N0cmluZ1xufSk7XG5mdW5jdGlvbiBpc0FTQ0lJKHN0cikge1xuICByZXR1cm4gL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzU2hvcnRTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIubGVuZ3RoIDw9IFRFWFRfVE9fRkVMVF9NQVhfTEVOO1xufVxuZnVuY3Rpb24gaXNEZWNpbWFsU3RyaW5nKHN0cikge1xuICByZXR1cm4gL15bMC05XSokL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNUZXh0KHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiAmJiAhaXNIZXgodmFsKSAmJiAhaXNTdHJpbmdXaG9sZU51bWJlcih2YWwpO1xufVxudmFyIGlzU2hvcnRUZXh0ID0gKHZhbCkgPT4gaXNUZXh0KHZhbCkgJiYgaXNTaG9ydFN0cmluZyh2YWwpO1xudmFyIGlzTG9uZ1RleHQgPSAodmFsKSA9PiBpc1RleHQodmFsKSAmJiAhaXNTaG9ydFN0cmluZyh2YWwpO1xuZnVuY3Rpb24gc3BsaXRMb25nU3RyaW5nKGxvbmdTdHIpIHtcbiAgY29uc3QgcmVnZXggPSBSZWdFeHAoYFteXXsxLCR7VEVYVF9UT19GRUxUX01BWF9MRU59fWAsIFwiZ1wiKTtcbiAgcmV0dXJuIGxvbmdTdHIubWF0Y2gocmVnZXgpIHx8IFtdO1xufVxuZnVuY3Rpb24gZW5jb2RlU2hvcnRTdHJpbmcoc3RyKSB7XG4gIGlmICghaXNBU0NJSShzdHIpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBhbiBBU0NJSSBzdHJpbmdgKTtcbiAgaWYgKCFpc1Nob3J0U3RyaW5nKHN0cikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgdG9vIGxvbmdgKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChzdHIucmVwbGFjZSgvLi9nLCAoY2hhcikgPT4gY2hhci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkpO1xufVxuZnVuY3Rpb24gZGVjb2RlU2hvcnRTdHJpbmcoc3RyKSB7XG4gIGlmICghaXNBU0NJSShzdHIpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBhbiBBU0NJSSBzdHJpbmdgKTtcbiAgaWYgKGlzSGV4KHN0cikpIHtcbiAgICByZXR1cm4gcmVtb3ZlSGV4UHJlZml4KHN0cikucmVwbGFjZSgvLnsyfS9nLCAoaGV4KSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKSk7XG4gIH1cbiAgaWYgKGlzRGVjaW1hbFN0cmluZyhzdHIpKSB7XG4gICAgcmV0dXJuIGRlY29kZVNob3J0U3RyaW5nKFwiMFhcIi5jb25jYXQoQmlnSW50KHN0cikudG9TdHJpbmcoMTYpKSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IEhleCBvciBkZWNpbWFsYCk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9ieXRlQXJyYXkudHNcbnZhciBieXRlQXJyYXlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoYnl0ZUFycmF5X2V4cG9ydHMsIHtcbiAgYnl0ZUFycmF5RnJvbVN0cmluZzogKCkgPT4gYnl0ZUFycmF5RnJvbVN0cmluZyxcbiAgc3RyaW5nRnJvbUJ5dGVBcnJheTogKCkgPT4gc3RyaW5nRnJvbUJ5dGVBcnJheVxufSk7XG5mdW5jdGlvbiBzdHJpbmdGcm9tQnl0ZUFycmF5KG15Qnl0ZUFycmF5KSB7XG4gIGNvbnN0IHBlbmRpbmdfd29yZCA9IEJpZ0ludChteUJ5dGVBcnJheS5wZW5kaW5nX3dvcmQpID09PSAwbiA/IFwiXCIgOiBkZWNvZGVTaG9ydFN0cmluZyh0b0hleChteUJ5dGVBcnJheS5wZW5kaW5nX3dvcmQpKTtcbiAgcmV0dXJuIG15Qnl0ZUFycmF5LmRhdGEucmVkdWNlKChjdW11bGVkU3RyaW5nLCBlbmNvZGVkU3RyaW5nKSA9PiB7XG4gICAgY29uc3QgYWRkID0gQmlnSW50KGVuY29kZWRTdHJpbmcpID09PSAwbiA/IFwiXCIgOiBkZWNvZGVTaG9ydFN0cmluZyh0b0hleChlbmNvZGVkU3RyaW5nKSk7XG4gICAgcmV0dXJuIGN1bXVsZWRTdHJpbmcgKyBhZGQ7XG4gIH0sIFwiXCIpICsgcGVuZGluZ193b3JkO1xufVxuZnVuY3Rpb24gYnl0ZUFycmF5RnJvbVN0cmluZyhteVN0cmluZykge1xuICBpZiAobXlTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IFtcIjB4MDBcIl0sXG4gICAgICBwZW5kaW5nX3dvcmQ6IFwiMHgwMFwiLFxuICAgICAgcGVuZGluZ193b3JkX2xlbjogMFxuICAgIH07XG4gIH1cbiAgY29uc3QgbXlTaG9ydFN0cmluZ3MgPSBzcGxpdExvbmdTdHJpbmcobXlTdHJpbmcpO1xuICBjb25zdCByZW1haW5zID0gbXlTaG9ydFN0cmluZ3NbbXlTaG9ydFN0cmluZ3MubGVuZ3RoIC0gMV07XG4gIGNvbnN0IG15U2hvcnRTdHJpbmdzRW5jb2RlZCA9IG15U2hvcnRTdHJpbmdzLm1hcChcbiAgICAoc2hvcnRTdHIpID0+IGVuY29kZVNob3J0U3RyaW5nKHNob3J0U3RyKVxuICApO1xuICBpZiAocmVtYWlucy5sZW5ndGggPT09IDMxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG15U2hvcnRTdHJpbmdzRW5jb2RlZCxcbiAgICAgIHBlbmRpbmdfd29yZDogXCIweDAwXCIsXG4gICAgICBwZW5kaW5nX3dvcmRfbGVuOiAwXG4gICAgfTtcbiAgfVxuICBjb25zdCBwZW5kaW5nRW5jb2RlZFdvcmQgPSBteVNob3J0U3RyaW5nc0VuY29kZWQucG9wKCk7XG4gIHJldHVybiB7XG4gICAgZGF0YTogbXlTaG9ydFN0cmluZ3NFbmNvZGVkLmxlbmd0aCA9PT0gMCA/IFtcIjB4MDBcIl0gOiBteVNob3J0U3RyaW5nc0VuY29kZWQsXG4gICAgcGVuZGluZ193b3JkOiBwZW5kaW5nRW5jb2RlZFdvcmQsXG4gICAgcGVuZGluZ193b3JkX2xlbjogcmVtYWlucy5sZW5ndGhcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgY2Fpcm9fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY2Fpcm9fZXhwb3J0cywge1xuICBmZWx0OiAoKSA9PiBmZWx0LFxuICBnZXRBYmlDb250cmFjdFZlcnNpb246ICgpID0+IGdldEFiaUNvbnRyYWN0VmVyc2lvbixcbiAgZ2V0QXJyYXlUeXBlOiAoKSA9PiBnZXRBcnJheVR5cGUsXG4gIGlzQ2Fpcm8xQWJpOiAoKSA9PiBpc0NhaXJvMUFiaSxcbiAgaXNDYWlybzFUeXBlOiAoKSA9PiBpc0NhaXJvMVR5cGUsXG4gIGlzTGVuOiAoKSA9PiBpc0xlbixcbiAgaXNUeXBlQXJyYXk6ICgpID0+IGlzVHlwZUFycmF5LFxuICBpc1R5cGVCb29sOiAoKSA9PiBpc1R5cGVCb29sLFxuICBpc1R5cGVCeXRlQXJyYXk6ICgpID0+IGlzVHlwZUJ5dGVBcnJheSxcbiAgaXNUeXBlQnl0ZXMzMTogKCkgPT4gaXNUeXBlQnl0ZXMzMSxcbiAgaXNUeXBlQ29udHJhY3RBZGRyZXNzOiAoKSA9PiBpc1R5cGVDb250cmFjdEFkZHJlc3MsXG4gIGlzVHlwZUVudW06ICgpID0+IGlzVHlwZUVudW0sXG4gIGlzVHlwZUV0aEFkZHJlc3M6ICgpID0+IGlzVHlwZUV0aEFkZHJlc3MsXG4gIGlzVHlwZUZlbHQ6ICgpID0+IGlzVHlwZUZlbHQsXG4gIGlzVHlwZUxpdGVyYWw6ICgpID0+IGlzVHlwZUxpdGVyYWwsXG4gIGlzVHlwZU5hbWVkVHVwbGU6ICgpID0+IGlzVHlwZU5hbWVkVHVwbGUsXG4gIGlzVHlwZU9wdGlvbjogKCkgPT4gaXNUeXBlT3B0aW9uLFxuICBpc1R5cGVSZXN1bHQ6ICgpID0+IGlzVHlwZVJlc3VsdCxcbiAgaXNUeXBlU3RydWN0OiAoKSA9PiBpc1R5cGVTdHJ1Y3QsXG4gIGlzVHlwZVR1cGxlOiAoKSA9PiBpc1R5cGVUdXBsZSxcbiAgaXNUeXBlVWludDogKCkgPT4gaXNUeXBlVWludCxcbiAgaXNUeXBlVWludDI1NjogKCkgPT4gaXNUeXBlVWludDI1NixcbiAgdHVwbGU6ICgpID0+IHR1cGxlLFxuICB1aW50MjU2OiAoKSA9PiB1aW50MjU2XG59KTtcblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL2ZlbHQudHNcbmZ1bmN0aW9uIENhaXJvRmVsdChpdCkge1xuICBpZiAoaXNCaWdJbnQoaXQpIHx8IHR5cGVvZiBpdCA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKGl0KSkge1xuICAgIHJldHVybiBpdC50b1N0cmluZygpO1xuICB9XG4gIGlmIChpc1RleHQoaXQpKSB7XG4gICAgaWYgKCFpc1Nob3J0U3RyaW5nKGl0KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7aXR9IGlzIGEgbG9uZyBzdHJpbmcgPiAzMSBjaGFycywgZmVsdCBjYW4gc3RvcmUgc2hvcnQgc3RyaW5ncywgc3BsaXQgaXQgdG8gYXJyYXkgb2Ygc2hvcnQgc3RyaW5nc2BcbiAgICAgICk7XG4gICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZVNob3J0U3RyaW5nKGl0KTtcbiAgICByZXR1cm4gQmlnSW50KGVuY29kZWQpLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpdCA9PT0gXCJzdHJpbmdcIiAmJiBpc0hleChpdCkpIHtcbiAgICByZXR1cm4gQmlnSW50KGl0KS50b1N0cmluZygpO1xuICB9XG4gIGlmICh0eXBlb2YgaXQgPT09IFwic3RyaW5nXCIgJiYgaXNTdHJpbmdXaG9sZU51bWJlcihpdCkpIHtcbiAgICByZXR1cm4gaXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBpdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gYCR7K2l0fWA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke2l0fSBjYW4ndCBiZSBjb21wdXRlZCBieSBmZWx0KClgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL3VpbnQyNTYudHNcbnZhciBVSU5UXzEyOF9NQVggPSAoMW4gPDwgMTI4bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NQVggPSAoMW4gPDwgMjU2bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NSU4gPSAwbjtcbnZhciBVSU5UXzI1Nl9MT1dfTUFYID0gMzQwMjgyMzY2OTIwOTM4NDYzNDYzMzc0NjA3NDMxNzY4MjExNDU1bjtcbnZhciBVSU5UXzI1Nl9ISUdIX01BWCA9IDM0MDI4MjM2NjkyMDkzODQ2MzQ2MzM3NDYwNzQzMTc2ODIxMTQ1NW47XG52YXIgVUlOVF8yNTZfTE9XX01JTiA9IDBuO1xudmFyIFVJTlRfMjU2X0hJR0hfTUlOID0gMG47XG52YXIgX0NhaXJvVWludDI1NiA9IGNsYXNzIHtcbiAgbG93O1xuICBoaWdoO1xuICBjb25zdHJ1Y3RvciguLi5hcnIpIHtcbiAgICBpZiAodHlwZW9mIGFyclswXSA9PT0gXCJvYmplY3RcIiAmJiBhcnIubGVuZ3RoID09PSAxICYmIFwibG93XCIgaW4gYXJyWzBdICYmIFwiaGlnaFwiIGluIGFyclswXSkge1xuICAgICAgY29uc3QgcHJvcHMgPSBfQ2Fpcm9VaW50MjU2LnZhbGlkYXRlUHJvcHMoYXJyWzBdLmxvdywgYXJyWzBdLmhpZ2gpO1xuICAgICAgdGhpcy5sb3cgPSBwcm9wcy5sb3c7XG4gICAgICB0aGlzLmhpZ2ggPSBwcm9wcy5oaWdoO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgYmlnSW50ID0gX0NhaXJvVWludDI1Ni52YWxpZGF0ZShhcnJbMF0pO1xuICAgICAgdGhpcy5sb3cgPSBiaWdJbnQgJiBVSU5UXzEyOF9NQVg7XG4gICAgICB0aGlzLmhpZ2ggPSBiaWdJbnQgPj4gMTI4bjtcbiAgICB9IGVsc2UgaWYgKGFyci5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHByb3BzID0gX0NhaXJvVWludDI1Ni52YWxpZGF0ZVByb3BzKGFyclswXSwgYXJyWzFdKTtcbiAgICAgIHRoaXMubG93ID0gcHJvcHMubG93O1xuICAgICAgdGhpcy5oaWdoID0gcHJvcHMuaGlnaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbmNvcnJlY3QgY29uc3RydWN0b3IgcGFyYW1ldGVyc1wiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGlmIEJpZ051bWJlcmlzaCBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgVW5pdDI1NlxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlKGJpZ051bWJlcmlzaCkge1xuICAgIGNvbnN0IGJpZ0ludCA9IEJpZ0ludChiaWdOdW1iZXJpc2gpO1xuICAgIGlmIChiaWdJbnQgPCBVSU5UXzI1Nl9NSU4pXG4gICAgICB0aHJvdyBFcnJvcihcImJpZ051bWJlcmlzaCBpcyBzbWFsbGVyIHRoYW4gVUlOVF8yNTZfTUlOXCIpO1xuICAgIGlmIChiaWdJbnQgPiBVSU5UXzI1Nl9NQVgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgYmlnZ2VyIHRoYW4gVUlOVF8yNTZfTUFYXCIpO1xuICAgIHJldHVybiBiaWdJbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGlmIGxvdyBhbmQgaGlnaCBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgVW5pdDI1NlxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlUHJvcHMobG93LCBoaWdoKSB7XG4gICAgY29uc3QgYmlnSW50TG93ID0gQmlnSW50KGxvdyk7XG4gICAgY29uc3QgYmlnSW50SGlnaCA9IEJpZ0ludChoaWdoKTtcbiAgICBpZiAoYmlnSW50TG93IDwgVUlOVF8yNTZfTE9XX01JTiB8fCBiaWdJbnRMb3cgPiBVSU5UXzI1Nl9MT1dfTUFYKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb3cgaXMgb3V0IG9mIHJhbmdlIFVJTlRfMjU2X0xPV19NSU4gLSBVSU5UXzI1Nl9MT1dfTUFYXCIpO1xuICAgIH1cbiAgICBpZiAoYmlnSW50SGlnaCA8IFVJTlRfMjU2X0hJR0hfTUlOIHx8IGJpZ0ludEhpZ2ggPiBVSU5UXzI1Nl9ISUdIX01BWCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGlnaCBpcyBvdXQgb2YgcmFuZ2UgVUlOVF8yNTZfSElHSF9NSU4gLSBVSU5UXzI1Nl9ISUdIX01BWFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbG93OiBiaWdJbnRMb3csIGhpZ2g6IGJpZ0ludEhpZ2ggfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVbml0MjU2XG4gICAqL1xuICBzdGF0aWMgaXMoYmlnTnVtYmVyaXNoKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9DYWlyb1VpbnQyNTYudmFsaWRhdGUoYmlnTnVtYmVyaXNoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcHJvdmlkZWQgYWJpIHR5cGUgaXMgdGhpcyBkYXRhIHR5cGVcbiAgICovXG4gIHN0YXRpYyBpc0FiaVR5cGUoYWJpVHlwZSkge1xuICAgIHJldHVybiBhYmlUeXBlID09PSBfQ2Fpcm9VaW50MjU2LmFiaVNlbGVjdG9yO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYmlnaW50IHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICB0b0JpZ0ludCgpIHtcbiAgICByZXR1cm4gKHRoaXMuaGlnaCA8PCAxMjhuKSArIHRoaXMubG93O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDI1NiBzdHJ1Y3R1cmUgd2l0aCBIZXhTdHJpbmcgcHJvcHNcbiAgICoge2xvdzogSGV4U3RyaW5nLCBoaWdoOiBIZXhTdHJpbmd9XG4gICAqL1xuICB0b1VpbnQyNTZIZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvdzogYWRkSGV4UHJlZml4KHRoaXMubG93LnRvU3RyaW5nKDE2KSksXG4gICAgICBoaWdoOiBhZGRIZXhQcmVmaXgodGhpcy5oaWdoLnRvU3RyaW5nKDE2KSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDI1NiBzdHJ1Y3R1cmUgd2l0aCBEZWNpbWFsU3RyaW5nIHByb3BzXG4gICAqIHtsb3c6IERlY1N0cmluZywgaGlnaDogRGVjU3RyaW5nfVxuICAgKi9cbiAgdG9VaW50MjU2RGVjaW1hbFN0cmluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG93OiB0aGlzLmxvdy50b1N0cmluZygxMCksXG4gICAgICBoaWdoOiB0aGlzLmhpZ2gudG9TdHJpbmcoMTApXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFwaSByZXF1ZXN0cyByZXByZXNlbnRhdGlvbiB3aXRjaCBpcyBmZWx0IGFycmF5XG4gICAqL1xuICB0b0FwaVJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIFtDYWlyb0ZlbHQodGhpcy5sb3cpLCBDYWlyb0ZlbHQodGhpcy5oaWdoKV07XG4gIH1cbn07XG52YXIgQ2Fpcm9VaW50MjU2ID0gX0NhaXJvVWludDI1Njtcbl9fcHVibGljRmllbGQoQ2Fpcm9VaW50MjU2LCBcImFiaVNlbGVjdG9yXCIsIFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiKTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgaXNMZW4gPSAobmFtZSkgPT4gL19sZW4kLy50ZXN0KG5hbWUpO1xudmFyIGlzVHlwZUZlbHQgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJmZWx0XCIgfHwgdHlwZSA9PT0gXCJjb3JlOjpmZWx0MjUyXCI7XG52YXIgaXNUeXBlQXJyYXkgPSAodHlwZSkgPT4gL1xcKi8udGVzdCh0eXBlKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OlwiKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6U3Bhbjo6XCIpO1xudmFyIGlzVHlwZVR1cGxlID0gKHR5cGUpID0+IC9eXFwoLipcXCkkL2kudGVzdCh0eXBlKTtcbnZhciBpc1R5cGVOYW1lZFR1cGxlID0gKHR5cGUpID0+IC9cXCguKlxcKS9pLnRlc3QodHlwZSkgJiYgdHlwZS5pbmNsdWRlcyhcIjpcIik7XG52YXIgaXNUeXBlU3RydWN0ID0gKHR5cGUsIHN0cnVjdHMpID0+IHR5cGUgaW4gc3RydWN0cztcbnZhciBpc1R5cGVFbnVtID0gKHR5cGUsIGVudW1zKSA9PiB0eXBlIGluIGVudW1zO1xudmFyIGlzVHlwZU9wdGlvbiA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpvcHRpb246Ok9wdGlvbjo6XCIpO1xudmFyIGlzVHlwZVJlc3VsdCA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6XCIpO1xudmFyIGlzVHlwZVVpbnQgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhVaW50KS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVVaW50MjU2ID0gKHR5cGUpID0+IENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSk7XG52YXIgaXNUeXBlTGl0ZXJhbCA9ICh0eXBlKSA9PiBPYmplY3QudmFsdWVzKExpdGVyYWwpLmluY2x1ZGVzKHR5cGUpO1xudmFyIGlzVHlwZUJvb2wgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpib29sXCI7XG52YXIgaXNUeXBlQ29udHJhY3RBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xudmFyIGlzVHlwZUV0aEFkZHJlc3MgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjtcbnZhciBpc1R5cGVCeXRlczMxID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6Ynl0ZXNfMzE6OmJ5dGVzMzFcIjtcbnZhciBpc1R5cGVCeXRlQXJyYXkgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpieXRlX2FycmF5OjpCeXRlQXJyYXlcIjtcbnZhciBpc0NhaXJvMVR5cGUgPSAodHlwZSkgPT4gdHlwZS5pbmNsdWRlcyhcIjo6XCIpO1xudmFyIGdldEFycmF5VHlwZSA9ICh0eXBlKSA9PiB7XG4gIGlmIChpc0NhaXJvMVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gdHlwZS5zdWJzdHJpbmcodHlwZS5pbmRleE9mKFwiPFwiKSArIDEsIHR5cGUubGFzdEluZGV4T2YoXCI+XCIpKTtcbiAgfVxuICByZXR1cm4gdHlwZS5yZXBsYWNlKFwiKlwiLCBcIlwiKTtcbn07XG5mdW5jdGlvbiBpc0NhaXJvMUFiaShhYmkpIHtcbiAgY29uc3QgeyBjYWlybyB9ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGFiaSk7XG4gIGlmIChjYWlybyA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZGV0ZXJtaW5lIENhaXJvIHZlcnNpb25cIik7XG4gIH1cbiAgcmV0dXJuIGNhaXJvID09PSBcIjFcIjtcbn1cbmZ1bmN0aW9uIGdldEFiaUNvbnRyYWN0VmVyc2lvbihhYmkpIHtcbiAgaWYgKGFiaS5maW5kKChpdCkgPT4gaXQudHlwZSA9PT0gXCJpbnRlcmZhY2VcIikpIHtcbiAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBcIjJcIiB9O1xuICB9XG4gIGNvbnN0IHRlc3RGdW5jdGlvbiA9IGFiaS5maW5kKFxuICAgIChpdCkgPT4gaXQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIChpdC5pbnB1dHMubGVuZ3RoIHx8IGl0Lm91dHB1dHMubGVuZ3RoKVxuICApO1xuICBpZiAoIXRlc3RGdW5jdGlvbikge1xuICAgIHJldHVybiB7IGNhaXJvOiB2b2lkIDAsIGNvbXBpbGVyOiB2b2lkIDAgfTtcbiAgfVxuICBjb25zdCBpbyA9IHRlc3RGdW5jdGlvbi5pbnB1dHMubGVuZ3RoID8gdGVzdEZ1bmN0aW9uLmlucHV0cyA6IHRlc3RGdW5jdGlvbi5vdXRwdXRzO1xuICBpZiAoaXNDYWlybzFUeXBlKGlvWzBdLnR5cGUpKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogXCIxXCIgfTtcbiAgfVxuICByZXR1cm4geyBjYWlybzogXCIwXCIsIGNvbXBpbGVyOiBcIjBcIiB9O1xufVxudmFyIHVpbnQyNTYgPSAoaXQpID0+IHtcbiAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYoaXQpLnRvVWludDI1NkRlY2ltYWxTdHJpbmcoKTtcbn07XG52YXIgdHVwbGUgPSAoLi4uYXJncykgPT4gKHsgLi4uYXJncyB9KTtcbmZ1bmN0aW9uIGZlbHQoaXQpIHtcbiAgcmV0dXJuIENhaXJvRmVsdChpdCk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvQ3VzdG9tRW51bS50c1xudmFyIENhaXJvQ3VzdG9tRW51bSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIGRpcmVjdCByZWFkb25seSBhY2Nlc3MgdG8gdmFyaWFudHMgb2YgdGhlIENhaXJvIEN1c3RvbSBFbnVtLlxuICAgKiBAcmV0dXJucyBhIHZhbHVlIG9mIHR5cGUgYW55XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3Qgc3VjY2Vzc1ZhbHVlID0gbXlDYWlyb0VudW0udmFyaWFudC5TdWNjZXNzO1xuICAgKi9cbiAgdmFyaWFudDtcbiAgLyoqXG4gICAqIEBwYXJhbSBlbnVtQ29udGVudCBhbiBvYmplY3Qgd2l0aCB0aGUgdmFyaWFudHMgYXMga2V5cyBhbmQgdGhlIGNvbnRlbnQgYXMgdmFsdWUuIE9ubHkgb25lIGNvbnRlbnQgc2hhbGwgYmUgZGVmaW5lZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVudW1Db250ZW50KSB7XG4gICAgY29uc3QgdmFyaWFudHNMaXN0ID0gT2JqZWN0LnZhbHVlcyhlbnVtQ29udGVudCk7XG4gICAgaWYgKHZhcmlhbnRzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRW51bSBtdXN0IGhhdmUgYXQgbGVhc3QgMSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBuYkFjdGl2ZVZhcmlhbnRzID0gdmFyaWFudHNMaXN0LmZpbHRlcihcbiAgICAgIChjb250ZW50KSA9PiB0eXBlb2YgY29udGVudCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICkubGVuZ3RoO1xuICAgIGlmIChuYkFjdGl2ZVZhcmlhbnRzICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGV4YWN0bHkgb25lIGFjdGl2ZSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICB0aGlzLnZhcmlhbnQgPSBlbnVtQ29udGVudDtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFudCk7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IHR5cGVvZiBpdGVtWzFdICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVWYXJpYW50WzFdO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIGN1c3RvbSBFbnVtLlxuICAgKi9cbiAgYWN0aXZlVmFyaWFudCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFudCk7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IHR5cGVvZiBpdGVtWzFdICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlVmFyaWFudFswXTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9PcHRpb24udHNcbnZhciBDYWlyb09wdGlvblZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gKChDYWlyb09wdGlvblZhcmlhbnQyKSA9PiB7XG4gIENhaXJvT3B0aW9uVmFyaWFudDJbQ2Fpcm9PcHRpb25WYXJpYW50MltcIlNvbWVcIl0gPSAwXSA9IFwiU29tZVwiO1xuICBDYWlyb09wdGlvblZhcmlhbnQyW0NhaXJvT3B0aW9uVmFyaWFudDJbXCJOb25lXCJdID0gMV0gPSBcIk5vbmVcIjtcbiAgcmV0dXJuIENhaXJvT3B0aW9uVmFyaWFudDI7XG59KShDYWlyb09wdGlvblZhcmlhbnQgfHwge30pO1xudmFyIENhaXJvT3B0aW9uID0gY2xhc3Mge1xuICBTb21lO1xuICBOb25lO1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50LCBzb21lQ29udGVudCkge1xuICAgIGlmICghKHZhcmlhbnQgaW4gQ2Fpcm9PcHRpb25WYXJpYW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdmFyaWFudCA6IHNob3VsZCBiZSBDYWlyb09wdGlvblZhcmlhbnQuU29tZSBvciAuTm9uZS5cIik7XG4gICAgfVxuICAgIGlmICh2YXJpYW50ID09PSAwIC8qIFNvbWUgKi8pIHtcbiAgICAgIGlmICh0eXBlb2Ygc29tZUNvbnRlbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgY3JlYXRpb24gb2YgYSBDYWlybyBPcHRpb24gd2l0aCBcIlNvbWVcIiB2YXJpYW50IG5lZWRzIGEgY29udGVudCBhcyBpbnB1dC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLlNvbWUgPSBzb21lQ29udGVudDtcbiAgICAgIHRoaXMuTm9uZSA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5Tb21lID0gdm9pZCAwO1xuICAgICAgdGhpcy5Ob25lID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gY3VzdG9tIEVudW0uXG4gICAqICBJZiBOb25lLCByZXR1cm5zICd1bmRlZmluZWQnLlxuICAgKi9cbiAgdW53cmFwKCkge1xuICAgIGlmICh0aGlzLk5vbmUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLlNvbWU7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzU29tZScuXG4gICAqL1xuICBpc1NvbWUoKSB7XG4gICAgcmV0dXJuICEodHlwZW9mIHRoaXMuU29tZSA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzTm9uZScuXG4gICAqL1xuICBpc05vbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuTm9uZSA9PT0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9SZXN1bHQudHNcbnZhciBDYWlyb1Jlc3VsdFZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gKChDYWlyb1Jlc3VsdFZhcmlhbnQyKSA9PiB7XG4gIENhaXJvUmVzdWx0VmFyaWFudDJbQ2Fpcm9SZXN1bHRWYXJpYW50MltcIk9rXCJdID0gMF0gPSBcIk9rXCI7XG4gIENhaXJvUmVzdWx0VmFyaWFudDJbQ2Fpcm9SZXN1bHRWYXJpYW50MltcIkVyclwiXSA9IDFdID0gXCJFcnJcIjtcbiAgcmV0dXJuIENhaXJvUmVzdWx0VmFyaWFudDI7XG59KShDYWlyb1Jlc3VsdFZhcmlhbnQgfHwge30pO1xudmFyIENhaXJvUmVzdWx0ID0gY2xhc3Mge1xuICBPaztcbiAgRXJyO1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50LCByZXN1bHRDb250ZW50KSB7XG4gICAgaWYgKCEodmFyaWFudCBpbiBDYWlyb1Jlc3VsdFZhcmlhbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyB2YXJpYW50IDogc2hvdWxkIGJlIENhaXJvUmVzdWx0VmFyaWFudC5PayBvciAuRXJyLlwiKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09IDAgLyogT2sgKi8pIHtcbiAgICAgIHRoaXMuT2sgPSByZXN1bHRDb250ZW50O1xuICAgICAgdGhpcy5FcnIgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuT2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLkVyciA9IHJlc3VsdENvbnRlbnQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIFJlc3VsdC5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuT2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLk9rO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuRXJyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5FcnI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJvdGggUmVzdWx0Lk9rIGFuZCAuRXJyIGFyZSB1bmRlZmluZWQuIE5vdCBhdXRob3JpemVkLlwiKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsaWQgdmFyaWFudCBpcyAnT2snLlxuICAgKi9cbiAgaXNPaygpIHtcbiAgICByZXR1cm4gISh0eXBlb2YgdGhpcy5PayA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzRXJyJy5cbiAgICovXG4gIGlzRXJyKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLkVyciA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9mb3JtYXR0ZXIudHNcbnZhciBndWFyZCA9IHtcbiAgaXNCTjogKGRhdGEsIHR5cGUsIGtleSkgPT4ge1xuICAgIGlmICghaXNCaWdJbnQoZGF0YVtrZXldKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYERhdGEgYW5kIGZvcm1hdHRlciBtaXNtYXRjaCBvbiAke2tleX06JHt0eXBlW2tleV19LCBleHBlY3RlZCByZXNwb25zZSBkYXRhICR7a2V5fToke2RhdGFba2V5XX0gdG8gYmUgQk4gaW5zdGVhZCBpdCBpcyAke3R5cGVvZiBkYXRhW2tleV19YFxuICAgICAgKTtcbiAgfSxcbiAgdW5rbm93bjogKGRhdGEsIHR5cGUsIGtleSkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGZvcm1hdHRlciB0eXBlIG9uICR7a2V5fToke3R5cGVba2V5XX0gZm9yIGRhdGEgJHtrZXl9OiR7ZGF0YVtrZXldfWApO1xuICB9XG59O1xuZnVuY3Rpb24gZm9ybWF0dGVyKGRhdGEsIHR5cGUsIHNhbWVUeXBlKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgZWxUeXBlID0gc2FtZVR5cGUgPz8gdHlwZVtrZXldO1xuICAgIGlmICghKGtleSBpbiB0eXBlKSAmJiAhc2FtZVR5cGUpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBpZiAoZWxUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pKSB7XG4gICAgICAgIGNvbnN0IGFycmF5U3RyID0gZm9ybWF0dGVyKFxuICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICBkYXRhW2tleV0ubWFwKChfKSA9PiBlbFR5cGUpXG4gICAgICAgICk7XG4gICAgICAgIGFjY1trZXldID0gT2JqZWN0LnZhbHVlcyhhcnJheVN0cikuam9pbihcIlwiKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGd1YXJkLmlzQk4oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgIGFjY1trZXldID0gZGVjb2RlU2hvcnRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKGVsVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZ3VhcmQuaXNCTihkYXRhLCB0eXBlLCBrZXkpO1xuICAgICAgYWNjW2tleV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbFR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYWNjW2tleV0gPSBlbFR5cGUodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxUeXBlKSkge1xuICAgICAgY29uc3QgYXJyYXlPYmogPSBmb3JtYXR0ZXIoZGF0YVtrZXldLCBlbFR5cGUsIGVsVHlwZVswXSk7XG4gICAgICBhY2Nba2V5XSA9IE9iamVjdC52YWx1ZXMoYXJyYXlPYmopO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGFjY1trZXldID0gZm9ybWF0dGVyKGRhdGFba2V5XSwgZWxUeXBlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGd1YXJkLnVua25vd24oZGF0YSwgdHlwZSwga2V5KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTAtMS4xLjAudHNcbnZhciBBYmlQYXJzZXIxID0gY2xhc3Mge1xuICBhYmk7XG4gIGNvbnN0cnVjdG9yKGFiaSkge1xuICAgIHRoaXMuYWJpID0gYWJpO1xuICB9XG4gIC8qKlxuICAgKiBhYmkgbWV0aG9kIGlucHV0cyBsZW5ndGggd2l0aG91dCAnX2xlbicgaW5wdXRzXG4gICAqIGNhaXJvIDAgcmVkdWNlclxuICAgKiBAcGFyYW0gYWJpTWV0aG9kIEZ1bmN0aW9uQWJpXG4gICAqIEByZXR1cm5zIG51bWJlclxuICAgKi9cbiAgbWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCkge1xuICAgIHJldHVybiBhYmlNZXRob2QuaW5wdXRzLnJlZHVjZSgoYWNjLCBpbnB1dCkgPT4gIWlzTGVuKGlucHV0Lm5hbWUpID8gYWNjICsgMSA6IGFjYywgMCk7XG4gIH1cbiAgLyoqXG4gICAqIGdldCBtZXRob2QgZGVmaW5pdGlvbiBmcm9tIGFiaVxuICAgKiBAcGFyYW0gbmFtZSBzdHJpbmdcbiAgICogQHJldHVybnMgRnVuY3Rpb25BYmkgfCB1bmRlZmluZWRcbiAgICovXG4gIGdldE1ldGhvZChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJpLmZpbmQoKGl0KSA9PiBpdC5uYW1lID09PSBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IEFiaSBpbiBsZWdhY3kgZm9ybWF0XG4gICAqIEByZXR1cm5zIEFiaVxuICAgKi9cbiAgZ2V0TGVnYWN5Rm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmFiaTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3BhcnNlci9wYXJzZXItMi4wLjAudHNcbnZhciBBYmlQYXJzZXIyID0gY2xhc3Mge1xuICBhYmk7XG4gIGNvbnN0cnVjdG9yKGFiaSkge1xuICAgIHRoaXMuYWJpID0gYWJpO1xuICB9XG4gIC8qKlxuICAgKiBhYmkgbWV0aG9kIGlucHV0cyBsZW5ndGhcbiAgICogQHBhcmFtIGFiaU1ldGhvZCBGdW5jdGlvbkFiaVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIG1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpIHtcbiAgICByZXR1cm4gYWJpTWV0aG9kLmlucHV0cy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIGdldCBtZXRob2QgZGVmaW5pdGlvbiBmcm9tIGFiaVxuICAgKiBAcGFyYW0gbmFtZSBzdHJpbmdcbiAgICogQHJldHVybnMgRnVuY3Rpb25BYmkgfCB1bmRlZmluZWRcbiAgICovXG4gIGdldE1ldGhvZChuYW1lKSB7XG4gICAgY29uc3QgaW50ZiA9IHRoaXMuYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKTtcbiAgICByZXR1cm4gaW50Zi5pdGVtcy5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmkuZmxhdE1hcCgoZSkgPT4ge1xuICAgICAgaWYgKGUudHlwZSA9PT0gXCJpbnRlcmZhY2VcIikge1xuICAgICAgICByZXR1cm4gZS5pdGVtcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL2luZGV4LnRzXG5mdW5jdGlvbiBjcmVhdGVBYmlQYXJzZXIoYWJpKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBnZXRBYmlWZXJzaW9uKGFiaSk7XG4gIGlmICh2ZXJzaW9uID09PSAwIHx8IHZlcnNpb24gPT09IDEpIHtcbiAgICByZXR1cm4gbmV3IEFiaVBhcnNlcjEoYWJpKTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMikge1xuICAgIHJldHVybiBuZXcgQWJpUGFyc2VyMihhYmkpO1xuICB9XG4gIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBBQkkgdmVyc2lvbiAke3ZlcnNpb259YCk7XG59XG5mdW5jdGlvbiBnZXRBYmlWZXJzaW9uKGFiaSkge1xuICBpZiAoYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKSlcbiAgICByZXR1cm4gMjtcbiAgaWYgKGlzQ2Fpcm8xQWJpKGFiaSkpXG4gICAgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzQ2FsbGRhdGEsIGFiaU1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kID09PSBcImNvbnN0cnVjdG9yXCIgJiYgIWFiaU1ldGhvZCAmJiAhYXJnc0NhbGxkYXRhLmxlbmd0aDtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3R1cGxlLnRzXG5mdW5jdGlvbiBwYXJzZU5hbWVkVHVwbGUobmFtZWRUdXBsZSkge1xuICBjb25zdCBuYW1lID0gbmFtZWRUdXBsZS5zdWJzdHJpbmcoMCwgbmFtZWRUdXBsZS5pbmRleE9mKFwiOlwiKSk7XG4gIGNvbnN0IHR5cGUgPSBuYW1lZFR1cGxlLnN1YnN0cmluZyhuYW1lLmxlbmd0aCArIFwiOlwiLmxlbmd0aCk7XG4gIHJldHVybiB7IG5hbWUsIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3ViVHVwbGUocykge1xuICBpZiAoIXMuaW5jbHVkZXMoXCIoXCIpKVxuICAgIHJldHVybiB7IHN1YlR1cGxlOiBbXSwgcmVzdWx0OiBzIH07XG4gIGNvbnN0IHN1YlR1cGxlID0gW107XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICBpZiAoc1tpXSA9PT0gXCIoXCIpIHtcbiAgICAgIGxldCBjb3VudGVyID0gMTtcbiAgICAgIGNvbnN0IGxCcmFja2V0ID0gaTtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjb3VudGVyKSB7XG4gICAgICAgIGlmIChzW2ldID09PSBcIilcIilcbiAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIGlmIChzW2ldID09PSBcIihcIilcbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHN1YlR1cGxlLnB1c2gocy5zdWJzdHJpbmcobEJyYWNrZXQsIGkpKTtcbiAgICAgIHJlc3VsdCArPSBcIiBcIjtcbiAgICAgIGktLTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHNbaV07XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4ge1xuICAgIHN1YlR1cGxlLFxuICAgIHJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdENhaXJvMFR1cGxlKHR5cGUpIHtcbiAgY29uc3QgY2xlYW5UeXBlID0gdHlwZS5yZXBsYWNlKC9cXHMvZywgXCJcIikuc2xpY2UoMSwgLTEpO1xuICBjb25zdCB7IHN1YlR1cGxlLCByZXN1bHQgfSA9IHBhcnNlU3ViVHVwbGUoY2xlYW5UeXBlKTtcbiAgbGV0IHJlY29tcG9zZWQgPSByZXN1bHQuc3BsaXQoXCIsXCIpLm1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gc3ViVHVwbGUubGVuZ3RoID8gaXQucmVwbGFjZShcIiBcIiwgc3ViVHVwbGUuc2hpZnQoKSkgOiBpdDtcbiAgfSk7XG4gIGlmIChpc1R5cGVOYW1lZFR1cGxlKHR5cGUpKSB7XG4gICAgcmVjb21wb3NlZCA9IHJlY29tcG9zZWQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZU5hbWVkVHVwbGUoaXQpKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgcmV0dXJuIHJlY29tcG9zZWQ7XG59XG5mdW5jdGlvbiBleHRyYWN0Q2Fpcm8xVHVwbGUodHlwZSkge1xuICBjb25zdCBjbGVhblR5cGUgPSB0eXBlLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IHsgc3ViVHVwbGUsIHJlc3VsdCB9ID0gcGFyc2VTdWJUdXBsZShjbGVhblR5cGUpO1xuICBjb25zdCByZWNvbXBvc2VkID0gcmVzdWx0LnNwbGl0KFwiLFwiKS5tYXAoKGl0KSA9PiB7XG4gICAgcmV0dXJuIHN1YlR1cGxlLmxlbmd0aCA/IGl0LnJlcGxhY2UoXCIgXCIsIHN1YlR1cGxlLnNoaWZ0KCkpIDogaXQ7XG4gIH0pO1xuICByZXR1cm4gcmVjb21wb3NlZDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKHR5cGUpIHtcbiAgaWYgKGlzQ2Fpcm8xVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBleHRyYWN0Q2Fpcm8xVHVwbGUodHlwZSk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhY3RDYWlybzBUdXBsZSh0eXBlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3Byb3BlcnR5T3JkZXIudHNcbmZ1bmN0aW9uIGVycm9yVTI1NihrZXkpIHtcbiAgcmV0dXJuIEVycm9yKFxuICAgIGBZb3VyIG9iamVjdCBpbmNsdWRlcyB0aGUgcHJvcGVydHkgOiAke2tleX0sIGNvbnRhaW5pbmcgYW4gVWludDI1NiBvYmplY3Qgd2l0aG91dCB0aGUgJ2xvdycgYW5kICdoaWdoJyBrZXlzLmBcbiAgKTtcbn1cbmZ1bmN0aW9uIG9yZGVyUHJvcHNCeUFiaSh1bm9yZGVyZWRPYmplY3QsIGFiaU9mT2JqZWN0LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBjb25zdCBvcmRlcklucHV0ID0gKHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpID0+IHtcbiAgICBpZiAoaXNUeXBlQXJyYXkoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlckFycmF5KHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlRW51bShhYmlUeXBlLCBlbnVtcykpIHtcbiAgICAgIGNvbnN0IGFiaU9iaiA9IGVudW1zW2FiaVR5cGVdO1xuICAgICAgcmV0dXJuIG9yZGVyRW51bSh1bm9yZGVyZWRJdGVtLCBhYmlPYmopO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlVHVwbGUoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlclR1cGxlKHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlRXRoQWRkcmVzcyhhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gICAgfVxuICAgIGlmIChpc1R5cGVCeXRlQXJyYXkoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICAgIH1cbiAgICBpZiAoQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZShhYmlUeXBlKSkge1xuICAgICAgY29uc3QgdTI1NiA9IHVub3JkZXJlZEl0ZW07XG4gICAgICBpZiAodHlwZW9mIHUyNTYgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHUyNTY7XG4gICAgICB9XG4gICAgICBpZiAoIShcImxvd1wiIGluIHUyNTYgJiYgXCJoaWdoXCIgaW4gdTI1NikpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JVMjU2KGFiaVR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbG93OiB1MjU2LmxvdywgaGlnaDogdTI1Ni5oaWdoIH07XG4gICAgfVxuICAgIGlmIChpc1R5cGVTdHJ1Y3QoYWJpVHlwZSwgc3RydWN0cykpIHtcbiAgICAgIGNvbnN0IGFiaU9mU3RydWN0ID0gc3RydWN0c1thYmlUeXBlXS5tZW1iZXJzO1xuICAgICAgcmV0dXJuIG9yZGVyU3RydWN0KHVub3JkZXJlZEl0ZW0sIGFiaU9mU3RydWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gIH07XG4gIGNvbnN0IG9yZGVyU3RydWN0ID0gKHVub3JkZXJlZE9iamVjdDIsIGFiaU9iamVjdCkgPT4ge1xuICAgIGNvbnN0IG9yZGVyZWRPYmplY3QyID0gYWJpT2JqZWN0LnJlZHVjZSgob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0pID0+IHtcbiAgICAgIGNvbnN0IHNldFByb3BlcnR5ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0ubmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUgPz8gdW5vcmRlcmVkT2JqZWN0MlthYmlQYXJhbS5uYW1lXVxuICAgICAgfSk7XG4gICAgICBpZiAodW5vcmRlcmVkT2JqZWN0MlthYmlQYXJhbS5uYW1lXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoaXNDYWlybzFUeXBlKGFiaVBhcmFtLnR5cGUpIHx8ICFpc0xlbihhYmlQYXJhbS5uYW1lKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBZb3VyIG9iamVjdCBuZWVkcyBhIHByb3BlcnR5IHdpdGgga2V5IDogJHthYmlQYXJhbS5uYW1lfSAuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0MlthYmlQYXJhbS5uYW1lXSwgYWJpUGFyYW0udHlwZSkpO1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0MjtcbiAgfTtcbiAgZnVuY3Rpb24gb3JkZXJBcnJheShteUFycmF5LCBhYmlQYXJhbSkge1xuICAgIGNvbnN0IHR5cGVJbkFycmF5ID0gZ2V0QXJyYXlUeXBlKGFiaVBhcmFtKTtcbiAgICBpZiAodHlwZW9mIG15QXJyYXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBteUFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gbXlBcnJheS5tYXAoKG15RWxlbSkgPT4gb3JkZXJJbnB1dChteUVsZW0sIHR5cGVJbkFycmF5KSk7XG4gIH1cbiAgZnVuY3Rpb24gb3JkZXJUdXBsZSh1bm9yZGVyZWRPYmplY3QyLCBhYmlQYXJhbSkge1xuICAgIGNvbnN0IHR5cGVMaXN0ID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXMoYWJpUGFyYW0pO1xuICAgIGNvbnN0IG9yZGVyZWRPYmplY3QyID0gdHlwZUxpc3QucmVkdWNlKChvcmRlcmVkT2JqZWN0LCBhYmlUeXBlQ2Fpcm9YLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgbXlPYmpLZXlzID0gT2JqZWN0LmtleXModW5vcmRlcmVkT2JqZWN0Mik7XG4gICAgICBjb25zdCBzZXRQcm9wZXJ0eSA9ICh2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yZGVyZWRPYmplY3QsIGluZGV4LnRvU3RyaW5nKCksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlID8/IHVub3JkZXJlZE9iamVjdDJbbXlPYmpLZXlzW2luZGV4XV1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWJpVHlwZSA9IGFiaVR5cGVDYWlyb1g/LnR5cGUgPyBhYmlUeXBlQ2Fpcm9YLnR5cGUgOiBhYmlUeXBlQ2Fpcm9YO1xuICAgICAgc2V0UHJvcGVydHkob3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyW215T2JqS2V5c1tpbmRleF1dLCBhYmlUeXBlKSk7XG4gICAgICByZXR1cm4gb3JkZXJlZE9iamVjdDtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3QyO1xuICB9XG4gIGNvbnN0IG9yZGVyRW51bSA9ICh1bm9yZGVyZWRPYmplY3QyLCBhYmlPYmplY3QpID0+IHtcbiAgICBpZiAoaXNUeXBlUmVzdWx0KGFiaU9iamVjdC5uYW1lKSkge1xuICAgICAgY29uc3QgdW5vcmRlcmVkUmVzdWx0ID0gdW5vcmRlcmVkT2JqZWN0MjtcbiAgICAgIGNvbnN0IHJlc3VsdE9rVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIixcIilcbiAgICAgICk7XG4gICAgICBjb25zdCByZXN1bHRFcnJUeXBlID0gYWJpT2JqZWN0Lm5hbWUuc3Vic3RyaW5nKFxuICAgICAgICBhYmlPYmplY3QubmFtZS5pbmRleE9mKFwiLFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmxhc3RJbmRleE9mKFwiPlwiKVxuICAgICAgKTtcbiAgICAgIGlmICh1bm9yZGVyZWRSZXN1bHQuaXNPaygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2Fpcm9SZXN1bHQoXG4gICAgICAgICAgMCAvKiBPayAqLyxcbiAgICAgICAgICBvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDIudW53cmFwKCksIHJlc3VsdE9rVHlwZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9SZXN1bHQoXG4gICAgICAgIDEgLyogRXJyICovLFxuICAgICAgICBvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDIudW53cmFwKCksIHJlc3VsdEVyclR5cGUpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlT3B0aW9uKGFiaU9iamVjdC5uYW1lKSkge1xuICAgICAgY29uc3QgdW5vcmRlcmVkT3B0aW9uID0gdW5vcmRlcmVkT2JqZWN0MjtcbiAgICAgIGNvbnN0IHJlc3VsdFNvbWVUeXBlID0gYWJpT2JqZWN0Lm5hbWUuc3Vic3RyaW5nKFxuICAgICAgICBhYmlPYmplY3QubmFtZS5pbmRleE9mKFwiPFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmxhc3RJbmRleE9mKFwiPlwiKVxuICAgICAgKTtcbiAgICAgIGlmICh1bm9yZGVyZWRPcHRpb24uaXNTb21lKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWlyb09wdGlvbihcbiAgICAgICAgICAwIC8qIFNvbWUgKi8sXG4gICAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPcHRpb24udW53cmFwKCksIHJlc3VsdFNvbWVUeXBlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDYWlyb09wdGlvbigxIC8qIE5vbmUgKi8sIHt9KTtcbiAgICB9XG4gICAgY29uc3QgdW5vcmRlcmVkQ3VzdG9tRW51bSA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh1bm9yZGVyZWRDdXN0b21FbnVtLnZhcmlhbnQpO1xuICAgIGNvbnN0IG5ld0VudHJpZXMgPSB2YXJpYW50cy5tYXAoKHZhcmlhbnQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFyaWFudFsxXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gdmFyaWFudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhcmlhbnRUeXBlID0gYWJpT2JqZWN0LnR5cGUuc3Vic3RyaW5nKFxuICAgICAgICBhYmlPYmplY3QudHlwZS5sYXN0SW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QudHlwZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodmFyaWFudFR5cGUgPT09IFwiKClcIikge1xuICAgICAgICByZXR1cm4gdmFyaWFudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdmFyaWFudFswXSwgb3JkZXJJbnB1dCh1bm9yZGVyZWRDdXN0b21FbnVtLnVud3JhcCgpLCB2YXJpYW50VHlwZSldO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKE9iamVjdC5mcm9tRW50cmllcyhuZXdFbnRyaWVzKSk7XG4gIH07XG4gIGNvbnN0IGZpbmFsT3JkZXJlZE9iamVjdCA9IGFiaU9mT2JqZWN0LnJlZHVjZSgob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0pID0+IHtcbiAgICBjb25zdCBzZXRQcm9wZXJ0eSA9ICh2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtLm5hbWUsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIGlmIChpc0xlbihhYmlQYXJhbS5uYW1lKSAmJiAhaXNDYWlybzFUeXBlKGFiaVBhcmFtLnR5cGUpKSB7XG4gICAgICByZXR1cm4gb3JkZXJlZE9iamVjdDtcbiAgICB9XG4gICAgc2V0UHJvcGVydHkob3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3RbYWJpUGFyYW0ubmFtZV0sIGFiaVBhcmFtLnR5cGUpKTtcbiAgICByZXR1cm4gb3JkZXJlZE9iamVjdDtcbiAgfSwge30pO1xuICByZXR1cm4gZmluYWxPcmRlcmVkT2JqZWN0O1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcmVxdWVzdFBhcnNlci50c1xuZnVuY3Rpb24gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsKSB7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZSh0eXBlKTpcbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KHZhbCkudG9BcGlSZXF1ZXN0KCk7XG4gICAgY2FzZSBpc1R5cGVCeXRlczMxKHR5cGUpOlxuICAgICAgcmV0dXJuIGVuY29kZVNob3J0U3RyaW5nKHZhbC50b1N0cmluZygpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZlbHQodmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUdXBsZShlbGVtZW50LCB0eXBlU3RyKSB7XG4gIGNvbnN0IG1lbWJlclR5cGVzID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXModHlwZVN0cik7XG4gIGNvbnN0IGVsZW1lbnRzID0gT2JqZWN0LnZhbHVlcyhlbGVtZW50KTtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gbWVtYmVyVHlwZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgUGFyc2VUdXBsZTogcHJvdmlkZWQgYW5kIGV4cGVjdGVkIGFiaSB0dXBsZSBzaXplIGRvIG5vdCBtYXRjaC5cbiAgICAgIHByb3ZpZGVkOiAke2VsZW1lbnRzfSBcbiAgICAgIGV4cGVjdGVkOiAke21lbWJlclR5cGVzfWBcbiAgICApO1xuICB9XG4gIHJldHVybiBtZW1iZXJUeXBlcy5tYXAoKGl0LCBkeCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50c1tkeF0sXG4gICAgICB0eXBlOiBpdC50eXBlID8/IGl0XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUJ5dGVBcnJheShlbGVtZW50KSB7XG4gIGNvbnN0IG15Qnl0ZUFycmF5ID0gYnl0ZUFycmF5RnJvbVN0cmluZyhlbGVtZW50KTtcbiAgcmV0dXJuIFtcbiAgICBteUJ5dGVBcnJheS5kYXRhLmxlbmd0aC50b1N0cmluZygpLFxuICAgIC4uLm15Qnl0ZUFycmF5LmRhdGEubWFwKChibikgPT4gYm4udG9TdHJpbmcoKSksXG4gICAgbXlCeXRlQXJyYXkucGVuZGluZ193b3JkLnRvU3RyaW5nKCksXG4gICAgbXlCeXRlQXJyYXkucGVuZGluZ193b3JkX2xlbi50b1N0cmluZygpXG4gIF07XG59XG5mdW5jdGlvbiBwYXJzZUNhbGxkYXRhVmFsdWUoZWxlbWVudCwgdHlwZSwgc3RydWN0cywgZW51bXMpIHtcbiAgaWYgKGVsZW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHRocm93IEVycm9yKGBNaXNzaW5nIHBhcmFtZXRlciBmb3IgdHlwZSAke3R5cGV9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQucHVzaChmZWx0KGVsZW1lbnQubGVuZ3RoKSk7XG4gICAgY29uc3QgYXJyYXlUeXBlID0gZ2V0QXJyYXlUeXBlKHR5cGUpO1xuICAgIHJldHVybiBlbGVtZW50LnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VDYWxsZGF0YVZhbHVlKGl0LCBhcnJheVR5cGUsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfSwgcmVzdWx0KTtcbiAgfVxuICBpZiAoc3RydWN0c1t0eXBlXSAmJiBzdHJ1Y3RzW3R5cGVdLm1lbWJlcnMubGVuZ3RoKSB7XG4gICAgaWYgKENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KGVsZW1lbnQpLnRvQXBpUmVxdWVzdCgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIilcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbiAgICBpZiAodHlwZSA9PT0gXCJjb3JlOjpieXRlX2FycmF5OjpCeXRlQXJyYXlcIilcbiAgICAgIHJldHVybiBwYXJzZUJ5dGVBcnJheShlbGVtZW50KTtcbiAgICBjb25zdCB7IG1lbWJlcnMgfSA9IHN0cnVjdHNbdHlwZV07XG4gICAgY29uc3Qgc3ViRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgcmV0dXJuIG1lbWJlcnMucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhVmFsdWUoc3ViRWxlbWVudFtpdC5uYW1lXSwgaXQudHlwZSwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKGlzVHlwZVR1cGxlKHR5cGUpKSB7XG4gICAgY29uc3QgdHVwbGVkID0gcGFyc2VUdXBsZShlbGVtZW50LCB0eXBlKTtcbiAgICByZXR1cm4gdHVwbGVkLnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShpdC5lbGVtZW50LCBpdC50eXBlLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZWREYXRhKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gbmV3IENhaXJvVWludDI1NihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgfVxuICBpZiAoaXNUeXBlRW51bSh0eXBlLCBlbnVtcykpIHtcbiAgICBjb25zdCB7IHZhcmlhbnRzIH0gPSBlbnVtc1t0eXBlXTtcbiAgICBpZiAoaXNUeXBlT3B0aW9uKHR5cGUpKSB7XG4gICAgICBjb25zdCBteU9wdGlvbiA9IGVsZW1lbnQ7XG4gICAgICBpZiAobXlPcHRpb24uaXNTb21lKCkpIHtcbiAgICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MiA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJTb21lXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogT3B0aW9uIGhhcyBubyAnU29tZScgdmFyaWFudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlVmFyaWFudFNvbWUgPSBsaXN0VHlwZVZhcmlhbnQyLnR5cGU7XG4gICAgICAgIGlmICh0eXBlVmFyaWFudFNvbWUgPT09IFwiKClcIikge1xuICAgICAgICAgIHJldHVybiAwIC8qIFNvbWUgKi8udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIyID0gcGFyc2VDYWxsZGF0YVZhbHVlKFxuICAgICAgICAgIG15T3B0aW9uLnVud3JhcCgpLFxuICAgICAgICAgIHR5cGVWYXJpYW50U29tZSxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcjIpKSB7XG4gICAgICAgICAgcmV0dXJuIFswIC8qIFNvbWUgKi8udG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswIC8qIFNvbWUgKi8udG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gMSAvKiBOb25lICovLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVSZXN1bHQodHlwZSkpIHtcbiAgICAgIGNvbnN0IG15UmVzdWx0ID0gZWxlbWVudDtcbiAgICAgIGlmIChteVJlc3VsdC5pc09rKCkpIHtcbiAgICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MyA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJPa1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IFJlc3VsdCBoYXMgbm8gJ09rJyB2YXJpYW50LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVWYXJpYW50T2sgPSBsaXN0VHlwZVZhcmlhbnQzLnR5cGU7XG4gICAgICAgIGlmICh0eXBlVmFyaWFudE9rID09PSBcIigpXCIpIHtcbiAgICAgICAgICByZXR1cm4gMCAvKiBPayAqLy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjMgPSBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgICAgbXlSZXN1bHQudW53cmFwKCksXG4gICAgICAgICAgdHlwZVZhcmlhbnRPayxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcjMpKSB7XG4gICAgICAgICAgcmV0dXJuIFswIC8qIE9rICovLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCAvKiBPayAqLy50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXIzXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudDIgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IFwiRXJyXCIpO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFcnJvciBpbiBhYmkgOiBSZXN1bHQgaGFzIG5vICdFcnInIHZhcmlhbnQuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlVmFyaWFudEVyciA9IGxpc3RUeXBlVmFyaWFudDIudHlwZTtcbiAgICAgIGlmICh0eXBlVmFyaWFudEVyciA9PT0gXCIoKVwiKSB7XG4gICAgICAgIHJldHVybiAxIC8qIEVyciAqLy50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyMiA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShteVJlc3VsdC51bndyYXAoKSwgdHlwZVZhcmlhbnRFcnIsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcjIpKSB7XG4gICAgICAgIHJldHVybiBbMSAvKiBFcnIgKi8udG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gWzEgLyogRXJyICovLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjJdO1xuICAgIH1cbiAgICBjb25zdCBteUVudW0gPSBlbGVtZW50O1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSBteUVudW0uYWN0aXZlVmFyaWFudCgpO1xuICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gYWN0aXZlVmFyaWFudCk7XG4gICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IEVycm9yKGBOb3QgZmluZCBpbiBhYmkgOiBFbnVtIGhhcyBubyAnJHthY3RpdmVWYXJpYW50fScgdmFyaWFudC5gKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZUFjdGl2ZVZhcmlhbnQgPSBsaXN0VHlwZVZhcmlhbnQudHlwZTtcbiAgICBjb25zdCBudW1BY3RpdmVWYXJpYW50ID0gdmFyaWFudHMuZmluZEluZGV4KCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IGFjdGl2ZVZhcmlhbnQpO1xuICAgIGlmICh0eXBlQWN0aXZlVmFyaWFudCA9PT0gXCIoKVwiKSB7XG4gICAgICByZXR1cm4gbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIgPSBwYXJzZUNhbGxkYXRhVmFsdWUobXlFbnVtLnVud3JhcCgpLCB0eXBlQWN0aXZlVmFyaWFudCwgc3RydWN0cywgZW51bXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcikpIHtcbiAgICAgIHJldHVybiBbbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXJdO1xuICAgIH1cbiAgICByZXR1cm4gW251bUFjdGl2ZVZhcmlhbnQudG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyXTtcbiAgfVxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFyYW1ldGVyICR7ZWxlbWVudH0gZG8gbm90IGFsaWduIHdpdGggYWJpIHBhcmFtZXRlciAke3R5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gcGFyc2VDYWxsZGF0YUZpZWxkKGFyZ3NJdGVyYXRvciwgaW5wdXQsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gaW5wdXQ7XG4gIGxldCB7IHZhbHVlIH0gPSBhcmdzSXRlcmF0b3IubmV4dCgpO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUFycmF5KHR5cGUpOlxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAhaXNUZXh0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgQUJJIGV4cGVjdGVkIHBhcmFtZXRlciAke25hbWV9IHRvIGJlIGFycmF5IG9yIGxvbmcgc3RyaW5nLCBnb3QgJHt2YWx1ZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBzcGxpdExvbmdTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZSh2YWx1ZSwgaW5wdXQudHlwZSwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCB2YWx1ZSk7XG4gICAgY2FzZSAoaXNUeXBlU3RydWN0KHR5cGUsIHN0cnVjdHMpIHx8IGlzVHlwZVR1cGxlKHR5cGUpIHx8IENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSkpOlxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZSh2YWx1ZSwgdHlwZSwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgaXNUeXBlRW51bSh0eXBlLCBlbnVtcyk6XG4gICAgICByZXR1cm4gcGFyc2VDYWxsZGF0YVZhbHVlKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3RydWN0cyxcbiAgICAgICAgZW51bXNcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCB2YWx1ZSk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3Jlc3BvbnNlUGFyc2VyLnRzXG5mdW5jdGlvbiBwYXJzZUJhc2VUeXBlczIodHlwZSwgaXQpIHtcbiAgbGV0IHRlbXA7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgaXNUeXBlQm9vbCh0eXBlKTpcbiAgICAgIHRlbXAgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQm9vbGVhbihCaWdJbnQodGVtcCkpO1xuICAgIGNhc2UgQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZSh0eXBlKTpcbiAgICAgIGNvbnN0IGxvdyA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IGhpZ2ggPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDI1Nihsb3csIGhpZ2gpLnRvQmlnSW50KCk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiOlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OmJ5dGVzXzMxOjpieXRlczMxXCI6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIGRlY29kZVNob3J0U3RyaW5nKHRlbXApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJpZ0ludCh0ZW1wKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsZW1lbnQsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGlmIChlbGVtZW50LnR5cGUgPT09IFwiKClcIikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgbG93ID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgY29uc3QgaGlnaCA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KGxvdywgaGlnaCkudG9CaWdJbnQoKTtcbiAgfVxuICBpZiAoaXNUeXBlQnl0ZUFycmF5KGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBwYXJzZWRCeXRlczMxQXJyID0gW107XG4gICAgY29uc3QgYnl0ZXMzMUFyckxlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgd2hpbGUgKHBhcnNlZEJ5dGVzMzFBcnIubGVuZ3RoIDwgYnl0ZXMzMUFyckxlbikge1xuICAgICAgcGFyc2VkQnl0ZXMzMUFyci5wdXNoKHRvSGV4KHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKSk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdfd29yZCA9IHRvSGV4KHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICBjb25zdCBwZW5kaW5nX3dvcmRfbGVuID0gQmlnSW50KHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICBjb25zdCBteUJ5dGVBcnJheSA9IHtcbiAgICAgIGRhdGE6IHBhcnNlZEJ5dGVzMzFBcnIsXG4gICAgICBwZW5kaW5nX3dvcmQsXG4gICAgICBwZW5kaW5nX3dvcmRfbGVuXG4gICAgfTtcbiAgICByZXR1cm4gc3RyaW5nRnJvbUJ5dGVBcnJheShteUJ5dGVBcnJheSk7XG4gIH1cbiAgaWYgKGlzVHlwZUFycmF5KGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBwYXJzZWREYXRhQXJyID0gW107XG4gICAgY29uc3QgZWwgPSB7IG5hbWU6IFwiXCIsIHR5cGU6IGdldEFycmF5VHlwZShlbGVtZW50LnR5cGUpIH07XG4gICAgY29uc3QgbGVuID0gQmlnSW50KHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICB3aGlsZSAocGFyc2VkRGF0YUFyci5sZW5ndGggPCBsZW4pIHtcbiAgICAgIHBhcnNlZERhdGFBcnIucHVzaChwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWREYXRhQXJyO1xuICB9XG4gIGlmIChzdHJ1Y3RzICYmIGVsZW1lbnQudHlwZSBpbiBzdHJ1Y3RzICYmIHN0cnVjdHNbZWxlbWVudC50eXBlXSkge1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCIpIHtcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIoZWxlbWVudC50eXBlLCByZXNwb25zZUl0ZXJhdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHNbZWxlbWVudC50eXBlXS5tZW1iZXJzLnJlZHVjZSgoYWNjLCBlbCkgPT4ge1xuICAgICAgYWNjW2VsLm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoZW51bXMgJiYgZWxlbWVudC50eXBlIGluIGVudW1zICYmIGVudW1zW2VsZW1lbnQudHlwZV0pIHtcbiAgICBjb25zdCB2YXJpYW50TnVtID0gTnVtYmVyKHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICBjb25zdCByYXdFbnVtID0gZW51bXNbZWxlbWVudC50eXBlXS52YXJpYW50cy5yZWR1Y2UoKGFjYywgdmFyaWFudCwgbnVtKSA9PiB7XG4gICAgICBpZiAobnVtID09PSB2YXJpYW50TnVtKSB7XG4gICAgICAgIGFjY1t2YXJpYW50Lm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKFxuICAgICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgICAgeyBuYW1lOiBcIlwiLCB0eXBlOiB2YXJpYW50LnR5cGUgfSxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBhY2NbdmFyaWFudC5uYW1lXSA9IHZvaWQgMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aChcImNvcmU6Om9wdGlvbjo6T3B0aW9uXCIpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdmFyaWFudE51bSA9PT0gMCAvKiBTb21lICovID8gcmF3RW51bS5Tb21lIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb09wdGlvbih2YXJpYW50TnVtLCBjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKFwiY29yZTo6cmVzdWx0OjpSZXN1bHRcIikpIHtcbiAgICAgIGxldCBjb250ZW50O1xuICAgICAgaWYgKHZhcmlhbnROdW0gPT09IDAgLyogT2sgKi8pIHtcbiAgICAgICAgY29udGVudCA9IHJhd0VudW0uT2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gcmF3RW51bS5FcnI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KHZhcmlhbnROdW0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBjdXN0b21FbnVtID0gbmV3IENhaXJvQ3VzdG9tRW51bShyYXdFbnVtKTtcbiAgICByZXR1cm4gY3VzdG9tRW51bTtcbiAgfVxuICBpZiAoaXNUeXBlVHVwbGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IG1lbWJlclR5cGVzID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXMoZWxlbWVudC50eXBlKTtcbiAgICByZXR1cm4gbWVtYmVyVHlwZXMucmVkdWNlKChhY2MsIGl0LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpdD8ubmFtZSA/IGl0Lm5hbWUgOiBpZHg7XG4gICAgICBjb25zdCB0eXBlID0gaXQ/LnR5cGUgPyBpdC50eXBlIDogaXQ7XG4gICAgICBjb25zdCBlbCA9IHsgbmFtZSwgdHlwZSB9O1xuICAgICAgYWNjW25hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoaXNUeXBlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICBjb25zdCBlbCA9IHsgbmFtZTogXCJcIiwgdHlwZTogZ2V0QXJyYXlUeXBlKGVsZW1lbnQudHlwZSkgfTtcbiAgICBjb25zdCBsZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGxlbikge1xuICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzMihlbGVtZW50LnR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xufVxuZnVuY3Rpb24gcmVzcG9uc2VQYXJzZXIocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcywgcGFyc2VkUmVzdWx0KSB7XG4gIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gb3V0cHV0O1xuICBsZXQgdGVtcDtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc0xlbihuYW1lKTpcbiAgICAgIHRlbXAgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgY2FzZSAoc3RydWN0cyAmJiB0eXBlIGluIHN0cnVjdHMgfHwgaXNUeXBlVHVwbGUodHlwZSkpOlxuICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIChlbnVtcyAmJiBpc1R5cGVFbnVtKHR5cGUsIGVudW1zKSk6XG4gICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgaXNUeXBlQXJyYXkodHlwZSk6XG4gICAgICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWREYXRhQXJyID0gW107XG4gICAgICBpZiAocGFyc2VkUmVzdWx0ICYmIHBhcnNlZFJlc3VsdFtgJHtuYW1lfV9sZW5gXSkge1xuICAgICAgICBjb25zdCBhcnJMZW4gPSBwYXJzZWRSZXN1bHRbYCR7bmFtZX1fbGVuYF07XG4gICAgICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGFyckxlbikge1xuICAgICAgICAgIHBhcnNlZERhdGFBcnIucHVzaChcbiAgICAgICAgICAgIHBhcnNlUmVzcG9uc2VWYWx1ZShcbiAgICAgICAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgICAgICAgeyBuYW1lLCB0eXBlOiBvdXRwdXQudHlwZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSB9LFxuICAgICAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgICAgICBlbnVtc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWREYXRhQXJyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXMyKHR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS92YWxpZGF0ZS50c1xudmFyIHZhbGlkYXRlRmVsdCA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICB0eXBlb2YgcGFyYW1ldGVyID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJiaWdpbnRcIixcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIGZlbHQgdHlwZWQgYXMgKFN0cmluZywgTnVtYmVyIG9yIEJpZ0ludClgXG4gICk7XG4gIGlmICh0eXBlb2YgcGFyYW1ldGVyID09PSBcInN0cmluZ1wiICYmICFpc0hleChwYXJhbWV0ZXIpKVxuICAgIHJldHVybjtcbiAgY29uc3QgcGFyYW0gPSBCaWdJbnQocGFyYW1ldGVyLnRvU3RyaW5nKDEwKSk7XG4gIGFzc2VydChcbiAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI2NlxuICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Mm4gLSAxbixcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVCeXRlczMxID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIsIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgc3RyaW5nLmApO1xuICBhc3NlcnQoXG4gICAgcGFyYW1ldGVyLmxlbmd0aCA8IDMyLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgYSBzdHJpbmcgb2YgbGVzcyB0aGFuIDMyIGNoYXJhY3RlcnMuYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZUJ5dGVBcnJheSA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydCh0eXBlb2YgcGFyYW1ldGVyID09PSBcInN0cmluZ1wiLCBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIHN0cmluZy5gKTtcbn07XG52YXIgdmFsaWRhdGVVaW50ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgaWYgKHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICBhc3NlcnQoXG4gICAgICBwYXJhbWV0ZXIgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICBgVmFsaWRhdGlvbjogUGFyYW1ldGVyIGlzIHRvIGxhcmdlIHRvIGJlIHR5cGVkIGFzIE51bWJlciB1c2UgKEJpZ0ludCBvciBTdHJpbmcpYFxuICAgICk7XG4gIH1cbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgcGFyYW1ldGVyID09PSBcImJpZ2ludFwiIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgXCJsb3dcIiBpbiBwYXJhbWV0ZXIgJiYgXCJoaWdoXCIgaW4gcGFyYW1ldGVyLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gb2YgY2Fpcm8gdHlwZSAke2lucHV0LnR5cGV9IHNob3VsZCBiZSB0eXBlIChTdHJpbmcsIE51bWJlciBvciBCaWdJbnQpLCBidXQgaXMgJHt0eXBlb2YgcGFyYW1ldGVyfSAke3BhcmFtZXRlcn0uYFxuICApO1xuICBjb25zdCBwYXJhbSA9IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgPyBuZXcgQ2Fpcm9VaW50MjU2KHBhcmFtZXRlcikudG9CaWdJbnQoKSA6IHRvQmlnSW50KHBhcmFtZXRlcik7XG4gIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1OFwiIC8qIHU4ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAyNTVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswIC0gMjU1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTE2XCIgLyogdTE2ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSA2NTUzNW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDY1NTM1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTMyXCIgLyogdTMyICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSA0Mjk0OTY3Mjk1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgNDI5NDk2NzI5NV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU2NFwiIC8qIHU2NCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogNjRuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeNjQtMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUxMjhcIiAvKiB1MTI4ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAxMjhuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMTI4LTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCIgLyogdTI1NiAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjU2biAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzICR7aW5wdXQudHlwZX0gMCAtIDJeMjU2LTFgXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OnN0YXJrbmV0OjpjbGFzc19oYXNoOjpDbGFzc0hhc2hcIiAvKiBDbGFzc0hhc2ggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxNjcwXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Mm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4yNTItMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIiAvKiBDb250cmFjdEFkZHJlc3MgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjQ1XG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Mm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4yNTItMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59O1xudmFyIHZhbGlkYXRlQm9vbCA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICB0eXBlb2YgcGFyYW1ldGVyID09PSBcImJvb2xlYW5cIixcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IG9mIGNhaXJvIHR5cGUgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgdHlwZSAoQm9vbGVhbilgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlU3RydWN0ID0gKHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMpID0+IHtcbiAgaWYgKGlucHV0LnR5cGUgPT09IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiIC8qIHUyNTYgKi8pIHtcbiAgICB2YWxpZGF0ZVVpbnQocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbnB1dC50eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHBhcmFtZXRlciAhPT0gXCJvYmplY3RcIixcbiAgICAgIGBFdGhBZGRyZXNzIHR5cGUgaXMgd2FpdGluZyBhIEJpZ051bWJlcmlzaC4gR290ICR7cGFyYW1ldGVyfWBcbiAgICApO1xuICAgIGNvbnN0IHBhcmFtID0gQmlnSW50KHBhcmFtZXRlci50b1N0cmluZygxMCkpO1xuICAgIGFzc2VydChcbiAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjU5XG4gICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAxNjBuIC0gMW4sXG4gICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjE2MC0xXWBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgY2Fpcm8gdHlwZSBzdHJ1Y3QgKCR7aW5wdXQudHlwZX0pLCBhbmQgc2hvdWxkIGJlIGRlZmluZWQgYXMganMgb2JqZWN0IChub3QgYXJyYXkpYFxuICApO1xuICBzdHJ1Y3RzW2lucHV0LnR5cGVdLm1lbWJlcnMuZm9yRWFjaCgoeyBuYW1lIH0pID0+IHtcbiAgICBhc3NlcnQoXG4gICAgICBPYmplY3Qua2V5cyhwYXJhbWV0ZXIpLmluY2x1ZGVzKG5hbWUpLFxuICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgaGF2ZSBhIHByb3BlcnR5ICR7bmFtZX1gXG4gICAgKTtcbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlRW51bSA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHBhcmFtZXRlciksXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyBjYWlybyB0eXBlIEVudW0gKCR7aW5wdXQudHlwZX0pLCBhbmQgc2hvdWxkIGJlIGRlZmluZWQgYXMganMgb2JqZWN0IChub3QgYXJyYXkpYFxuICApO1xuICBjb25zdCBtZXRob2RzS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJhbWV0ZXIpKTtcbiAgY29uc3Qga2V5cyA9IFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYXJhbWV0ZXIpLCAuLi5tZXRob2RzS2V5c107XG4gIGlmIChpc1R5cGVPcHRpb24oaW5wdXQudHlwZSkgJiYga2V5cy5pbmNsdWRlcyhcImlzU29tZVwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNOb25lXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1R5cGVSZXN1bHQoaW5wdXQudHlwZSkgJiYga2V5cy5pbmNsdWRlcyhcImlzT2tcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzRXJyXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChrZXlzLmluY2x1ZGVzKFwidmFyaWFudFwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiYWN0aXZlVmFyaWFudFwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFZhbGlkYXRlIEVudW06IGFyZ3VtZW50ICR7aW5wdXQubmFtZX0sIHR5cGUgJHtpbnB1dC50eXBlfSwgdmFsdWUgcmVjZWl2ZWQgJHtwYXJhbWV0ZXJ9LCBpcyBub3QgYW4gRW51bS5gXG4gICk7XG59O1xudmFyIHZhbGlkYXRlVHVwbGUgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgdHVwbGUgKGRlZmluZWQgYXMgb2JqZWN0KWBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVBcnJheSA9IChwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcykgPT4ge1xuICBjb25zdCBiYXNlVHlwZSA9IGdldEFycmF5VHlwZShpbnB1dC50eXBlKTtcbiAgaWYgKGlzVHlwZUZlbHQoYmFzZVR5cGUpICYmIGlzTG9uZ1RleHQocGFyYW1ldGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLCBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhbiBBcnJheWApO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUZlbHQoYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZUZlbHQocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZVR1cGxlKGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChpdCkgPT4gdmFsaWRhdGVUdXBsZShpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUFycmF5KGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKFxuICAgICAgICAocGFyYW0pID0+IHZhbGlkYXRlQXJyYXkocGFyYW0sIHsgbmFtZTogXCJcIiwgdHlwZTogYmFzZVR5cGUgfSwgc3RydWN0cywgZW51bXMpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVTdHJ1Y3QoYmFzZVR5cGUsIHN0cnVjdHMpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goXG4gICAgICAgIChpdCkgPT4gdmFsaWRhdGVTdHJ1Y3QoaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSwgc3RydWN0cylcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUVudW0oYmFzZVR5cGUsIGVudW1zKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChpdCkgPT4gdmFsaWRhdGVFbnVtKGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0pKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgKGlzVHlwZVVpbnQoYmFzZVR5cGUpIHx8IGlzVHlwZUxpdGVyYWwoYmFzZVR5cGUpKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVVaW50KHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVCb29sKGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVCb29sKHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFZhbGlkYXRlIFVuaGFuZGxlZDogYXJndW1lbnQgJHtpbnB1dC5uYW1lfSwgdHlwZSAke2lucHV0LnR5cGV9LCB2YWx1ZSAke3BhcmFtZXRlcn1gXG4gICAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCBzdHJ1Y3RzLCBlbnVtcykge1xuICBhYmlNZXRob2QuaW5wdXRzLnJlZHVjZSgoYWNjLCBpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IGFyZ3NbYWNjXTtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgaXNMZW4oaW5wdXQubmFtZSk6XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICBjYXNlIGlzVHlwZUZlbHQoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlRmVsdChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUJ5dGVzMzEoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQnl0ZXMzMShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIChpc1R5cGVVaW50KGlucHV0LnR5cGUpIHx8IGlzVHlwZUxpdGVyYWwoaW5wdXQudHlwZSkpOlxuICAgICAgICB2YWxpZGF0ZVVpbnQocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVCb29sKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZUJvb2wocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVCeXRlQXJyYXkoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQnl0ZUFycmF5KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlQXJyYXkoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQXJyYXkocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlU3RydWN0KGlucHV0LnR5cGUsIHN0cnVjdHMpOlxuICAgICAgICB2YWxpZGF0ZVN0cnVjdChwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUVudW0oaW5wdXQudHlwZSwgZW51bXMpOlxuICAgICAgICB2YWxpZGF0ZUVudW0ocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVUdXBsZShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVUdXBsZShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFZhbGlkYXRlIFVuaGFuZGxlZDogYXJndW1lbnQgJHtpbnB1dC5uYW1lfSwgdHlwZSAke2lucHV0LnR5cGV9LCB2YWx1ZSAke3BhcmFtZXRlcn1gXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhY2MgKyAxO1xuICB9LCAwKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2luZGV4LnRzXG52YXIgQ2FsbERhdGEgPSBjbGFzcyB7XG4gIGFiaTtcbiAgcGFyc2VyO1xuICBzdHJ1Y3RzO1xuICBlbnVtcztcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5zdHJ1Y3RzID0gQ2FsbERhdGEuZ2V0QWJpU3RydWN0KGFiaSk7XG4gICAgdGhpcy5lbnVtcyA9IENhbGxEYXRhLmdldEFiaUVudW0oYWJpKTtcbiAgICB0aGlzLnBhcnNlciA9IGNyZWF0ZUFiaVBhcnNlcihhYmkpO1xuICAgIHRoaXMuYWJpID0gdGhpcy5wYXJzZXIuZ2V0TGVnYWN5Rm9ybWF0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZCBhcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBvbmVzIGluIHRoZSBhYmlcbiAgICogQHBhcmFtIHR5cGUgVmFsaWRhdGVUeXBlIC0gdHlwZSBvZiB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gbmFtZSBvZiB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSBhcmdzIEFyZ3NPckNhbGxkYXRhIC0gYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gICAqL1xuICB2YWxpZGF0ZSh0eXBlLCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICAgIGlmICh0eXBlICE9PSBcIkRFUExPWVwiIC8qIERFUExPWSAqLykge1xuICAgICAgY29uc3QgaW52b2NhYmxlRnVuY3Rpb25OYW1lcyA9IHRoaXMuYWJpLmZpbHRlcigoYWJpKSA9PiB7XG4gICAgICAgIGlmIChhYmkudHlwZSAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaXNWaWV3ID0gYWJpLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgYWJpLnN0YXRlX211dGFiaWxpdHkgPT09IFwidmlld1wiO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8gPyAhaXNWaWV3IDogaXNWaWV3O1xuICAgICAgfSkubWFwKChhYmkpID0+IGFiaS5uYW1lKTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgaW52b2NhYmxlRnVuY3Rpb25OYW1lcy5pbmNsdWRlcyhtZXRob2QpLFxuICAgICAgICBgJHt0eXBlID09PSBcIklOVk9LRVwiIC8qIElOVk9LRSAqLyA/IFwiaW52b2NhYmxlXCIgOiBcInZpZXdhYmxlXCJ9IG1ldGhvZCBub3QgZm91bmQgaW4gYWJpYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYWJpTWV0aG9kID0gdGhpcy5hYmkuZmluZChcbiAgICAgIChhYmkpID0+IHR5cGUgPT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovID8gYWJpLm5hbWUgPT09IG1ldGhvZCAmJiBhYmkudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiIDogYWJpLm5hbWUgPT09IG1ldGhvZCAmJiBhYmkudHlwZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgKTtcbiAgICBpZiAoaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzLCBhYmlNZXRob2QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0c0xlbmd0aCA9IHRoaXMucGFyc2VyLm1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpO1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gaW5wdXRzTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cywgZXhwZWN0ZWQgJHtpbnB1dHNMZW5ndGh9IGFyZ3VtZW50cywgYnV0IGdvdCAke2FyZ3MubGVuZ3RofWBcbiAgICAgICk7XG4gICAgfVxuICAgIHZhbGlkYXRlRmllbGRzKGFiaU1ldGhvZCwgYXJncywgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zKTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSBjb250cmFjdCBjYWxsRGF0YSB3aXRoIGFiaVxuICAgKiBQYXJzZSB0aGUgY2FsbGRhdGEgYnkgdXNpbmcgaW5wdXQgZmllbGRzIGZyb20gdGhlIGFiaSBmb3IgdGhhdCBtZXRob2RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gYXJncyBSYXdBcmdzIC0gYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLiBDYW4gYmUgYW4gYXJyYXkgb2YgYXJndW1lbnRzIChpbiB0aGUgb3JkZXIgb2YgYWJpIGRlZmluaXRpb24pLCBvciBhbiBvYmplY3QgY29uc3RydWN0ZWQgaW4gY29uZm9ybWl0eSB3aXRoIGFiaSAoaW4gdGhpcyBjYXNlLCB0aGUgcGFyYW1ldGVyIGNhbiBiZSBpbiBhIHdyb25nIG9yZGVyKS5cbiAgICogQHJldHVybiBDYWxsZGF0YSAtIHBhcnNlZCBhcmd1bWVudHMgaW4gZm9ybWF0IHRoYXQgY29udHJhY3QgaXMgZXhwZWN0aW5nXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY2FsbGRhdGEgPSBteUNhbGxEYXRhLmNvbXBpbGUoXCJjb25zdHJ1Y3RvclwiLCBbXCIweDM0YVwiLCBbMSwgM25dXSk7XG4gICAqIGBgYFxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNhbGxkYXRhMiA9IG15Q2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIHtsaXN0OlsxLCAzbl0sIGJhbGFuY2U6XCIweDM0XCJ9KTsgLy8gd3Jvbmcgb3JkZXIgaXMgdmFsaWRcbiAgICogYGBgXG4gICAqL1xuICBjb21waWxlKG1ldGhvZCwgYXJnc0NhbGxkYXRhKSB7XG4gICAgY29uc3QgYWJpTWV0aG9kID0gdGhpcy5hYmkuZmluZCgoYWJpRnVuY3Rpb24pID0+IGFiaUZ1bmN0aW9uLm5hbWUgPT09IG1ldGhvZCk7XG4gICAgaWYgKGlzTm9Db25zdHJ1Y3RvclZhbGlkKG1ldGhvZCwgYXJnc0NhbGxkYXRhLCBhYmlNZXRob2QpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBhcmdzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NDYWxsZGF0YSkpIHtcbiAgICAgIGFyZ3MgPSBhcmdzQ2FsbGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9yZGVyZWRPYmplY3QgPSBvcmRlclByb3BzQnlBYmkoXG4gICAgICAgIGFyZ3NDYWxsZGF0YSxcbiAgICAgICAgYWJpTWV0aG9kLmlucHV0cyxcbiAgICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgICB0aGlzLmVudW1zXG4gICAgICApO1xuICAgICAgYXJncyA9IE9iamVjdC52YWx1ZXMob3JkZXJlZE9iamVjdCk7XG4gICAgICB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3NJdGVyYXRvciA9IGFyZ3NbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGNhbGxBcnJheSA9IGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKFxuICAgICAgKGFjYywgaW5wdXQpID0+IGlzTGVuKGlucHV0Lm5hbWUpICYmICFpc0NhaXJvMVR5cGUoaW5wdXQudHlwZSkgPyBhY2MgOiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpKSxcbiAgICAgIFtdXG4gICAgKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FsbEFycmF5LCBcIl9fY29tcGlsZWRfX1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxBcnJheTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSBjb250cmFjdCBjYWxsRGF0YSB3aXRob3V0IGFiaVxuICAgKiBAcGFyYW0gcmF3QXJncyBSYXdBcmdzIHJlcHJlc2VudGluZyBjYWlybyBtZXRob2QgYXJndW1lbnRzIG9yIHN0cmluZyBhcnJheSBvZiBjb21waWxlZCBkYXRhXG4gICAqIEByZXR1cm5zIENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgY29tcGlsZShyYXdBcmdzKSB7XG4gICAgY29uc3QgY3JlYXRlVHJlZSA9IChvYmopID0+IHtcbiAgICAgIGNvbnN0IGdldEVudHJpZXMgPSAobywgcHJlZml4ID0gXCIuXCIpID0+IHtcbiAgICAgICAgY29uc3Qgb2UgPSBBcnJheS5pc0FycmF5KG8pID8gW28ubGVuZ3RoLnRvU3RyaW5nKCksIC4uLm9dIDogbztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9lKS5mbGF0TWFwKChbaywgdl0pID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB2O1xuICAgICAgICAgIGlmIChpc0xvbmdUZXh0KHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gYnl0ZUFycmF5RnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGsgPT09IFwiZW50cnlwb2ludFwiKVxuICAgICAgICAgICAgdmFsdWUgPSBnZXRTZWxlY3RvckZyb21OYW1lKHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBrayA9IEFycmF5LmlzQXJyYXkob2UpICYmIGsgPT09IFwiMFwiID8gXCIkJGxlblwiIDogaztcbiAgICAgICAgICBpZiAoaXNCaWdJbnQodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdCh2YWx1ZSldXTtcbiAgICAgICAgICBpZiAoT2JqZWN0KHZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZHNLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSwgLi4ubWV0aG9kc0tleXNdO1xuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteU9wdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYW50TmIgPSBteU9wdGlvbi5pc1NvbWUoKSA/IDAgLyogU29tZSAqLyA6IDEgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgaWYgKG15T3B0aW9uLmlzU29tZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogdmFyaWFudE5iLCAxOiBteU9wdGlvbi51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFyaWFudE5iKV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJpc09rXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc0VyclwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteVJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYW50TmIgPSBteVJlc3VsdC5pc09rKCkgPyAwIC8qIE9rICovIDogMSAvKiBFcnIgKi87XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogdmFyaWFudE5iLCAxOiBteVJlc3VsdC51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcyhcInZhcmlhbnRcIikgJiYga2V5cy5pbmNsdWRlcyhcImFjdGl2ZVZhcmlhbnRcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlFbnVtID0gdmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSBteUVudW0uYWN0aXZlVmFyaWFudCgpO1xuICAgICAgICAgICAgICBjb25zdCBsaXN0VmFyaWFudHMgPSBPYmplY3Qua2V5cyhteUVudW0udmFyaWFudCk7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnROYiA9IGxpc3RWYXJpYW50cy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgKHZhcmlhbnQpID0+IHZhcmlhbnQgPT09IGFjdGl2ZVZhcmlhbnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBteUVudW0udW53cmFwKCkgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMobXlFbnVtLnVud3JhcCgpKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KGFjdGl2ZVZhcmlhbnROYildXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IGFjdGl2ZVZhcmlhbnROYiwgMTogbXlFbnVtLnVud3JhcCgpIH0sIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHZhbHVlLCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFsdWUpXV07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5mcm9tRW50cmllcyhnZXRFbnRyaWVzKG9iaikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGxldCBjYWxsVHJlZUFycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyYXdBcmdzKSkge1xuICAgICAgY29uc3QgY2FsbFRyZWUgPSBjcmVhdGVUcmVlKHJhd0FyZ3MpO1xuICAgICAgY2FsbFRyZWVBcnJheSA9IE9iamVjdC52YWx1ZXMoY2FsbFRyZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjYWxsT2JqID0geyAuLi5yYXdBcmdzIH07XG4gICAgICBjb25zdCBjYWxsVHJlZSA9IGNyZWF0ZVRyZWUoY2FsbE9iaik7XG4gICAgICBjYWxsVHJlZUFycmF5ID0gT2JqZWN0LnZhbHVlcyhjYWxsVHJlZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWxsVHJlZUFycmF5LCBcIl9fY29tcGlsZWRfX1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxUcmVlQXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGVsZW1lbnRzIG9mIHRoZSByZXNwb25zZSBhcnJheSBhbmQgc3RydWN0dXJpbmcgdGhlbSBpbnRvIHJlc3BvbnNlIG9iamVjdFxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSByZXNwb25zZSBzdHJpbmdbXSAtIHJlc3BvbnNlIGZyb20gdGhlIG1ldGhvZFxuICAgKiBAcmV0dXJuIFJlc3VsdCAtIHBhcnNlZCByZXNwb25zZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBhYmlcbiAgICovXG4gIHBhcnNlKG1ldGhvZCwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCB7IG91dHB1dHMgfSA9IHRoaXMuYWJpLmZpbmQoKGFiaSkgPT4gYWJpLm5hbWUgPT09IG1ldGhvZCk7XG4gICAgY29uc3QgcmVzcG9uc2VJdGVyYXRvciA9IHJlc3BvbnNlLmZsYXQoKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgcGFyc2VkID0gb3V0cHV0cy5mbGF0KCkucmVkdWNlKChhY2MsIG91dHB1dCwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBwcm9wTmFtZSA9IG91dHB1dC5uYW1lID8/IGlkeDtcbiAgICAgIGFjY1twcm9wTmFtZV0gPSByZXNwb25zZVBhcnNlcihyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcywgYWNjKTtcbiAgICAgIGlmIChhY2NbcHJvcE5hbWVdICYmIGFjY1tgJHtwcm9wTmFtZX1fbGVuYF0pIHtcbiAgICAgICAgZGVsZXRlIGFjY1tgJHtwcm9wTmFtZX1fbGVuYF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggPT09IDEgJiYgMCBpbiBwYXJzZWQgPyBwYXJzZWRbMF0gOiBwYXJzZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEZvcm1hdCBjYWlybyBtZXRob2QgcmVzcG9uc2UgZGF0YSB0byBuYXRpdmUganMgdmFsdWVzIGJhc2VkIG9uIHByb3ZpZGVkIGZvcm1hdCBzY2hlbWFcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBjYWlybyBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSBjYWlybyBtZXRob2QgcmVzcG9uc2VcbiAgICogQHBhcmFtIGZvcm1hdCBvYmplY3QgLSBmb3JtYXR0ZXIgb2JqZWN0IHNjaGVtYVxuICAgKiBAcmV0dXJucyBSZXN1bHQgLSBwYXJzZWQgYW5kIGZvcm1hdHRlZCByZXNwb25zZSBvYmplY3RcbiAgICovXG4gIGZvcm1hdChtZXRob2QsIHJlc3BvbnNlLCBmb3JtYXQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlKG1ldGhvZCwgcmVzcG9uc2UpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIocGFyc2VkLCBmb3JtYXQpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBzdHJ1Y3RzIGZyb20gYWJpXG4gICAqIEBwYXJhbSBhYmkgQWJpXG4gICAqIEByZXR1cm5zIEFiaVN0cnVjdHMgLSBzdHJ1Y3RzIGZyb20gYWJpXG4gICAqL1xuICBzdGF0aWMgZ2V0QWJpU3RydWN0KGFiaSkge1xuICAgIHJldHVybiBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJzdHJ1Y3RcIikucmVkdWNlKFxuICAgICAgKGFjYywgYWJpRW50cnkpID0+ICh7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2FiaUVudHJ5Lm5hbWVdOiBhYmlFbnRyeVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciB0byBleHRyYWN0IGVudW1zIGZyb20gYWJpXG4gICAqIEBwYXJhbSBhYmkgQWJpXG4gICAqIEByZXR1cm5zIEFiaUVudW1zIC0gZW51bXMgZnJvbSBhYmlcbiAgICovXG4gIHN0YXRpYyBnZXRBYmlFbnVtKGFiaSkge1xuICAgIGNvbnN0IGZ1bGxFbnVtTGlzdCA9IGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcImVudW1cIikucmVkdWNlKFxuICAgICAgKGFjYywgYWJpRW50cnkpID0+ICh7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2FiaUVudHJ5Lm5hbWVdOiBhYmlFbnRyeVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gICAgZGVsZXRlIGZ1bGxFbnVtTGlzdFtcImNvcmU6OmJvb2xcIl07XG4gICAgcmV0dXJuIGZ1bGxFbnVtTGlzdDtcbiAgfVxuICAvKipcbiAgICogSGVscGVyOiBDb21waWxlIEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEBwYXJhbSByYXdDYWxsZGF0YSBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcmV0dXJucyBDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIHRvQ2FsbGRhdGEocmF3Q2FsbGRhdGEgPSBbXSkge1xuICAgIHJldHVybiBDYWxsRGF0YS5jb21waWxlKHJhd0NhbGxkYXRhKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyOiBDb252ZXJ0IHJhdyB0byBIZXhDYWxsZGF0YVxuICAgKiBAcGFyYW0gcmF3IEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEByZXR1cm5zIEhleENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgdG9IZXgocmF3ID0gW10pIHtcbiAgICBjb25zdCBjYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUocmF3KTtcbiAgICByZXR1cm4gY2FsbGRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgY29udHJhY3QgcmVzcG9uc2UgYW5kIHN0cnVjdHVyZSB0aGVtIGludG8gb25lIG9yIHNldmVyYWwgUmVzdWx0LlxuICAgKiBJbiBDYWlybyAwLCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqIEBwYXJhbSB0eXBlQ2Fpcm8gc3RyaW5nIG9yIHN0cmluZ1tdIC0gQ2Fpcm8gdHlwZSBuYW1lLCBleCA6IFwiaGVsbG86OmhlbGxvOjpVc2VyRGF0YVwiXG4gICAqIEBwYXJhbSByZXNwb25zZSBzdHJpbmdbXSAtIHNlcmlhbGl6ZWQgZGF0YSBjb3JyZXNwb25kaW5nIHRvIHR5cGVDYWlyby5cbiAgICogQHJldHVybiBSZXN1bHQgb3IgUmVzdWx0W10gLSBwYXJzZWQgcmVzcG9uc2UgY29ycmVzcG9uZGluZyB0byB0eXBlRGF0YS5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVzMj1oZWxsb0NhbGxEYXRhLmRlY29kZVBhcmFtZXRlcnMoXCJoZWxsbzo6aGVsbG86OlVzZXJEYXRhXCIsW1wiMHgxMjM0NTZcIixcIjB4MVwiXSk7XG4gICAqIHJlc3VsdCA9IHsgYWRkcmVzczogMTE5MzA0Nm4sIGlzX2NsYWltZWQ6IHRydWUgfVxuICAgKi9cbiAgZGVjb2RlUGFyYW1ldGVycyh0eXBlQ2Fpcm8sIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgdHlwZUNhaXJvQXJyYXkgPSBBcnJheS5pc0FycmF5KHR5cGVDYWlybykgPyB0eXBlQ2Fpcm8gOiBbdHlwZUNhaXJvXTtcbiAgICBjb25zdCByZXNwb25zZUl0ZXJhdG9yID0gcmVzcG9uc2UuZmxhdCgpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBkZWNvZGVkQXJyYXkgPSB0eXBlQ2Fpcm9BcnJheS5tYXAoXG4gICAgICAodHlwZVBhcmFtKSA9PiByZXNwb25zZVBhcnNlcihcbiAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgeyBuYW1lOiBcIlwiLCB0eXBlOiB0eXBlUGFyYW0gfSxcbiAgICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgICB0aGlzLmVudW1zXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZEFycmF5Lmxlbmd0aCA9PT0gMSA/IGRlY29kZWRBcnJheVswXSA6IGRlY29kZWRBcnJheTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2hhc2gvaW5kZXgudHNcbnZhciBoYXNoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGhhc2hfZXhwb3J0cywge1xuICBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaDogKCkgPT4gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2gsXG4gIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzLFxuICBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyxcbiAgY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyLFxuICBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVDb21waWxlZENsYXNzSGFzaCxcbiAgY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2gsXG4gIGNvbXB1dGVIYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMixcbiAgY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2gsXG4gIGNvbXB1dGVQZWRlcnNlbkhhc2g6ICgpID0+IGNvbXB1dGVQZWRlcnNlbkhhc2gsXG4gIGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlUGVkZXJzZW5IYXNoT25FbGVtZW50cyxcbiAgY29tcHV0ZVBvc2VpZG9uSGFzaDogKCkgPT4gY29tcHV0ZVBvc2VpZG9uSGFzaCxcbiAgY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHM6ICgpID0+IGNvbXB1dGVQb3NlaWRvbkhhc2hPbkVsZW1lbnRzLFxuICBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaCxcbiAgZm9ybWF0U3BhY2VzOiAoKSA9PiBmb3JtYXRTcGFjZXMsXG4gIGdldFNlbGVjdG9yOiAoKSA9PiBnZXRTZWxlY3RvcixcbiAgZ2V0U2VsZWN0b3JGcm9tTmFtZTogKCkgPT4gZ2V0U2VsZWN0b3JGcm9tTmFtZSxcbiAga2VjY2FrQm46ICgpID0+IGtlY2Nha0JuLFxuICBwb3NlaWRvbjogKCkgPT4gcG9zZWlkb24sXG4gIHN0YXJrbmV0S2VjY2FrOiAoKSA9PiBzdGFya25ldEtlY2Nha1xufSk7XG5pbXBvcnQgKiBhcyBwb3NlaWRvbiBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9wb3NlaWRvblwiO1xuXG4vLyBzcmMvdXRpbHMvaGFzaC90cmFuc2FjdGlvbkhhc2gvdjIudHNcbnZhciB2Ml9leHBvcnRzID0ge307XG5fX2V4cG9ydCh2Ml9leHBvcnRzLCB7XG4gIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gsXG4gIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gsXG4gIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb246ICgpID0+IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbixcbiAgY29tcHV0ZUhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlSGFzaE9uRWxlbWVudHNcbn0pO1xuXG4vLyBzcmMvdXRpbHMvZWMudHNcbnZhciBlY19leHBvcnRzID0ge307XG5fX2V4cG9ydChlY19leHBvcnRzLCB7XG4gIHN0YXJrQ3VydmU6ICgpID0+IHN0YXJrQ3VydmUsXG4gIHdlaWVyc3RyYXNzOiAoKSA9PiB3ZWllcnN0cmFzc1xufSk7XG5pbXBvcnQgKiBhcyBzdGFya0N1cnZlIGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmltcG9ydCAqIGFzIHdlaWVyc3RyYXNzIGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzXCI7XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC92Mi50c1xuZnVuY3Rpb24gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGRhdGEpIHtcbiAgcmV0dXJuIFsuLi5kYXRhLCBkYXRhLmxlbmd0aF0ucmVkdWNlKCh4LCB5KSA9PiBzdGFya0N1cnZlLnBlZGVyc2VuKHRvQmlnSW50KHgpLCB0b0JpZ0ludCh5KSksIDApLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24odHhIYXNoUHJlZml4LCB2ZXJzaW9uLCBjb250cmFjdEFkZHJlc3MsIGVudHJ5UG9pbnRTZWxlY3RvciwgY2FsbGRhdGEsIG1heEZlZSwgY2hhaW5JZCwgYWRkaXRpb25hbERhdGEgPSBbXSkge1xuICBjb25zdCBjYWxsZGF0YUhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoY2FsbGRhdGEpO1xuICBjb25zdCBkYXRhVG9IYXNoID0gW1xuICAgIHR4SGFzaFByZWZpeCxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBlbnRyeVBvaW50U2VsZWN0b3IsXG4gICAgY2FsbGRhdGFIYXNoLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIC4uLmFkZGl0aW9uYWxEYXRhXG4gIF07XG4gIHJldHVybiBjb21wdXRlSGFzaE9uRWxlbWVudHMoZGF0YVRvSGFzaCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoKGNsYXNzSGFzaCwgc2VuZGVyQWRkcmVzcywgdmVyc2lvbiwgbWF4RmVlLCBjaGFpbklkLCBub25jZSwgY29tcGlsZWRDbGFzc0hhc2gpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4NjQ2NTYzNmM2MTcyNjVcIiAvKiBERUNMQVJFICovLFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICAwLFxuICAgIFtjbGFzc0hhc2hdLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZSwgLi4uY29tcGlsZWRDbGFzc0hhc2ggPyBbY29tcGlsZWRDbGFzc0hhc2hdIDogW11dXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzYWx0LCB2ZXJzaW9uLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlKSB7XG4gIGNvbnN0IGNhbGxkYXRhID0gW2NsYXNzSGFzaCwgc2FsdCwgLi4uY29uc3RydWN0b3JDYWxsZGF0YV07XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAwLFxuICAgIGNhbGxkYXRhLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChjb250cmFjdEFkZHJlc3MsIHZlcnNpb24sIGNhbGxkYXRhLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY5NmU3NjZmNmI2NVwiIC8qIElOVk9LRSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAwLFxuICAgIGNhbGxkYXRhLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZV1cbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhc2gvdHJhbnNhY3Rpb25IYXNoL3YzLnRzXG52YXIgdjNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodjNfZXhwb3J0cywge1xuICBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMixcbiAgY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDIsXG4gIGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb246ICgpID0+IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjIsXG4gIGhhc2hEQU1vZGU6ICgpID0+IGhhc2hEQU1vZGUsXG4gIGhhc2hGZWVGaWVsZDogKCkgPT4gaGFzaEZlZUZpZWxkXG59KTtcbmltcG9ydCB7IHBvc2VpZG9uSGFzaE1hbnkgfSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG52YXIgQVRvQkkgPSAoYXJyYXkpID0+IGFycmF5Lm1hcCgoaXQpID0+IEJpZ0ludChpdCkpO1xudmFyIERBVEFfQVZBSUxBQklMSVRZX01PREVfQklUUyA9IDMybjtcbnZhciBNQVhfQU1PVU5UX0JJVFMgPSA2NG47XG52YXIgTUFYX1BSSUNFX1BFUl9VTklUX0JJVFMgPSAxMjhuO1xudmFyIFJFU09VUkNFX1ZBTFVFX09GRlNFVCA9IE1BWF9BTU9VTlRfQklUUyArIE1BWF9QUklDRV9QRVJfVU5JVF9CSVRTO1xudmFyIEwxX0dBU19OQU1FID0gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKFwiTDFfR0FTXCIpKTtcbnZhciBMMl9HQVNfTkFNRSA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhcIkwyX0dBU1wiKSk7XG5mdW5jdGlvbiBoYXNoREFNb2RlKG5vbmNlREFNb2RlLCBmZWVEQU1vZGUpIHtcbiAgcmV0dXJuIChCaWdJbnQobm9uY2VEQU1vZGUpIDw8IERBVEFfQVZBSUxBQklMSVRZX01PREVfQklUUykgKyBCaWdJbnQoZmVlREFNb2RlKTtcbn1cbmZ1bmN0aW9uIGhhc2hGZWVGaWVsZCh0aXAsIGJvdW5kcykge1xuICBjb25zdCBMMUJvdW5kID0gKEwxX0dBU19OQU1FIDw8IFJFU09VUkNFX1ZBTFVFX09GRlNFVCkgKyAoQmlnSW50KGJvdW5kcy5sMV9nYXMubWF4X2Ftb3VudCkgPDwgTUFYX1BSSUNFX1BFUl9VTklUX0JJVFMpICsgQmlnSW50KGJvdW5kcy5sMV9nYXMubWF4X3ByaWNlX3Blcl91bml0KTtcbiAgY29uc3QgTDJCb3VuZCA9IChMMl9HQVNfTkFNRSA8PCBSRVNPVVJDRV9WQUxVRV9PRkZTRVQpICsgKEJpZ0ludChib3VuZHMubDJfZ2FzLm1heF9hbW91bnQpIDw8IE1BWF9QUklDRV9QRVJfVU5JVF9CSVRTKSArIEJpZ0ludChib3VuZHMubDJfZ2FzLm1heF9wcmljZV9wZXJfdW5pdCk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55KFtCaWdJbnQodGlwKSwgTDFCb3VuZCwgTDJCb3VuZF0pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uMih0eEhhc2hQcmVmaXgsIHZlcnNpb24sIHNlbmRlckFkZHJlc3MsIGNoYWluSWQsIG5vbmNlLCB0aXAsIHBheW1hc3RlckRhdGEsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLCByZXNvdXJjZUJvdW5kcywgYWRkaXRpb25hbERhdGEgPSBbXSkge1xuICBjb25zdCBmZWVGaWVsZEhhc2ggPSBoYXNoRmVlRmllbGQodGlwLCByZXNvdXJjZUJvdW5kcyk7XG4gIGNvbnN0IGRBTW9kZUhhc2ggPSBoYXNoREFNb2RlKG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKTtcbiAgY29uc3QgZGF0YVRvSGFzaCA9IEFUb0JJKFtcbiAgICB0eEhhc2hQcmVmaXgsXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIGZlZUZpZWxkSGFzaCxcbiAgICBwb3NlaWRvbkhhc2hNYW55KEFUb0JJKHBheW1hc3RlckRhdGEpKSxcbiAgICBjaGFpbklkLFxuICAgIG5vbmNlLFxuICAgIGRBTW9kZUhhc2gsXG4gICAgLi4uQVRvQkkoYWRkaXRpb25hbERhdGEpXG4gIF0pO1xuICByZXR1cm4gdG9IZXgocG9zZWlkb25IYXNoTWFueShkYXRhVG9IYXNoKSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLCBzYWx0LCB2ZXJzaW9uLCBjaGFpbklkLCBub25jZSwgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSwgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIHJlc291cmNlQm91bmRzLCB0aXAsIHBheW1hc3RlckRhdGEpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjIoXG4gICAgXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBjaGFpbklkLFxuICAgIG5vbmNlLFxuICAgIHRpcCxcbiAgICBwYXltYXN0ZXJEYXRhLFxuICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgcmVzb3VyY2VCb3VuZHMsXG4gICAgW3Bvc2VpZG9uSGFzaE1hbnkoQVRvQkkoY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhKSksIGNsYXNzSGFzaCwgc2FsdF1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gyKGNsYXNzSGFzaCwgY29tcGlsZWRDbGFzc0hhc2gsIHNlbmRlckFkZHJlc3MsIHZlcnNpb24sIGNoYWluSWQsIG5vbmNlLCBhY2NvdW50RGVwbG95bWVudERhdGEsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLCByZXNvdXJjZUJvdW5kcywgdGlwLCBwYXltYXN0ZXJEYXRhKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yKFxuICAgIFwiMHg2NDY1NjM2YzYxNzI2NVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIGNoYWluSWQsXG4gICAgbm9uY2UsXG4gICAgdGlwLFxuICAgIEFUb0JJKHBheW1hc3RlckRhdGEpLFxuICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgcmVzb3VyY2VCb3VuZHMsXG4gICAgW3Bvc2VpZG9uSGFzaE1hbnkoQVRvQkkoYWNjb3VudERlcGxveW1lbnREYXRhKSksIGNsYXNzSGFzaCwgY29tcGlsZWRDbGFzc0hhc2hdXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2goc2VuZGVyQWRkcmVzcywgdmVyc2lvbiwgY29tcGlsZWRDYWxsZGF0YSwgY2hhaW5JZCwgbm9uY2UsIGFjY291bnREZXBsb3ltZW50RGF0YSwgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSwgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIHJlc291cmNlQm91bmRzLCB0aXAsIHBheW1hc3RlckRhdGEpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjIoXG4gICAgXCIweDY5NmU3NjZmNmI2NVwiIC8qIElOVk9LRSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIHNlbmRlckFkZHJlc3MsXG4gICAgY2hhaW5JZCxcbiAgICBub25jZSxcbiAgICB0aXAsXG4gICAgcGF5bWFzdGVyRGF0YSxcbiAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIHJlc291cmNlQm91bmRzLFxuICAgIFtwb3NlaWRvbkhhc2hNYW55KEFUb0JJKGFjY291bnREZXBsb3ltZW50RGF0YSkpLCBwb3NlaWRvbkhhc2hNYW55KEFUb0JJKGNvbXBpbGVkQ2FsbGRhdGEpKV1cbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhc2gvdHJhbnNhY3Rpb25IYXNoL2luZGV4LnRzXG5mdW5jdGlvbiBpc1YzSW52b2tlVHgoYXJncykge1xuICByZXR1cm4gW1wiMHgzXCIgLyogVjMgKi8sIFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIiAvKiBGMyAqL10uaW5jbHVkZXMoXG4gICAgYXJncy52ZXJzaW9uXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyKGFyZ3MpIHtcbiAgaWYgKGlzVjNJbnZva2VUeChhcmdzKSkge1xuICAgIHJldHVybiBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2goXG4gICAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgICBhcmdzLnZlcnNpb24sXG4gICAgICBhcmdzLmNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICBhcmdzLmNoYWluSWQsXG4gICAgICBhcmdzLm5vbmNlLFxuICAgICAgYXJncy5hY2NvdW50RGVwbG95bWVudERhdGEsXG4gICAgICBhcmdzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIGFyZ3MudGlwLFxuICAgICAgYXJncy5wYXltYXN0ZXJEYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoKFxuICAgIGFyZ3Muc2VuZGVyQWRkcmVzcyxcbiAgICBhcmdzLnZlcnNpb24sXG4gICAgYXJncy5jb21waWxlZENhbGxkYXRhLFxuICAgIGFyZ3MubWF4RmVlLFxuICAgIGFyZ3MuY2hhaW5JZCxcbiAgICBhcmdzLm5vbmNlXG4gICk7XG59XG5mdW5jdGlvbiBpc1YzRGVjbGFyZVR4KGFyZ3MpIHtcbiAgcmV0dXJuIFtcIjB4M1wiIC8qIFYzICovLCBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzXCIgLyogRjMgKi9dLmluY2x1ZGVzKFxuICAgIGFyZ3MudmVyc2lvblxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoYXJncykge1xuICBpZiAoaXNWM0RlY2xhcmVUeChhcmdzKSkge1xuICAgIHJldHVybiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMihcbiAgICAgIGFyZ3MuY2xhc3NIYXNoLFxuICAgICAgYXJncy5jb21waWxlZENsYXNzSGFzaCxcbiAgICAgIGFyZ3Muc2VuZGVyQWRkcmVzcyxcbiAgICAgIGFyZ3MudmVyc2lvbixcbiAgICAgIGFyZ3MuY2hhaW5JZCxcbiAgICAgIGFyZ3Mubm9uY2UsXG4gICAgICBhcmdzLmFjY291bnREZXBsb3ltZW50RGF0YSxcbiAgICAgIGFyZ3Mubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgIGFyZ3MuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLnJlc291cmNlQm91bmRzLFxuICAgICAgYXJncy50aXAsXG4gICAgICBhcmdzLnBheW1hc3RlckRhdGFcbiAgICApO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoKFxuICAgIGFyZ3MuY2xhc3NIYXNoLFxuICAgIGFyZ3Muc2VuZGVyQWRkcmVzcyxcbiAgICBhcmdzLnZlcnNpb24sXG4gICAgYXJncy5tYXhGZWUsXG4gICAgYXJncy5jaGFpbklkLFxuICAgIGFyZ3Mubm9uY2UsXG4gICAgYXJncy5jb21waWxlZENsYXNzSGFzaFxuICApO1xufVxuZnVuY3Rpb24gaXNWM0RlcGxveUFjY291bnRUeChhcmdzKSB7XG4gIHJldHVybiBbXCIweDNcIiAvKiBWMyAqLywgXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM1wiIC8qIEYzICovXS5pbmNsdWRlcyhcbiAgICBhcmdzLnZlcnNpb25cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzKGFyZ3MpIHtcbiAgaWYgKGlzVjNEZXBsb3lBY2NvdW50VHgoYXJncykpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDIoXG4gICAgICBhcmdzLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGFyZ3MuY2xhc3NIYXNoLFxuICAgICAgYXJncy5jb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICBhcmdzLnNhbHQsXG4gICAgICBhcmdzLnZlcnNpb24sXG4gICAgICBhcmdzLmNoYWluSWQsXG4gICAgICBhcmdzLm5vbmNlLFxuICAgICAgYXJncy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgIGFyZ3MucmVzb3VyY2VCb3VuZHMsXG4gICAgICBhcmdzLnRpcCxcbiAgICAgIGFyZ3MucGF5bWFzdGVyRGF0YVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2goXG4gICAgYXJncy5jb250cmFjdEFkZHJlc3MsXG4gICAgYXJncy5jbGFzc0hhc2gsXG4gICAgYXJncy5jb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgIGFyZ3Muc2FsdCxcbiAgICBhcmdzLnZlcnNpb24sXG4gICAgYXJncy5tYXhGZWUsXG4gICAgYXJncy5jaGFpbklkLFxuICAgIGFyZ3Mubm9uY2VcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhc2gvY2xhc3NIYXNoLnRzXG5pbXBvcnQgeyBwb3NlaWRvbkhhc2hNYW55IGFzIHBvc2VpZG9uSGFzaE1hbnkyIH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuXG4vLyBzcmMvdXRpbHMvanNvbi50c1xudmFyIGpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoanNvbl9leHBvcnRzLCB7XG4gIHBhcnNlOiAoKSA9PiBwYXJzZTIsXG4gIHBhcnNlQWx3YXlzQXNCaWc6ICgpID0+IHBhcnNlQWx3YXlzQXNCaWcsXG4gIHN0cmluZ2lmeTogKCkgPT4gc3RyaW5naWZ5MixcbiAgc3RyaW5naWZ5QWx3YXlzQXNCaWc6ICgpID0+IHN0cmluZ2lmeUFsd2F5c0FzQmlnXG59KTtcbmltcG9ydCAqIGFzIGpzb24gZnJvbSBcImxvc3NsZXNzLWpzb25cIjtcbnZhciBwYXJzZUludEFzTnVtYmVyT3JCaWdJbnQgPSAoeCkgPT4ge1xuICBpZiAoIWpzb24uaXNJbnRlZ2VyKHgpKVxuICAgIHJldHVybiBwYXJzZUZsb2F0KHgpO1xuICBjb25zdCB2ID0gcGFyc2VJbnQoeCwgMTApO1xuICByZXR1cm4gTnVtYmVyLmlzU2FmZUludGVnZXIodikgPyB2IDogQmlnSW50KHgpO1xufTtcbnZhciBwYXJzZTIgPSAoeCkgPT4ganNvbi5wYXJzZShTdHJpbmcoeCksIHZvaWQgMCwgcGFyc2VJbnRBc051bWJlck9yQmlnSW50KTtcbnZhciBwYXJzZUFsd2F5c0FzQmlnID0gKHgpID0+IGpzb24ucGFyc2UoU3RyaW5nKHgpLCB2b2lkIDAsIGpzb24ucGFyc2VOdW1iZXJBbmRCaWdJbnQpO1xudmFyIHN0cmluZ2lmeTIgPSAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKSA9PiBqc29uLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBudW1iZXJTdHJpbmdpZmllcnMpO1xudmFyIHN0cmluZ2lmeUFsd2F5c0FzQmlnID0gc3RyaW5naWZ5MjtcblxuLy8gc3JjL3V0aWxzL2hhc2gvY2xhc3NIYXNoLnRzXG5mdW5jdGlvbiBjb21wdXRlUGVkZXJzZW5IYXNoKGEsIGIpIHtcbiAgcmV0dXJuIHN0YXJrQ3VydmUucGVkZXJzZW4oQmlnSW50KGEpLCBCaWdJbnQoYikpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVBvc2VpZG9uSGFzaChhLCBiKSB7XG4gIHJldHVybiB0b0hleChzdGFya0N1cnZlLnBvc2VpZG9uSGFzaChCaWdJbnQoYSksIEJpZ0ludChiKSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihkYXRhKSB7XG4gIHJldHVybiBbLi4uZGF0YSwgZGF0YS5sZW5ndGhdLnJlZHVjZSgoeCwgeSkgPT4gc3RhcmtDdXJ2ZS5wZWRlcnNlbihCaWdJbnQoeCksIEJpZ0ludCh5KSksIDApLnRvU3RyaW5nKCk7XG59XG52YXIgY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHMgPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyO1xuZnVuY3Rpb24gY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMoZGF0YSkge1xuICByZXR1cm4gdG9IZXgocG9zZWlkb25IYXNoTWFueTIoZGF0YS5tYXAoKHgpID0+IEJpZ0ludCh4KSkpKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKHNhbHQsIGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgZGVwbG95ZXJBZGRyZXNzKSB7XG4gIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICBjb25zdCBjb25zdHJ1Y3RvckNhbGxkYXRhSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoY29tcGlsZWRDYWxsZGF0YSk7XG4gIGNvbnN0IENPTlRSQUNUX0FERFJFU1NfUFJFRklYID0gZmVsdChcIjB4NTM1NDQxNTI0YjRlNDU1NDVmNDM0ZjRlNTQ1MjQxNDM1NDVmNDE0NDQ0NTI0NTUzNTNcIik7XG4gIGNvbnN0IGhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKFtcbiAgICBDT05UUkFDVF9BRERSRVNTX1BSRUZJWCxcbiAgICBkZXBsb3llckFkZHJlc3MsXG4gICAgc2FsdCxcbiAgICBjbGFzc0hhc2gsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YUhhc2hcbiAgXSk7XG4gIHJldHVybiB0b0hleChCaWdJbnQoaGFzaCkgJSBBRERSX0JPVU5EKTtcbn1cbmZ1bmN0aW9uIG51bGxTa2lwUmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09PSBcImF0dHJpYnV0ZXNcIiB8fCBrZXkgPT09IFwiYWNjZXNzaWJsZV9zY29wZXNcIikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiB2YWx1ZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImRlYnVnX2luZm9cIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZm9ybWF0U3BhY2VzKGpzb24yKSB7XG4gIGxldCBpbnNpZGVRdW90ZXMgPSBmYWxzZTtcbiAgY29uc3QgbmV3U3RyaW5nID0gW107XG4gIGZvciAoY29uc3QgY2hhciBvZiBqc29uMikge1xuICAgIGlmIChjaGFyID09PSAnXCInICYmIChuZXdTdHJpbmcubGVuZ3RoID4gMCAmJiBuZXdTdHJpbmcuc2xpY2UoLTEpWzBdID09PSBcIlxcXFxcIikgPT09IGZhbHNlKSB7XG4gICAgICBpbnNpZGVRdW90ZXMgPSAhaW5zaWRlUXVvdGVzO1xuICAgIH1cbiAgICBpZiAoaW5zaWRlUXVvdGVzKSB7XG4gICAgICBuZXdTdHJpbmcucHVzaChjaGFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RyaW5nLnB1c2goY2hhciA9PT0gXCI6XCIgPyBcIjogXCIgOiBjaGFyID09PSBcIixcIiA/IFwiLCBcIiA6IGNoYXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3U3RyaW5nLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBjb21wdXRlSGludGVkQ2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpIHtcbiAgY29uc3QgeyBhYmksIHByb2dyYW0gfSA9IGNvbXBpbGVkQ29udHJhY3Q7XG4gIGNvbnN0IGNvbnRyYWN0Q2xhc3MgPSB7IGFiaSwgcHJvZ3JhbSB9O1xuICBjb25zdCBzZXJpYWxpemVkSnNvbiA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKGNvbnRyYWN0Q2xhc3MsIG51bGxTa2lwUmVwbGFjZXIpKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShzZXJpYWxpemVkSnNvbikpLnRvU3RyaW5nKDE2KSk7XG59XG5mdW5jdGlvbiBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2goY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IHR5cGVvZiBjb250cmFjdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgY29uc3QgYXBpVmVyc2lvbiA9IHRvSGV4KEFQSV9WRVJTSU9OKTtcbiAgY29uc3QgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuRVhURVJOQUwuZmxhdE1hcCgoZSkgPT4gW2Uuc2VsZWN0b3IsIGUub2Zmc2V0XSlcbiAgKTtcbiAgY29uc3QgbDFIYW5kbGVyRW50cnlQb2ludHNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihcbiAgICBjb21waWxlZENvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLkwxX0hBTkRMRVIuZmxhdE1hcCgoZSkgPT4gW2Uuc2VsZWN0b3IsIGUub2Zmc2V0XSlcbiAgKTtcbiAgY29uc3QgY29uc3RydWN0b3JFbnRyeVBvaW50SGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5DT05TVFJVQ1RPUi5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBidWlsdGluc0hhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKFxuICAgIGNvbXBpbGVkQ29udHJhY3QucHJvZ3JhbS5idWlsdGlucy5tYXAoKHMpID0+IGVuY29kZVNob3J0U3RyaW5nKHMpKVxuICApO1xuICBjb25zdCBoaW50ZWRDbGFzc0hhc2ggPSBjb21wdXRlSGludGVkQ2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpO1xuICBjb25zdCBkYXRhSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoY29tcGlsZWRDb250cmFjdC5wcm9ncmFtLmRhdGEpO1xuICByZXR1cm4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihbXG4gICAgYXBpVmVyc2lvbixcbiAgICBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCxcbiAgICBsMUhhbmRsZXJFbnRyeVBvaW50c0hhc2gsXG4gICAgY29uc3RydWN0b3JFbnRyeVBvaW50SGFzaCxcbiAgICBidWlsdGluc0hhc2gsXG4gICAgaGludGVkQ2xhc3NIYXNoLFxuICAgIGRhdGFIYXNoXG4gIF0pO1xufVxuZnVuY3Rpb24gaGFzaEJ1aWx0aW5zKGJ1aWx0aW5zKSB7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55MihcbiAgICBidWlsdGlucy5mbGF0TWFwKChpdCkgPT4ge1xuICAgICAgcmV0dXJuIEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhpdCkpO1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBoYXNoRW50cnlQb2ludChkYXRhKSB7XG4gIGNvbnN0IGJhc2UgPSBkYXRhLmZsYXRNYXAoKGl0KSA9PiB7XG4gICAgcmV0dXJuIFtCaWdJbnQoaXQuc2VsZWN0b3IpLCBCaWdJbnQoaXQub2Zmc2V0KSwgaGFzaEJ1aWx0aW5zKGl0LmJ1aWx0aW5zKV07XG4gIH0pO1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueTIoYmFzZSk7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2goY2FzbSkge1xuICBjb25zdCBDT01QSUxFRF9DTEFTU19WRVJTSU9OID0gXCJDT01QSUxFRF9DTEFTU19WMVwiO1xuICBjb25zdCBjb21waWxlZENsYXNzVmVyc2lvbiA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhDT01QSUxFRF9DTEFTU19WRVJTSU9OKSk7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTCk7XG4gIGNvbnN0IGwxSGFuZGxlcnMgPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkwxX0hBTkRMRVIpO1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IpO1xuICBjb25zdCBieXRlY29kZSA9IHBvc2VpZG9uSGFzaE1hbnkyKGNhc20uYnl0ZWNvZGUubWFwKChpdCkgPT4gQmlnSW50KGl0KSkpO1xuICByZXR1cm4gdG9IZXgoXG4gICAgcG9zZWlkb25IYXNoTWFueTIoW1xuICAgICAgY29tcGlsZWRDbGFzc1ZlcnNpb24sXG4gICAgICBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCxcbiAgICAgIGwxSGFuZGxlcnMsXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGJ5dGVjb2RlXG4gICAgXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc2hFbnRyeVBvaW50U2llcnJhKGRhdGEpIHtcbiAgY29uc3QgYmFzZSA9IGRhdGEuZmxhdE1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gW0JpZ0ludChpdC5zZWxlY3RvciksIEJpZ0ludChpdC5mdW5jdGlvbl9pZHgpXTtcbiAgfSk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55MihiYXNlKTtcbn1cbmZ1bmN0aW9uIGhhc2hBYmkoc2llcnJhKSB7XG4gIGNvbnN0IGluZGVudFN0cmluZyA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKHNpZXJyYS5hYmksIG51bGwpKTtcbiAgcmV0dXJuIEJpZ0ludChhZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoaW5kZW50U3RyaW5nKSkudG9TdHJpbmcoMTYpKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2goc2llcnJhKSB7XG4gIGNvbnN0IENPTlRSQUNUX0NMQVNTX1ZFUlNJT04gPSBcIkNPTlRSQUNUX0NMQVNTX1YwLjEuMFwiO1xuICBjb25zdCBjb21waWxlZENsYXNzVmVyc2lvbiA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhDT05UUkFDVF9DTEFTU19WRVJTSU9OKSk7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMKTtcbiAgY29uc3QgbDFIYW5kbGVycyA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSKTtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IpO1xuICBjb25zdCBhYmlIYXNoID0gaGFzaEFiaShzaWVycmEpO1xuICBjb25zdCBzaWVycmFQcm9ncmFtID0gcG9zZWlkb25IYXNoTWFueTIoc2llcnJhLnNpZXJyYV9wcm9ncmFtLm1hcCgoaXQpID0+IEJpZ0ludChpdCkpKTtcbiAgcmV0dXJuIHRvSGV4KFxuICAgIHBvc2VpZG9uSGFzaE1hbnkyKFtcbiAgICAgIGNvbXBpbGVkQ2xhc3NWZXJzaW9uLFxuICAgICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgICBsMUhhbmRsZXJzLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBhYmlIYXNoLFxuICAgICAgc2llcnJhUHJvZ3JhbVxuICAgIF0pXG4gICk7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2goY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IHR5cGVvZiBjb250cmFjdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgaWYgKFwic2llcnJhX3Byb2dyYW1cIiBpbiBjb21waWxlZENvbnRyYWN0KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpO1xufVxuXG4vLyBzcmMvdXRpbHMvc3RhcmsudHNcbnZhciBzdGFya19leHBvcnRzID0ge307XG5fX2V4cG9ydChzdGFya19leHBvcnRzLCB7XG4gIGNvbXByZXNzUHJvZ3JhbTogKCkgPT4gY29tcHJlc3NQcm9ncmFtLFxuICBkZWNvbXByZXNzUHJvZ3JhbTogKCkgPT4gZGVjb21wcmVzc1Byb2dyYW0sXG4gIGVzdGltYXRlRmVlVG9Cb3VuZHM6ICgpID0+IGVzdGltYXRlRmVlVG9Cb3VuZHMsXG4gIGVzdGltYXRlZEZlZVRvTWF4RmVlOiAoKSA9PiBlc3RpbWF0ZWRGZWVUb01heEZlZSxcbiAgZm9ybWF0U2lnbmF0dXJlOiAoKSA9PiBmb3JtYXRTaWduYXR1cmUsXG4gIGludERBTTogKCkgPT4gaW50REFNLFxuICBtYWtlQWRkcmVzczogKCkgPT4gbWFrZUFkZHJlc3MsXG4gIHJhbmRvbUFkZHJlc3M6ICgpID0+IHJhbmRvbUFkZHJlc3MsXG4gIHJlZHVjZVYyOiAoKSA9PiByZWR1Y2VWMixcbiAgc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXk6ICgpID0+IHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5LFxuICBzaWduYXR1cmVUb0hleEFycmF5OiAoKSA9PiBzaWduYXR1cmVUb0hleEFycmF5LFxuICB0b0ZlZVZlcnNpb246ICgpID0+IHRvRmVlVmVyc2lvbixcbiAgdG9UcmFuc2FjdGlvblZlcnNpb246ICgpID0+IHRvVHJhbnNhY3Rpb25WZXJzaW9uLFxuICB2M0RldGFpbHM6ICgpID0+IHYzRGV0YWlsc1xufSk7XG5pbXBvcnQgeyBnZXRTdGFya0tleSwgdXRpbHMgfSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5pbXBvcnQgeyBnemlwLCB1bmd6aXAgfSBmcm9tIFwicGFrb1wiO1xuZnVuY3Rpb24gY29tcHJlc3NQcm9ncmFtKGpzb25Qcm9ncmFtKSB7XG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gdHlwZW9mIGpzb25Qcm9ncmFtID09PSBcInN0cmluZ1wiID8ganNvblByb2dyYW0gOiBzdHJpbmdpZnkyKGpzb25Qcm9ncmFtKTtcbiAgY29uc3QgY29tcHJlc3NlZFByb2dyYW0gPSBnemlwKHN0cmluZ2lmaWVkKTtcbiAgcmV0dXJuIGJ0b2FVbml2ZXJzYWwoY29tcHJlc3NlZFByb2dyYW0pO1xufVxuZnVuY3Rpb24gZGVjb21wcmVzc1Byb2dyYW0oYmFzZTY0Mikge1xuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlNjQyKSlcbiAgICByZXR1cm4gYmFzZTY0MjtcbiAgY29uc3QgZGVjb21wcmVzc2VkID0gYXJyYXlCdWZmZXJUb1N0cmluZyh1bmd6aXAoYXRvYlVuaXZlcnNhbChiYXNlNjQyKSkpO1xuICByZXR1cm4gcGFyc2UyKGRlY29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiByYW5kb21BZGRyZXNzKCkge1xuICBjb25zdCByYW5kb21LZXlQYWlyID0gdXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICByZXR1cm4gZ2V0U3RhcmtLZXkocmFuZG9tS2V5UGFpcik7XG59XG5mdW5jdGlvbiBtYWtlQWRkcmVzcyhpbnB1dCkge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGlucHV0KS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZm9ybWF0U2lnbmF0dXJlKHNpZykge1xuICBpZiAoIXNpZylcbiAgICB0aHJvdyBFcnJvcihcImZvcm1hdFNpZ25hdHVyZTogcHJvdmlkZWQgc2lnbmF0dXJlIGlzIHVuZGVmaW5lZFwiKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHJldHVybiBzaWcubWFwKChpdCkgPT4gdG9IZXgoaXQpKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgIHJldHVybiBbdG9IZXgociksIHRvSGV4KHMpXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25hdHVyZSBuZWVkIHRvIGJlIHdlaWVyc3RyYXNzLlNpZ25hdHVyZVR5cGUgb3IgYW4gYXJyYXkgZm9yIGN1c3RvbVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoc2lnKSB7XG4gIHJldHVybiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5KGZvcm1hdFNpZ25hdHVyZShzaWcpKTtcbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnKSB7XG4gIHJldHVybiBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheShmb3JtYXRTaWduYXR1cmUoc2lnKSk7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZWRGZWVUb01heEZlZShlc3RpbWF0ZWRGZWUsIG92ZXJoZWFkID0gMC41KSB7XG4gIHJldHVybiBhZGRQZXJjZW50KGVzdGltYXRlZEZlZSwgb3ZlcmhlYWQgKiAxMDApO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVGZWVUb0JvdW5kcyhlc3RpbWF0ZSwgYW1vdW50T3ZlcmhlYWQgPSAxMCwgcHJpY2VPdmVyaGVhZCA9IDUwKSB7XG4gIGlmICh0eXBlb2YgZXN0aW1hdGUgPT09IFwiYmlnaW50XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbDJfZ2FzOiB7IG1heF9hbW91bnQ6IFwiMHgwXCIsIG1heF9wcmljZV9wZXJfdW5pdDogXCIweDBcIiB9LFxuICAgICAgbDFfZ2FzOiB7IG1heF9hbW91bnQ6IFwiMHgwXCIsIG1heF9wcmljZV9wZXJfdW5pdDogXCIweDBcIiB9XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGVzdGltYXRlLmdhc19jb25zdW1lZCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZXN0aW1hdGUuZ2FzX3ByaWNlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJlc3RpbWF0ZUZlZVRvQm91bmRzOiBlc3RpbWF0ZSBpcyB1bmRlZmluZWRcIik7XG4gIH1cbiAgY29uc3QgbWF4VW5pdHMgPSB0b0hleChhZGRQZXJjZW50KGVzdGltYXRlLmdhc19jb25zdW1lZCwgYW1vdW50T3ZlcmhlYWQpKTtcbiAgY29uc3QgbWF4VW5pdFByaWNlID0gdG9IZXgoYWRkUGVyY2VudChlc3RpbWF0ZS5nYXNfcHJpY2UsIHByaWNlT3ZlcmhlYWQpKTtcbiAgcmV0dXJuIHtcbiAgICBsMl9nYXM6IHsgbWF4X2Ftb3VudDogXCIweDBcIiwgbWF4X3ByaWNlX3Blcl91bml0OiBcIjB4MFwiIH0sXG4gICAgbDFfZ2FzOiB7IG1heF9hbW91bnQ6IG1heFVuaXRzLCBtYXhfcHJpY2VfcGVyX3VuaXQ6IG1heFVuaXRQcmljZSB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnREQU0oZGFtKSB7XG4gIGlmIChkYW0gPT09IFwiTDFcIiAvKiBMMSAqLylcbiAgICByZXR1cm4gMCAvKiBMMSAqLztcbiAgaWYgKGRhbSA9PT0gXCJMMlwiIC8qIEwyICovKVxuICAgIHJldHVybiAxIC8qIEwyICovO1xuICB0aHJvdyBFcnJvcihcIkVEQU0gY29udmVyc2lvblwiKTtcbn1cbmZ1bmN0aW9uIHRvVHJhbnNhY3Rpb25WZXJzaW9uKGRlZmF1bHRWZXJzaW9uLCBwcm92aWRlZFZlcnNpb24pIHtcbiAgY29uc3QgcHJvdmlkZWRWZXJzaW9uMHhzID0gcHJvdmlkZWRWZXJzaW9uID8gdG9IZXgocHJvdmlkZWRWZXJzaW9uKSA6IHZvaWQgMDtcbiAgY29uc3QgZGVmYXVsdFZlcnNpb24weHMgPSB0b0hleChkZWZhdWx0VmVyc2lvbik7XG4gIGlmIChwcm92aWRlZFZlcnNpb24gJiYgIU9iamVjdC52YWx1ZXMoRVRyYW5zYWN0aW9uVmVyc2lvbikuaW5jbHVkZXMocHJvdmlkZWRWZXJzaW9uMHhzKSkge1xuICAgIHRocm93IEVycm9yKGBwcm92aWRlZFZlcnNpb24gJHtwcm92aWRlZFZlcnNpb259IGlzIG5vdCBFVHJhbnNhY3Rpb25WZXJzaW9uYCk7XG4gIH1cbiAgaWYgKCFPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24pLmluY2x1ZGVzKGRlZmF1bHRWZXJzaW9uMHhzKSkge1xuICAgIHRocm93IEVycm9yKGBkZWZhdWx0VmVyc2lvbiAke2RlZmF1bHRWZXJzaW9ufSBpcyBub3QgRVRyYW5zYWN0aW9uVmVyc2lvbmApO1xuICB9XG4gIHJldHVybiBwcm92aWRlZFZlcnNpb24gPyBwcm92aWRlZFZlcnNpb24weHMgOiBkZWZhdWx0VmVyc2lvbjB4cztcbn1cbmZ1bmN0aW9uIHRvRmVlVmVyc2lvbihwcm92aWRlZFZlcnNpb24pIHtcbiAgaWYgKCFwcm92aWRlZFZlcnNpb24pXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgdmVyc2lvbiA9IHRvSGV4KHByb3ZpZGVkVmVyc2lvbik7XG4gIGlmICh2ZXJzaW9uID09PSBcIjB4MFwiIC8qIFYwICovKVxuICAgIHJldHVybiBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIgLyogRjAgKi87XG4gIGlmICh2ZXJzaW9uID09PSBcIjB4MVwiIC8qIFYxICovKVxuICAgIHJldHVybiBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCIgLyogRjEgKi87XG4gIGlmICh2ZXJzaW9uID09PSBcIjB4MlwiIC8qIFYyICovKVxuICAgIHJldHVybiBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyXCIgLyogRjIgKi87XG4gIGlmICh2ZXJzaW9uID09PSBcIjB4M1wiIC8qIFYzICovKVxuICAgIHJldHVybiBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzXCIgLyogRjMgKi87XG4gIHRocm93IEVycm9yKGB0b0ZlZVZlcnNpb246ICR7dmVyc2lvbn0gaXMgbm90IHN1cHBvcnRlZGApO1xufVxuZnVuY3Rpb24gdjNEZXRhaWxzKGRldGFpbHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0aXA6IGRldGFpbHMudGlwIHx8IDAsXG4gICAgcGF5bWFzdGVyRGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhIHx8IFtdLFxuICAgIGFjY291bnREZXBsb3ltZW50RGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEgfHwgW10sXG4gICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlIHx8IFwiTDFcIiAvKiBMMSAqLyxcbiAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogZGV0YWlscy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSB8fCBcIkwxXCIgLyogTDEgKi8sXG4gICAgcmVzb3VyY2VCb3VuZHM6IGRldGFpbHMucmVzb3VyY2VCb3VuZHMgPz8gZXN0aW1hdGVGZWVUb0JvdW5kcyhaRVJPKVxuICB9O1xufVxuZnVuY3Rpb24gcmVkdWNlVjIocHJvdmlkZWRWZXJzaW9uKSB7XG4gIGlmIChwcm92aWRlZFZlcnNpb24gPT09IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJcIiAvKiBGMiAqLylcbiAgICByZXR1cm4gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiIC8qIEYxICovO1xuICBpZiAocHJvdmlkZWRWZXJzaW9uID09PSBcIjB4MlwiIC8qIFYyICovKVxuICAgIHJldHVybiBcIjB4MVwiIC8qIFYxICovO1xuICByZXR1cm4gcHJvdmlkZWRWZXJzaW9uO1xufVxuXG4vLyBzcmMvdXRpbHMvY29udHJhY3QudHNcbmZ1bmN0aW9uIGlzU2llcnJhKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSB0eXBlb2YgY29udHJhY3QgPT09IFwic3RyaW5nXCIgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIHJldHVybiBcInNpZXJyYV9wcm9ncmFtXCIgaW4gY29tcGlsZWRDb250cmFjdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0geyAuLi5wYXlsb2FkIH07XG4gIGlmIChpc1NpZXJyYShwYXlsb2FkLmNvbnRyYWN0KSkge1xuICAgIGlmICghcGF5bG9hZC5jb21waWxlZENsYXNzSGFzaCAmJiBwYXlsb2FkLmNhc20pIHtcbiAgICAgIHJlc3BvbnNlLmNvbXBpbGVkQ2xhc3NIYXNoID0gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoKHBheWxvYWQuY2FzbSk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuY29tcGlsZWRDbGFzc0hhc2gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXh0cmFjdCBjb21waWxlZENsYXNzSGFzaCBmYWlsZWQsIHByb3ZpZGUgKENhaXJvQXNzZW1ibHkpLmNhc20gZmlsZSBvciBjb21waWxlZENsYXNzSGFzaFwiXG4gICAgICApO1xuICB9XG4gIHJlc3BvbnNlLmNsYXNzSGFzaCA9IHBheWxvYWQuY2xhc3NIYXNoID8/IGNvbXB1dGVDb250cmFjdENsYXNzSGFzaChwYXlsb2FkLmNvbnRyYWN0KTtcbiAgaWYgKCFyZXNwb25zZS5jbGFzc0hhc2gpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0cmFjdCBjbGFzc0hhc2ggZmFpbGVkLCBwcm92aWRlIChDb21waWxlZENvbnRyYWN0KS5qc29uIGZpbGUgb3IgY2xhc3NIYXNoXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBjb250cmFjdENsYXNzUmVzcG9uc2VUb0xlZ2FjeUNvbXBpbGVkQ29udHJhY3QoY2NyKSB7XG4gIGlmIChpc1NpZXJyYShjY3IpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDb250cmFjdENsYXNzUmVzcG9uc2UgbmVlZCB0byBiZSBMZWdhY3lDb250cmFjdENsYXNzIChjYWlybzAgcmVzcG9uc2UgY2xhc3MpXCIpO1xuICB9XG4gIGNvbnN0IGNvbnRyYWN0ID0gY2NyO1xuICByZXR1cm4geyAuLi5jb250cmFjdCwgcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3QucHJvZ3JhbSkgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2ZldGNoUG9ueWZpbGwudHNcbmltcG9ydCBpc29tb3JwaGljRmV0Y2ggZnJvbSBcImlzb21vcnBoaWMtZmV0Y2hcIjtcbnZhciBmZXRjaFBvbnlmaWxsX2RlZmF1bHQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5mZXRjaCB8fCAvLyB1c2UgYnVpbGRpbiBmZXRjaCBpbiBicm93c2VyIGlmIGF2YWlsYWJsZVxudHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuZmV0Y2ggfHwgLy8gdXNlIGJ1aWxkaW4gZmV0Y2ggaW4gbm9kZSwgcmVhY3QtbmF0aXZlIGFuZCBzZXJ2aWNlIHdvcmtlciBpZiBhdmFpbGFibGVcbmlzb21vcnBoaWNGZXRjaDtcblxuLy8gc3JjL3V0aWxzL3Byb3ZpZGVyLnRzXG52YXIgcHJvdmlkZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocHJvdmlkZXJfZXhwb3J0cywge1xuICBCbG9jazogKCkgPT4gQmxvY2ssXG4gIGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3M6ICgpID0+IGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MsXG4gIGZvcm1hdEhhc2g6ICgpID0+IGZvcm1hdEhhc2gsXG4gIGdldERlZmF1bHROb2RlVXJsOiAoKSA9PiBnZXREZWZhdWx0Tm9kZVVybCxcbiAgaXNQZW5kaW5nQmxvY2s6ICgpID0+IGlzUGVuZGluZ0Jsb2NrLFxuICBpc1BlbmRpbmdTdGF0ZVVwZGF0ZTogKCkgPT4gaXNQZW5kaW5nU3RhdGVVcGRhdGUsXG4gIGlzUGVuZGluZ1RyYW5zYWN0aW9uOiAoKSA9PiBpc1BlbmRpbmdUcmFuc2FjdGlvbixcbiAgaXNWM1R4OiAoKSA9PiBpc1YzVHgsXG4gIGlzVmVyc2lvbjogKCkgPT4gaXNWZXJzaW9uLFxuICBwYXJzZUNvbnRyYWN0OiAoKSA9PiBwYXJzZUNvbnRyYWN0LFxuICB0eElkZW50aWZpZXI6ICgpID0+IHR4SWRlbnRpZmllcixcbiAgdmFsaWRCbG9ja1RhZ3M6ICgpID0+IHZhbGlkQmxvY2tUYWdzLFxuICB3YWl0OiAoKSA9PiB3YWl0XG59KTtcbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlcywgZGVsYXkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MoY29udHJhY3QpIHtcbiAgY29uc3QgcmVzdWx0ID0geyAuLi5jb250cmFjdCB9O1xuICBkZWxldGUgcmVzdWx0LnNpZXJyYV9wcm9ncmFtX2RlYnVnX2luZm87XG4gIHJlc3VsdC5hYmkgPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdC5hYmkpKTtcbiAgcmVzdWx0LnNpZXJyYV9wcm9ncmFtID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3Quc2llcnJhX3Byb2dyYW0pKTtcbiAgcmVzdWx0LnNpZXJyYV9wcm9ncmFtID0gY29tcHJlc3NQcm9ncmFtKHJlc3VsdC5zaWVycmFfcHJvZ3JhbSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUNvbnRyYWN0KGNvbnRyYWN0KSB7XG4gIGNvbnN0IHBhcnNlZENvbnRyYWN0ID0gdHlwZW9mIGNvbnRyYWN0ID09PSBcInN0cmluZ1wiID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wYXJzZWRDb250cmFjdCxcbiAgICAgIC4uLlwicHJvZ3JhbVwiIGluIHBhcnNlZENvbnRyYWN0ICYmIHsgcHJvZ3JhbTogY29tcHJlc3NQcm9ncmFtKHBhcnNlZENvbnRyYWN0LnByb2dyYW0pIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzKHBhcnNlZENvbnRyYWN0KTtcbn1cbnZhciBnZXREZWZhdWx0Tm9kZVVybCA9IChuZXR3b3JrTmFtZSwgbXV0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmICghbXV0ZSlcbiAgICBjb25zb2xlLndhcm4oXCJVc2luZyBkZWZhdWx0IHB1YmxpYyBub2RlIHVybCwgcGxlYXNlIHByb3ZpZGUgbm9kZVVybCBpbiBwcm92aWRlciBvcHRpb25zIVwiKTtcbiAgY29uc3Qgbm9kZXMgPSBSUENfTk9ERVNbbmV0d29ya05hbWUgPz8gXCJTTl9HT0VSTElcIiAvKiBTTl9HT0VSTEkgKi9dO1xuICBjb25zdCByYW5kSWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKTtcbiAgcmV0dXJuIG5vZGVzW3JhbmRJZHhdO1xufTtcbmZ1bmN0aW9uIGZvcm1hdEhhc2goaGFzaFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaGFzaFZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBoYXNoVmFsdWU7XG4gIHJldHVybiB0b0hleChoYXNoVmFsdWUpO1xufVxuZnVuY3Rpb24gdHhJZGVudGlmaWVyKHR4SGFzaCwgdHhJZCkge1xuICBpZiAoIXR4SGFzaCkge1xuICAgIHJldHVybiBgdHJhbnNhY3Rpb25JZD0ke0pTT04uc3RyaW5naWZ5KHR4SWQpfWA7XG4gIH1cbiAgY29uc3QgaGFzaFN0cmluZyA9IGZvcm1hdEhhc2godHhIYXNoKTtcbiAgcmV0dXJuIGB0cmFuc2FjdGlvbkhhc2g9JHtoYXNoU3RyaW5nfWA7XG59XG52YXIgdmFsaWRCbG9ja1RhZ3MgPSBPYmplY3QudmFsdWVzKEJsb2NrVGFnKTtcbnZhciBCbG9jayA9IGNsYXNzIHtcbiAgaGFzaCA9IG51bGw7XG4gIG51bWJlciA9IG51bGw7XG4gIHRhZyA9IG51bGw7XG4gIHNldElkZW50aWZpZXIoX19pZGVudGlmaWVyKSB7XG4gICAgaWYgKHR5cGVvZiBfX2lkZW50aWZpZXIgPT09IFwic3RyaW5nXCIgJiYgaXNIZXgoX19pZGVudGlmaWVyKSkge1xuICAgICAgdGhpcy5oYXNoID0gX19pZGVudGlmaWVyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF9faWRlbnRpZmllciA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgdGhpcy5oYXNoID0gdG9IZXgoX19pZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfX2lkZW50aWZpZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMubnVtYmVyID0gX19pZGVudGlmaWVyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF9faWRlbnRpZmllciA9PT0gXCJzdHJpbmdcIiAmJiB2YWxpZEJsb2NrVGFncy5pbmNsdWRlcyhfX2lkZW50aWZpZXIpKSB7XG4gICAgICB0aGlzLnRhZyA9IF9faWRlbnRpZmllcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWcgPSBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihfaWRlbnRpZmllcikge1xuICAgIHRoaXMuc2V0SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gIH1cbiAgLy8gVE9ETzogZml4IGFueVxuICBnZXQgcXVlcnlJZGVudGlmaWVyKCkge1xuICAgIGlmICh0aGlzLm51bWJlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGBibG9ja051bWJlcj0ke3RoaXMubnVtYmVyfWA7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgYmxvY2tIYXNoPSR7dGhpcy5oYXNofWA7XG4gICAgfVxuICAgIHJldHVybiBgYmxvY2tOdW1iZXI9JHt0aGlzLnRhZ31gO1xuICB9XG4gIC8vIFRPRE86IGZpeCBhbnlcbiAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubnVtYmVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBibG9ja19udW1iZXI6IHRoaXMubnVtYmVyIH07XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGJsb2NrX2hhc2g6IHRoaXMuaGFzaCB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50YWc7XG4gIH1cbiAgc2V0IGlkZW50aWZpZXIoX2lkZW50aWZpZXIpIHtcbiAgICB0aGlzLnNldElkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICB9XG4gIHZhbHVlT2YgPSAoKSA9PiB0aGlzLm51bWJlcjtcbiAgdG9TdHJpbmcgPSAoKSA9PiB0aGlzLmhhc2g7XG4gIC8qICAgZ2V0IHNlcXVlbmNlcklkZW50aWZpZXIoKTogU2VxdWVuY2VySWRlbnRpZmllciB7XG4gICAgcmV0dXJuIHRoaXMuaGFzaCAhPT0gbnVsbFxuICAgICAgPyB7IGJsb2NrSGFzaDogdGhpcy5oYXNoIGFzIHN0cmluZyB9XG4gICAgICA6IHsgYmxvY2tOdW1iZXI6ICh0aGlzLm51bWJlciA/PyB0aGlzLnRhZykgYXMgQmxvY2tOdW1iZXIgfTtcbiAgfSAqL1xufTtcbmZ1bmN0aW9uIGlzVjNUeChkZXRhaWxzKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBkZXRhaWxzLnZlcnNpb24gPyB0b0hleChkZXRhaWxzLnZlcnNpb24pIDogXCIweDNcIiAvKiBWMyAqLztcbiAgcmV0dXJuIHZlcnNpb24gPT09IFwiMHgzXCIgLyogVjMgKi8gfHwgdmVyc2lvbiA9PT0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM1wiIC8qIEYzICovO1xufVxuZnVuY3Rpb24gaXNWZXJzaW9uKHZlcnNpb24sIHJlc3BvbnNlKSB7XG4gIGNvbnN0IFttYWpvclMsIG1pbm9yU10gPSB2ZXJzaW9uLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgW21ham9yUiwgbWlub3JSXSA9IHJlc3BvbnNlLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIG1ham9yUyA9PT0gbWFqb3JSICYmIG1pbm9yUyA9PT0gbWlub3JSO1xufVxuZnVuY3Rpb24gaXNQZW5kaW5nQmxvY2socmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlLnN0YXR1cyA9PT0gXCJQRU5ESU5HXCI7XG59XG5mdW5jdGlvbiBpc1BlbmRpbmdUcmFuc2FjdGlvbihyZXNwb25zZSkge1xuICByZXR1cm4gIShcImJsb2NrX2hhc2hcIiBpbiByZXNwb25zZSk7XG59XG5mdW5jdGlvbiBpc1BlbmRpbmdTdGF0ZVVwZGF0ZShyZXNwb25zZSkge1xuICByZXR1cm4gIShcImJsb2NrX2hhc2hcIiBpbiByZXNwb25zZSk7XG59XG5cbi8vIHNyYy91dGlscy90cmFuc2FjdGlvbi50c1xudmFyIHRyYW5zYWN0aW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHRyYW5zYWN0aW9uX2V4cG9ydHMsIHtcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGE6ICgpID0+IGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhLFxuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFXaXRoTm9uY2UsXG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xLFxuICBnZXRFeGVjdXRlQ2FsbGRhdGE6ICgpID0+IGdldEV4ZWN1dGVDYWxsZGF0YSxcbiAgZ2V0VmVyc2lvbnNCeVR5cGU6ICgpID0+IGdldFZlcnNpb25zQnlUeXBlLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMTogKCkgPT4gdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzFcbn0pO1xudmFyIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gW107XG4gIGNvbnN0IGNhbGxkYXRhID0gW107XG4gIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICBjb25zdCBkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKTtcbiAgICBjYWxsQXJyYXkucHVzaCh7XG4gICAgICB0bzogdG9CaWdJbnQoY2FsbC5jb250cmFjdEFkZHJlc3MpLnRvU3RyaW5nKDEwKSxcbiAgICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICAgIGRhdGFfb2Zmc2V0OiBjYWxsZGF0YS5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAgIGRhdGFfbGVuOiBkYXRhLmxlbmd0aC50b1N0cmluZygpXG4gICAgfSk7XG4gICAgY2FsbGRhdGEucHVzaCguLi5kYXRhKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsbEFycmF5LFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHsgY2FsbGRhdGEgfSlcbiAgfTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgeyBjYWxsQXJyYXksIGNhbGxkYXRhIH0gPSB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzKGNhbGxzKTtcbiAgY29uc3QgY29tcGlsZWRDYWxscyA9IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsQXJyYXkgfSk7XG4gIHJldHVybiBbLi4uY29tcGlsZWRDYWxscywgLi4uY2FsbGRhdGFdO1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSA9IChjYWxscywgbm9uY2UpID0+IHtcbiAgcmV0dXJuIFsuLi5mcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YShjYWxscyksIHRvQmlnSW50KG5vbmNlKS50b1N0cmluZygpXTtcbn07XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKVxuICB9KSk7XG4gIHJldHVybiBjYWxsQXJyYXk7XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBvcmRlckNhbGxzID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlwb2ludDogY2FsbC5lbnRyeXBvaW50LFxuICAgIGNhbGxkYXRhOiBBcnJheS5pc0FycmF5KGNhbGwuY2FsbGRhdGEpICYmIFwiX19jb21waWxlZF9fXCIgaW4gY2FsbC5jYWxsZGF0YSA/IGNhbGwuY2FsbGRhdGEgOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEpXG4gICAgLy8gUmF3QXJnc09iamVjdCB8IFJhd0FyZ3NBcnJheSB0eXBlXG4gIH0pKTtcbiAgcmV0dXJuIENhbGxEYXRhLmNvbXBpbGUoeyBvcmRlckNhbGxzIH0pO1xufTtcbnZhciBnZXRFeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMsIGNhaXJvVmVyc2lvbiA9IFwiMFwiKSA9PiB7XG4gIGlmIChjYWlyb1ZlcnNpb24gPT09IFwiMVwiKSB7XG4gICAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMShjYWxscyk7XG4gIH1cbiAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKTtcbn07XG5mdW5jdGlvbiBnZXRWZXJzaW9uc0J5VHlwZSh2ZXJzaW9uVHlwZSkge1xuICByZXR1cm4gdmVyc2lvblR5cGUgPT09IFwiZmVlXCIgPyB7XG4gICAgdjE6IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIiAvKiBGMSAqLyxcbiAgICB2MjogXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMlwiIC8qIEYyICovLFxuICAgIHYzOiBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzXCIgLyogRjMgKi9cbiAgfSA6IHsgdjE6IFwiMHgxXCIgLyogVjEgKi8sIHYyOiBcIjB4MlwiIC8qIFYyICovLCB2MzogXCIweDNcIiAvKiBWMyAqLyB9O1xufVxuXG4vLyBzcmMvY2hhbm5lbC9ycGNfMF82LnRzXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgYmxvY2tJZGVudGlmaWVyOiBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovLFxuICByZXRyaWVzOiAyMDBcbn07XG52YXIgUnBjQ2hhbm5lbCA9IGNsYXNzIHtcbiAgbm9kZVVybDtcbiAgaGVhZGVycztcbiAgcmV0cmllcztcbiAgcmVxdWVzdElkO1xuICBibG9ja0lkZW50aWZpZXI7XG4gIGNoYWluSWQ7XG4gIHNwZWNrVmVyc2lvbjtcbiAgd2FpdE1vZGU7XG4gIC8vIGJlaGF2ZSBsaWtlIHdlYjIgcnBjIGFuZCByZXR1cm4gd2hlbiB0eCBpcyBwcm9jZXNzZWRcbiAgY29uc3RydWN0b3Iob3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICBjb25zdCB7IG5vZGVVcmwsIHJldHJpZXMsIGhlYWRlcnMsIGJsb2NrSWRlbnRpZmllciwgY2hhaW5JZCwgd2FpdE1vZGUgfSA9IG9wdGlvbnNPclByb3ZpZGVyIHx8IHt9O1xuICAgIGlmIChPYmplY3QudmFsdWVzKE5ldHdvcmtOYW1lKS5pbmNsdWRlcyhub2RlVXJsKSkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwobm9kZVVybCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQpO1xuICAgIH0gZWxzZSBpZiAobm9kZVVybCkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gbm9kZVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwodm9pZCAwLCBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCk7XG4gICAgfVxuICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXMgfHwgZGVmYXVsdE9wdGlvbnMucmV0cmllcztcbiAgICB0aGlzLmhlYWRlcnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLmhlYWRlcnMsIC4uLmhlYWRlcnMgfTtcbiAgICB0aGlzLmJsb2NrSWRlbnRpZmllciA9IGJsb2NrSWRlbnRpZmllciB8fCBkZWZhdWx0T3B0aW9ucy5ibG9ja0lkZW50aWZpZXI7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB0aGlzLndhaXRNb2RlID0gd2FpdE1vZGUgfHwgZmFsc2U7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSAwO1xuICB9XG4gIGZldGNoKG1ldGhvZCwgcGFyYW1zLCBpZCA9IDApIHtcbiAgICBjb25zdCBycGNSZXF1ZXN0Qm9keSA9IHtcbiAgICAgIGlkLFxuICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgIG1ldGhvZCxcbiAgICAgIC4uLnBhcmFtcyAmJiB7IHBhcmFtcyB9XG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hQb255ZmlsbF9kZWZhdWx0KHRoaXMubm9kZVVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHN0cmluZ2lmeTIocnBjUmVxdWVzdEJvZHkpLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgfSk7XG4gIH1cbiAgZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBycGNFcnJvciwgb3RoZXJFcnJvcikge1xuICAgIGlmIChycGNFcnJvcikge1xuICAgICAgY29uc3QgeyBjb2RlLCBtZXNzYWdlLCBkYXRhIH0gPSBycGNFcnJvcjtcbiAgICAgIHRocm93IG5ldyBMaWJyYXJ5RXJyb3IoXG4gICAgICAgIGBSUEM6ICR7bWV0aG9kfSB3aXRoIHBhcmFtcyAke3N0cmluZ2lmeTIocGFyYW1zLCBudWxsLCAyKX1cbiBcbiAgICAgICAgJHtjb2RlfTogJHttZXNzYWdlfTogJHtzdHJpbmdpZnkyKGRhdGEpfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yIGluc3RhbmNlb2YgTGlicmFyeUVycm9yKSB7XG4gICAgICB0aHJvdyBvdGhlckVycm9yO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvcikge1xuICAgICAgdGhyb3cgRXJyb3Iob3RoZXJFcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmV0Y2hFbmRwb2ludChtZXRob2QsIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByYXdSZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoKG1ldGhvZCwgcGFyYW1zLCB0aGlzLnJlcXVlc3RJZCArPSAxKTtcbiAgICAgIGNvbnN0IHsgZXJyb3IsIHJlc3VsdCB9ID0gYXdhaXQgcmF3UmVzdWx0Lmpzb24oKTtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3I/LnJlc3BvbnNlPy5kYXRhLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICB0aGlzLmNoYWluSWQgPz89IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2NoYWluSWRcIik7XG4gICAgcmV0dXJuIHRoaXMuY2hhaW5JZDtcbiAgfVxuICBhc3luYyBnZXRTcGVjVmVyc2lvbigpIHtcbiAgICB0aGlzLnNwZWNrVmVyc2lvbiA/Pz0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3BlY1ZlcnNpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuc3BlY2tWZXJzaW9uO1xuICB9XG4gIGdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXROb25jZVwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBoYXNoIGFuZCBudW1iZXJcbiAgICovXG4gIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrSGFzaEFuZE51bWJlclwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBudW1iZXJcbiAgICogcmVkdW5kYW50IHVzZSBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gICAqIEByZXR1cm5zIE51bWJlciBvZiB0aGUgbGF0ZXN0IGJsb2NrXG4gICAqL1xuICBnZXRCbG9ja051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tOdW1iZXJcIik7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4SGFzaGVzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdGF0ZVVwZGF0ZVwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZUJsb2NrVHJhbnNhY3Rpb25zXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaFxuICAgIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleFwiLCB7IGJsb2NrX2lkLCBpbmRleCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VUcmFuc2FjdGlvblwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblN0YXR1c1wiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zIGJsb2NrSWRlbnRpZmllciBhbmQgZmxhZ3MgdG8gc2tpcCB2YWxpZGF0aW9uIGFuZCBmZWUgY2hhcmdlPGJyLz5cbiAgICogLSBibG9ja0lkZW50aWZpZXI8YnIvPlxuICAgKiAtIHNraXBWYWxpZGF0ZSAoZGVmYXVsdCBmYWxzZSk8YnIvPlxuICAgKiAtIHNraXBGZWVDaGFyZ2UgKGRlZmF1bHQgdHJ1ZSk8YnIvPlxuICAgKi9cbiAgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywge1xuICAgIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLFxuICAgIHNraXBWYWxpZGF0ZSA9IHRydWUsXG4gICAgc2tpcEZlZUNoYXJnZSA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHNpbXVsYXRpb25GbGFncyA9IFtdO1xuICAgIGlmIChza2lwVmFsaWRhdGUpXG4gICAgICBzaW11bGF0aW9uRmxhZ3MucHVzaChhcGlfZXhwb3J0cy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9WQUxJREFURSk7XG4gICAgaWYgKHNraXBGZWVDaGFyZ2UpXG4gICAgICBzaW11bGF0aW9uRmxhZ3MucHVzaChhcGlfZXhwb3J0cy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9GRUVfQ0hBUkdFKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc2ltdWxhdGVUcmFuc2FjdGlvbnNcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICB0cmFuc2FjdGlvbnM6IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCkpLFxuICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2ltdWxhdGlvbkZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgbGV0IHsgcmV0cmllcyB9ID0gdGhpcztcbiAgICBsZXQgb25jaGFpbiA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yU3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gb3B0aW9ucz8ucmV0cnlJbnRlcnZhbCA/PyA1ZTM7XG4gICAgY29uc3QgZXJyb3JTdGF0ZXMgPSBvcHRpb25zPy5lcnJvclN0YXRlcyA/PyBbXG4gICAgICBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuUkVKRUNURURcbiAgICAgIC8vIFRPRE86IGNvbW1lbnRlZCBvdXQgdG8gcHJlc2VydmUgdGhlIGxvbmctc3RhbmRpbmcgYmVoYXZpb3Igb2YgXCJyZXZlcnRlZFwiIG5vdCBiZWluZyB0cmVhdGVkIGFzIGFuIGVycm9yIGJ5IGRlZmF1bHRcbiAgICAgIC8vIHNob3VsZCBkZWNpZGUgd2hpY2ggYmVoYXZpb3IgdG8ga2VlcCBpbiB0aGUgZnV0dXJlXG4gICAgICAvLyBSUEMuRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlJFVkVSVEVELFxuICAgIF07XG4gICAgY29uc3Qgc3VjY2Vzc1N0YXRlcyA9IG9wdGlvbnM/LnN1Y2Nlc3NTdGF0ZXMgPz8gW1xuICAgICAgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlNVQ0NFRURFRCxcbiAgICAgIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMixcbiAgICAgIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMVxuICAgIF07XG4gICAgbGV0IHR4U3RhdHVzO1xuICAgIHdoaWxlICghb25jaGFpbikge1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR4U3RhdHVzID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBjb25zdCBleGVjdXRpb25TdGF0dXMgPSB0eFN0YXR1cy5leGVjdXRpb25fc3RhdHVzO1xuICAgICAgICBjb25zdCBmaW5hbGl0eVN0YXR1cyA9IHR4U3RhdHVzLmZpbmFsaXR5X3N0YXR1cztcbiAgICAgICAgaWYgKCFmaW5hbGl0eVN0YXR1cykge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwid2FpdGluZyBmb3IgdHJhbnNhY3Rpb24gc3RhdHVzXCIpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvclN0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IGVycm9yU3RhdGVzLmluY2x1ZGVzKGZpbmFsaXR5U3RhdHVzKSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtleGVjdXRpb25TdGF0dXN9OiAke2ZpbmFsaXR5U3RhdHVzfWA7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSB0eFN0YXR1cztcbiAgICAgICAgICBpc0Vycm9yU3RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGVsc2UgaWYgKHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMoZXhlY3V0aW9uU3RhdHVzKSB8fCBzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKGZpbmFsaXR5U3RhdHVzKSkge1xuICAgICAgICAgIG9uY2hhaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBpc0Vycm9yU3RhdGUpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yVHJhbnNhY3Rpb24gdGltZWQtb3V0IHdpdGggcmV0cmllcyAke3RoaXMucmV0cmllc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmllcyAtPSAxO1xuICAgIH1cbiAgICBsZXQgdHhSZWNlaXB0ID0gbnVsbDtcbiAgICB3aGlsZSAodHhSZWNlaXB0ID09PSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgfVxuICAgIHJldHVybiB0eFJlY2VpcHQ7XG4gIH1cbiAgZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IHRvU3RvcmFnZUtleShrZXkpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0U3RvcmFnZUF0XCIsIHtcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBrZXk6IHBhcnNlZEtleSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NIYXNoQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNsYXNzX2hhc2ggPSB0b0hleChjbGFzc0hhc2gpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NcIiwge1xuICAgICAgY2xhc3NfaGFzaCxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc0F0XCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgY29udHJhY3RfYWRkcmVzc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlKGludm9jYXRpb25zLCB7IGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSB0cnVlIH0pIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgbGV0IGZsYWdzID0ge307XG4gICAgaWYgKGlzVmVyc2lvbihcIjAuNlwiLCBhd2FpdCB0aGlzLmdldFNwZWNWZXJzaW9uKCkpKSB7XG4gICAgICBmbGFncyA9IHtcbiAgICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2tpcFZhbGlkYXRlID8gW2FwaV9leHBvcnRzLkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFXSA6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0LCBcImZlZVwiKSksXG4gICAgICBibG9ja19pZCxcbiAgICAgIC4uLmZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaW52b2tlKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBpbnZva2VfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogZnVuY3Rpb25JbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgICB0eXBlOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICB2ZXJzaW9uOiBcIjB4MVwiIC8qIFYxICovLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGludm9rZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChmdW5jdGlvbkludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICAgIHZlcnNpb246IFwiMHgzXCIgLyogVjMgKi8sXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGZ1bmN0aW9uSW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICByZXNvdXJjZV9ib3VuZHM6IGRldGFpbHMucmVzb3VyY2VCb3VuZHMsXG4gICAgICAgICAgdGlwOiB0b0hleChkZXRhaWxzLnRpcCksXG4gICAgICAgICAgcGF5bWFzdGVyX2RhdGE6IGRldGFpbHMucGF5bWFzdGVyRGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIGFjY291bnRfZGVwbG95bWVudF9kYXRhOiBkZXRhaWxzLmFjY291bnREZXBsb3ltZW50RGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIG5vbmNlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdE1vZGUgPyB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbigoYXdhaXQgcHJvbWlzZSkudHJhbnNhY3Rpb25faGFzaCkgOiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlY2xhcmUoeyBjb250cmFjdCwgc2lnbmF0dXJlLCBzZW5kZXJBZGRyZXNzLCBjb21waWxlZENsYXNzSGFzaCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKCFpc1NpZXJyYShjb250cmFjdCkgJiYgIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHByb2dyYW06IGNvbnRyYWN0LnByb2dyYW0sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVyc2lvbjogXCIweDFcIiAvKiBWMSAqLyxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5zaWVycmFfcHJvZ3JhbSksXG4gICAgICAgICAgICBjb250cmFjdF9jbGFzc192ZXJzaW9uOiBjb250cmFjdC5jb250cmFjdF9jbGFzc192ZXJzaW9uLFxuICAgICAgICAgICAgZW50cnlfcG9pbnRzX2J5X3R5cGU6IGNvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLFxuICAgICAgICAgICAgYWJpOiBjb250cmFjdC5hYmlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgICAgdmVyc2lvbjogXCIweDJcIiAvKiBWMiAqLyxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICAgIHZlcnNpb246IFwiMHgzXCIgLyogVjMgKi8sXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgICBzaWVycmFfcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3Quc2llcnJhX3Byb2dyYW0pLFxuICAgICAgICAgICAgY29udHJhY3RfY2xhc3NfdmVyc2lvbjogY29udHJhY3QuY29udHJhY3RfY2xhc3NfdmVyc2lvbixcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNvdXJjZV9ib3VuZHM6IGRldGFpbHMucmVzb3VyY2VCb3VuZHMsXG4gICAgICAgICAgdGlwOiB0b0hleChkZXRhaWxzLnRpcCksXG4gICAgICAgICAgcGF5bWFzdGVyX2RhdGE6IGRldGFpbHMucGF5bWFzdGVyRGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIGFjY291bnRfZGVwbG95bWVudF9kYXRhOiBkZXRhaWxzLmFjY291bnREZXBsb3ltZW50RGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICAgIG5vbmNlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJkZWNsYXJlIHVuc3BvdHRlZCBwYXJhbWV0ZXJzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgYXN5bmMgZGVwbG95QWNjb3VudCh7IGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgYWRkcmVzc1NhbHQsIHNpZ25hdHVyZSB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKCFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgICBjbGFzc19oYXNoOiB0b0hleChjbGFzc0hhc2gpLFxuICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgICAgdHlwZTogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICB2ZXJzaW9uOiBcIjB4MVwiIC8qIFYxICovLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCxcbiAgICAgICAgICB2ZXJzaW9uOiBcIjB4M1wiIC8qIFYzICovLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgICBjbGFzc19oYXNoOiB0b0hleChjbGFzc0hhc2gpLFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgY2FsbENvbnRyYWN0KGNhbGwsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jYWxsXCIsIHtcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCksXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjYWxsLmNhbGxkYXRhKVxuICAgICAgfSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogRXN0aW1hdGUgdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gTDFcbiAgICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSBGcm9tIEwxXG4gICAqL1xuICBlc3RpbWF0ZU1lc3NhZ2VGZWUobWVzc2FnZSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCB7IGZyb21fYWRkcmVzcywgdG9fYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHtcbiAgICAgIGZyb21fYWRkcmVzczogdG9IZXgoZnJvbV9hZGRyZXNzKSxcbiAgICAgIHRvX2FkZHJlc3M6IHRvSGV4KHRvX2FkZHJlc3MpLFxuICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yKGVudHJ5X3BvaW50X3NlbGVjdG9yKSxcbiAgICAgIHBheWxvYWQ6IGdldEhleFN0cmluZ0FycmF5KHBheWxvYWQpXG4gICAgfTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlTWVzc2FnZUZlZVwiLCB7XG4gICAgICBtZXNzYWdlOiBmb3JtYXR0ZWRNZXNzYWdlLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYWJvdXQgdGhlIHN5bmMgc3RhdHVzLCBvciBmYWxzZSBpZiB0aGUgbm9kZSBpcyBub3Qgc3luY2hpbmdcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHN0YXRzIGRhdGFcbiAgICovXG4gIGdldFN5bmNpbmdTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3luY2luZ1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGFuZCB0aGUgcGFnaW5hdGlvbiBvZiB0aGUgZXZlbnRzXG4gICAqL1xuICBnZXRFdmVudHMoZXZlbnRGaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0RXZlbnRzXCIsIHsgZmlsdGVyOiBldmVudEZpbHRlciB9KTtcbiAgfVxuICBidWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb24sIHZlcnNpb25UeXBlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb25zID0gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpO1xuICAgIGxldCBkZXRhaWxzO1xuICAgIGlmICghaXNWM1R4KGludm9jYXRpb24pKSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGludm9jYXRpb24ubWF4RmVlIHx8IDApXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIHJlc291cmNlX2JvdW5kczogaW52b2NhdGlvbi5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgdGlwOiB0b0hleChpbnZvY2F0aW9uLnRpcCksXG4gICAgICAgIHBheW1hc3Rlcl9kYXRhOiBpbnZvY2F0aW9uLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGludm9jYXRpb24uYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyB2MCB2MSB2M1xuICAgICAgICB0eXBlOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgLy8gVE9ETzogRGlmZiBiZXR3ZWVuIHNlcXVlbmNlciBhbmQgcnBjIGludm9rZSB0eXBlXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYzKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgaWYgKCFpc1NpZXJyYShpbnZvY2F0aW9uLmNvbnRyYWN0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczogaW52b2NhdGlvbi5jb250cmFjdCxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5zZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIENhaXJvIDEgLSB2MiB2M1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgLi4uaW52b2NhdGlvbi5jb250cmFjdCxcbiAgICAgICAgICBzaWVycmFfcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oaW52b2NhdGlvbi5jb250cmFjdC5zaWVycmFfcHJvZ3JhbSlcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogaW52b2NhdGlvbi5jb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5zZW5kZXJBZGRyZXNzLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYzKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovKSB7XG4gICAgICBjb25zdCB7IGFjY291bnRfZGVwbG95bWVudF9kYXRhLCAuLi5yZXN0RGV0YWlscyB9ID0gZGV0YWlscztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGludm9jYXRpb24uY2xhc3NIYXNoKSxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChpbnZvY2F0aW9uLmFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYzKSxcbiAgICAgICAgLi4ucmVzdERldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwiUlBDIGJ1aWxkVHJhbnNhY3Rpb24gcmVjZWl2ZWQgdW5rbm93biBUcmFuc2FjdGlvblR5cGVcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9yZXNwb25zZVBhcnNlci9ycGMudHNcbnZhciBSUENSZXNwb25zZVBhcnNlciA9IGNsYXNzIHtcbiAgcGFyc2VHZXRCbG9ja1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJQRU5ESU5HXCIsIC4uLnJlcyB9O1xuICB9XG4gIHBhcnNlVHJhbnNhY3Rpb25SZWNlaXB0KHJlcykge1xuICAgIGlmIChcImFjdHVhbF9mZWVcIiBpbiByZXMgJiYgdHlwZW9mIHJlcy5hY3R1YWxfZmVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXMsXG4gICAgICAgIGFjdHVhbF9mZWU6IHtcbiAgICAgICAgICBhbW91bnQ6IHJlcy5hY3R1YWxfZmVlLFxuICAgICAgICAgIHVuaXQ6IFwiRlJJXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgdmFsID0gcmVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQodmFsLmdhc19jb25zdW1lZCksXG4gICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHZhbC5nYXNfcHJpY2UpLFxuICAgICAgdW5pdDogdmFsLnVuaXQsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWU6IGVzdGltYXRlZEZlZVRvTWF4RmVlKHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGVGZWVUb0JvdW5kcyh2YWwpXG4gICAgfTtcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKCh2YWwpID0+ICh7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQodmFsLmdhc19jb25zdW1lZCksXG4gICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHZhbC5nYXNfcHJpY2UpLFxuICAgICAgdW5pdDogdmFsLnVuaXQsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWU6IGVzdGltYXRlZEZlZVRvTWF4RmVlKHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGVGZWVUb0JvdW5kcyh2YWwpXG4gICAgfSkpO1xuICB9XG4gIHBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKChpdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXQsXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZTogZXN0aW1hdGVkRmVlVG9NYXhGZWUoQmlnSW50KGl0LmZlZV9lc3RpbWF0aW9uLm92ZXJhbGxfZmVlKSksXG4gICAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZUZlZVRvQm91bmRzKGl0LmZlZV9lc3RpbWF0aW9uKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBwYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzLFxuICAgICAgYWJpOiB0eXBlb2YgcmVzLmFiaSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UocmVzLmFiaSkgOiByZXMuYWJpXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL3JwYy50c1xudmFyIFJwY1Byb3ZpZGVyID0gY2xhc3Mge1xuICByZXNwb25zZVBhcnNlciA9IG5ldyBSUENSZXNwb25zZVBhcnNlcigpO1xuICBjaGFubmVsO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zT3JQcm92aWRlcikge1xuICAgIGlmIChvcHRpb25zT3JQcm92aWRlciAmJiBcImNoYW5uZWxcIiBpbiBvcHRpb25zT3JQcm92aWRlcikge1xuICAgICAgdGhpcy5jaGFubmVsID0gb3B0aW9uc09yUHJvdmlkZXIuY2hhbm5lbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFubmVsID0gbmV3IFJwY0NoYW5uZWwoeyAuLi5vcHRpb25zT3JQcm92aWRlciwgd2FpdE1vZGU6IGZhbHNlIH0pO1xuICAgIH1cbiAgfVxuICBmZXRjaChtZXRob2QsIHBhcmFtcywgaWQgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5mZXRjaChtZXRob2QsIHBhcmFtcywgaWQpO1xuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRDaGFpbklkKCk7XG4gIH1cbiAgYXN5bmMgZ2V0U3BlY1ZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRTcGVjVmVyc2lvbigpO1xuICB9XG4gIGFzeW5jIGdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcikudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0QmxvY2tSZXNwb25zZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgaGFzaCBhbmQgbnVtYmVyXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIG51bWJlclxuICAgKiByZWR1bmRhbnQgdXNlIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKTtcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIHRoZSBsYXRlc3QgYmxvY2tcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgZ2V0U3RhdGVVcGRhdGUgPSB0aGlzLmdldEJsb2NrU3RhdGVVcGRhdGU7XG4gIGFzeW5jIGdldEJsb2NrU3RhdGVVcGRhdGUoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJhbnNhY3Rpb25zIGZyb20gcGVuZGluZyBibG9ja1xuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkIHVzZSBnZXRCbG9jayhCbG9ja1RhZy5wZW5kaW5nKTsgKHdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IG1pbm9yIHZlcnNpb24pXG4gICAqIFV0aWxpdHkgbWV0aG9kLCBzYW1lIHJlc3VsdCBjYW4gYmUgYWNoaWV2ZWQgdXNpbmcgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoQmxvY2tUYWcucGVuZGluZyk7XG4gICAqL1xuICBhc3luYyBnZXRQZW5kaW5nVHJhbnNhY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBhd2FpdCB0aGlzLmdldEJsb2NrV2l0aFR4SGFzaGVzKFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0QmxvY2tSZXNwb25zZVxuICAgICk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmdldFRyYW5zYWN0aW9uQnlIYXNoKGl0KSkpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleChibG9ja0lkZW50aWZpZXIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4KGJsb2NrSWRlbnRpZmllciwgaW5kZXgpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZVRyYW5zYWN0aW9uUmVjZWlwdCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uVHJhY2UodHhIYXNoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gaW52b2NhdGlvbnMgQWNjb3VudEludm9jYXRpb25zXG4gICAqIEBwYXJhbSBzaW11bGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyBibG9ja0lkZW50aWZpZXIgYW5kIGZsYWdzIHRvIHNraXAgdmFsaWRhdGlvbiBhbmQgZmVlIGNoYXJnZTxici8+XG4gICAqIC0gYmxvY2tJZGVudGlmaWVyPGJyLz5cbiAgICogLSBza2lwVmFsaWRhdGUgKGRlZmF1bHQgZmFsc2UpPGJyLz5cbiAgICogLSBza2lwRmVlQ2hhcmdlIChkZWZhdWx0IHRydWUpPGJyLz5cbiAgICovXG4gIGFzeW5jIGdldFNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLnNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIG9wdGlvbnMpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZVNpbXVsYXRlVHJhbnNhY3Rpb25SZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwud2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQnlIYXNoKGNsYXNzSGFzaCkge1xuICAgIHJldHVybiB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29udHJhY3RWZXJzaW9uKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCB7XG4gICAgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5jaGFubmVsLmJsb2NrSWRlbnRpZmllcixcbiAgICBjb21waWxlciA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgbGV0IGNvbnRyYWN0Q2xhc3M7XG4gICAgaWYgKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmIChjbGFzc0hhc2gpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJnZXRDb250cmFjdFZlcnNpb24gcmVxdWlyZSBjb250cmFjdEFkZHJlc3Mgb3IgY2xhc3NIYXNoXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaWVycmEoY29udHJhY3RDbGFzcykpIHtcbiAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICBjb25zdCBhYmlUZXN0ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGNvbnRyYWN0Q2xhc3MuYWJpKTtcbiAgICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogYWJpVGVzdC5jb21waWxlciB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXQqdHlwZSpFc3RpbWF0ZUZlZSAod2lsbCBiZSByZWZhY3RvcmVkIGJhc2VkIG9uIHR5cGUgYWZ0ZXIgc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKTtcbiAgfVxuICBhc3luYyBnZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8sXG4gICAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uRGV0YWlsc1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9XG4gICAgKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXREZWNsYXJlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLyxcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfVxuICAgICkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFc3RpbWF0ZUZlZShcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfVxuICAgICkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9ucywgb3B0aW9ucykudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGludm9rZUZ1bmN0aW9uKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuaW52b2tlKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZUNvbnRyYWN0KHRyYW5zYWN0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5kZWNsYXJlKHRyYW5zYWN0aW9uLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50Q29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmRlcGxveUFjY291bnQoXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIGRldGFpbHNcbiAgICApO1xuICB9XG4gIGFzeW5jIGNhbGxDb250cmFjdChjYWxsLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmNhbGxDb250cmFjdChjYWxsLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIC8qKlxuICAgKiBORVc6IEVzdGltYXRlIHRoZSBmZWUgZm9yIGEgbWVzc2FnZSBmcm9tIEwxXG4gICAqIEBwYXJhbSBtZXNzYWdlIE1lc3NhZ2UgRnJvbSBMMVxuICAgKi9cbiAgYXN5bmMgZXN0aW1hdGVNZXNzYWdlRmVlKG1lc3NhZ2UsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZXN0aW1hdGVNZXNzYWdlRmVlKG1lc3NhZ2UsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGFib3V0IHRoZSBzeW5jIHN0YXR1cywgb3IgZmFsc2UgaWYgdGhlIG5vZGUgaXMgbm90IHN5bmNoaW5nXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHRoZSBzdGF0cyBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRTeW5jaW5nU3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRTeW5jaW5nU3RhdHMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGFuZCB0aGUgcGFnaW5hdGlvbiBvZiB0aGUgZXZlbnRzXG4gICAqL1xuICBhc3luYyBnZXRFdmVudHMoZXZlbnRGaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEV2ZW50cyhldmVudEZpbHRlcik7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9leHRlbnNpb25zL2RlZmF1bHQudHNcbmltcG9ydCB7IE1peGluIH0gZnJvbSBcInRzLW1peGVyXCI7XG5cbi8vIHNyYy91dGlscy9zdGFya25ldElkLnRzXG52YXIgc3RhcmtuZXRJZF9leHBvcnRzID0ge307XG5fX2V4cG9ydChzdGFya25ldElkX2V4cG9ydHMsIHtcbiAgU3RhcmtuZXRJZENvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkQ29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZENvbnRyYWN0LFxuICB1c2VEZWNvZGVkOiAoKSA9PiB1c2VEZWNvZGVkLFxuICB1c2VFbmNvZGVkOiAoKSA9PiB1c2VFbmNvZGVkXG59KTtcbnZhciBiYXNpY0FscGhhYmV0ID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXCI7XG52YXIgYmFzaWNTaXplUGx1c09uZSA9IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCArIDEpO1xudmFyIGJpZ0FscGhhYmV0ID0gXCJcXHU4RkQ5XFx1Njc2NVwiO1xudmFyIGJhc2ljQWxwaGFiZXRTaXplID0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoKTtcbnZhciBiaWdBbHBoYWJldFNpemUgPSBCaWdJbnQoYmlnQWxwaGFiZXQubGVuZ3RoKTtcbnZhciBiaWdBbHBoYWJldFNpemVQbHVzT25lID0gQmlnSW50KGJpZ0FscGhhYmV0Lmxlbmd0aCArIDEpO1xuZnVuY3Rpb24gZXh0cmFjdFN0YXJzKHN0cikge1xuICBsZXQgayA9IDA7XG4gIHdoaWxlIChzdHIuZW5kc1dpdGgoYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0pKSB7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgayArPSAxO1xuICB9XG4gIHJldHVybiBbc3RyLCBrXTtcbn1cbmZ1bmN0aW9uIHVzZURlY29kZWQoZW5jb2RlZCkge1xuICBsZXQgZGVjb2RlZCA9IFwiXCI7XG4gIGVuY29kZWQuZm9yRWFjaCgoc3ViZG9tYWluKSA9PiB7XG4gICAgd2hpbGUgKHN1YmRvbWFpbiAhPT0gWkVSTykge1xuICAgICAgY29uc3QgY29kZSA9IHN1YmRvbWFpbiAlIGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBzdWJkb21haW4gLz0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIGlmIChjb2RlID09PSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IG5leHRTdWJkb21haW4gPSBzdWJkb21haW4gLyBiaWdBbHBoYWJldFNpemVQbHVzT25lO1xuICAgICAgICBpZiAobmV4dFN1YmRvbWFpbiA9PT0gWkVSTykge1xuICAgICAgICAgIGNvbnN0IGNvZGUyID0gc3ViZG9tYWluICUgYmlnQWxwaGFiZXRTaXplUGx1c09uZTtcbiAgICAgICAgICBzdWJkb21haW4gPSBuZXh0U3ViZG9tYWluO1xuICAgICAgICAgIGlmIChjb2RlMiA9PT0gWkVSTylcbiAgICAgICAgICAgIGRlY29kZWQgKz0gYmFzaWNBbHBoYWJldFswXTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWNvZGVkICs9IGJpZ0FscGhhYmV0W051bWJlcihjb2RlMikgLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjb2RlMiA9IHN1YmRvbWFpbiAlIGJpZ0FscGhhYmV0U2l6ZTtcbiAgICAgICAgICBkZWNvZGVkICs9IGJpZ0FscGhhYmV0W051bWJlcihjb2RlMildO1xuICAgICAgICAgIHN1YmRvbWFpbiAvPSBiaWdBbHBoYWJldFNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBkZWNvZGVkICs9IGJhc2ljQWxwaGFiZXRbTnVtYmVyKGNvZGUpXTtcbiAgICB9XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZCk7XG4gICAgaWYgKGspXG4gICAgICBkZWNvZGVkID0gc3RyICsgKGsgJSAyID09PSAwID8gYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KGsgLyAyIC0gMSkgKyBiaWdBbHBoYWJldFswXSArIGJhc2ljQWxwaGFiZXRbMV0gOiBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoKGsgLSAxKSAvIDIgKyAxKSk7XG4gICAgZGVjb2RlZCArPSBcIi5cIjtcbiAgfSk7XG4gIGlmICghZGVjb2RlZCkge1xuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG4gIHJldHVybiBkZWNvZGVkLmNvbmNhdChcInN0YXJrXCIpO1xufVxuZnVuY3Rpb24gdXNlRW5jb2RlZChkZWNvZGVkKSB7XG4gIGxldCBlbmNvZGVkID0gQmlnSW50KDApO1xuICBsZXQgbXVsdGlwbGllciA9IEJpZ0ludCgxKTtcbiAgaWYgKGRlY29kZWQuZW5kc1dpdGgoYmlnQWxwaGFiZXRbMF0gKyBiYXNpY0FscGhhYmV0WzFdKSkge1xuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQuc3Vic3RyaW5nKDAsIGRlY29kZWQubGVuZ3RoIC0gMikpO1xuICAgIGRlY29kZWQgPSBzdHIgKyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoMiAqIChrICsgMSkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQpO1xuICAgIGlmIChrKVxuICAgICAgZGVjb2RlZCA9IHN0ciArIGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdCgxICsgMiAqIChrIC0gMSkpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBkZWNvZGVkW2ldO1xuICAgIGNvbnN0IGluZGV4ID0gYmFzaWNBbHBoYWJldC5pbmRleE9mKGNoYXIpO1xuICAgIGNvbnN0IGJuSW5kZXggPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5pbmRleE9mKGNoYXIpKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoaSA9PT0gZGVjb2RlZC5sZW5ndGggLSAxICYmIGRlY29kZWRbaV0gPT09IGJhc2ljQWxwaGFiZXRbMF0pIHtcbiAgICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYmFzaWNBbHBoYWJldFNpemU7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYm5JbmRleDtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYmlnQWxwaGFiZXQuaW5kZXhPZihjaGFyKSAhPT0gLTEpIHtcbiAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJhc2ljQWxwaGFiZXRTaXplO1xuICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgY29uc3QgbmV3aWQgPSAoaSA9PT0gZGVjb2RlZC5sZW5ndGggLSAxID8gMSA6IDApICsgYmlnQWxwaGFiZXQuaW5kZXhPZihjaGFyKTtcbiAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIEJpZ0ludChuZXdpZCk7XG4gICAgICBtdWx0aXBsaWVyICo9IGJpZ0FscGhhYmV0U2l6ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG52YXIgU3RhcmtuZXRJZENvbnRyYWN0ID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRJZENvbnRyYWN0MikgPT4ge1xuICBTdGFya25ldElkQ29udHJhY3QyW1wiTUFJTk5FVFwiXSA9IFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIjtcbiAgU3RhcmtuZXRJZENvbnRyYWN0MltcIlRFU1RORVRcIl0gPSBcIjB4M2JhYjI2OGU5MzJkMmNlY2QxOTQ2ZjEwMGFlNjdjZTNkZmY5ZmQyMzQxMTllYTJmNmRhNTdkMTZkMjlmY2VcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRDb250cmFjdDI7XG59KShTdGFya25ldElkQ29udHJhY3QgfHwge30pO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIiAvKiBNQUlOTkVUICovO1xuICAgIGNhc2UgXCIweDUzNGU1ZjQ3NGY0NTUyNGM0OVwiIC8qIFNOX0dPRVJMSSAqLzpcbiAgICAgIHJldHVybiBcIjB4M2JhYjI2OGU5MzJkMmNlY2QxOTQ2ZjEwMGFlNjdjZTNkZmY5ZmQyMzQxMTllYTJmNmRhNTdkMTZkMjlmY2VcIiAvKiBURVNUTkVUICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFya25ldC5pZCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxuXG4vLyBzcmMvcHJvdmlkZXIvZXh0ZW5zaW9ucy9zdGFya25ldElkLnRzXG52YXIgU3RhcmtuZXRJZCA9IGNsYXNzIHtcbiAgYXN5bmMgZ2V0U3RhcmtOYW1lKGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gU3RhcmtuZXRJZC5nZXRTdGFya05hbWUoXG4gICAgICAvLyBBZnRlciBNaXhpbiwgdGhpcyBpcyBQcm92aWRlckludGVyZmFjZVxuICAgICAgdGhpcyxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBTdGFya25ldElkQ29udHJhY3QyXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIFN0YXJrbmV0SWQuZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUoXG4gICAgICAvLyBBZnRlciBNaXhpbiwgdGhpcyBpcyBQcm92aWRlckludGVyZmFjZVxuICAgICAgdGhpcyxcbiAgICAgIG5hbWUsXG4gICAgICBTdGFya25ldElkQ29udHJhY3QyXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2V0U3RhcmtOYW1lKHByb3ZpZGVyLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZXhEb21haW4gPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0LFxuICAgICAgICBlbnRyeXBvaW50OiBcImFkZHJlc3NfdG9fZG9tYWluXCIsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgICBhZGRyZXNzXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlY2ltYWxEb21haW4gPSBoZXhEb21haW4ubWFwKChlbGVtZW50KSA9PiBCaWdJbnQoZWxlbWVudCkpLnNsaWNlKDEpO1xuICAgICAgY29uc3Qgc3RyaW5nRG9tYWluID0gdXNlRGVjb2RlZChkZWNpbWFsRG9tYWluKTtcbiAgICAgIGlmICghc3RyaW5nRG9tYWluKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmdEb21haW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UgPT09IFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgc3RhcmsgbmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHByb3ZpZGVyLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZGRyZXNzRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmNhbGxDb250cmFjdCh7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udHJhY3QsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFwiZG9tYWluX3RvX2FkZHJlc3NcIixcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoe1xuICAgICAgICAgIGRvbWFpbjogW3VzZUVuY29kZWQobmFtZS5yZXBsYWNlKFwiLnN0YXJrXCIsIFwiXCIpKS50b1N0cmluZygxMCldXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhZGRyZXNzRGF0YVswXTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGdldCBhZGRyZXNzIGZyb20gc3RhcmsgbmFtZVwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9leHRlbnNpb25zL2RlZmF1bHQudHNcbnZhciBScGNQcm92aWRlcjIgPSBjbGFzcyBleHRlbmRzIE1peGluKFJwY1Byb3ZpZGVyLCBTdGFya25ldElkKSB7XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvaW50ZXJmYWNlLnRzXG52YXIgUHJvdmlkZXJJbnRlcmZhY2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvaW5kZXgudHNcbnZhciBkZWZhdWx0UHJvdmlkZXIgPSBuZXcgUnBjUHJvdmlkZXIoeyBkZWZhdWx0OiB0cnVlIH0pO1xuXG4vLyBzcmMvc2lnbmVyL2ludGVyZmFjZS50c1xudmFyIFNpZ25lckludGVyZmFjZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbnZhciB0eXBlZERhdGFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZWREYXRhX2V4cG9ydHMsIHtcbiAgVHlwZWREYXRhUmV2aXNpb246ICgpID0+IFR5cGVkRGF0YVJldmlzaW9uLFxuICBieXRlQXJyYXlGcm9tU3RyaW5nOiAoKSA9PiBieXRlQXJyYXlGcm9tU3RyaW5nMixcbiAgZW5jb2RlRGF0YTogKCkgPT4gZW5jb2RlRGF0YSxcbiAgZW5jb2RlVHlwZTogKCkgPT4gZW5jb2RlVHlwZSxcbiAgZW5jb2RlVmFsdWU6ICgpID0+IGVuY29kZVZhbHVlLFxuICBnZXREZXBlbmRlbmNpZXM6ICgpID0+IGdldERlcGVuZGVuY2llcyxcbiAgZ2V0TWVzc2FnZUhhc2g6ICgpID0+IGdldE1lc3NhZ2VIYXNoLFxuICBnZXRTdHJ1Y3RIYXNoOiAoKSA9PiBnZXRTdHJ1Y3RIYXNoLFxuICBnZXRUeXBlSGFzaDogKCkgPT4gZ2V0VHlwZUhhc2gsXG4gIGlzTWVya2xlVHJlZVR5cGU6ICgpID0+IGlzTWVya2xlVHJlZVR5cGUsXG4gIHByZXBhcmVTZWxlY3RvcjogKCkgPT4gcHJlcGFyZVNlbGVjdG9yXG59KTtcblxuLy8gc3JjL3V0aWxzL21lcmtsZS50c1xudmFyIG1lcmtsZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChtZXJrbGVfZXhwb3J0cywge1xuICBNZXJrbGVUcmVlOiAoKSA9PiBNZXJrbGVUcmVlLFxuICBwcm9vZk1lcmtsZVBhdGg6ICgpID0+IHByb29mTWVya2xlUGF0aFxufSk7XG52YXIgTWVya2xlVHJlZSA9IGNsYXNzIHtcbiAgbGVhdmVzO1xuICBicmFuY2hlcyA9IFtdO1xuICByb290O1xuICBoYXNoTWV0aG9kO1xuICBjb25zdHJ1Y3RvcihsZWFmSGFzaGVzLCBoYXNoTWV0aG9kID0gY29tcHV0ZVBlZGVyc2VuSGFzaCkge1xuICAgIHRoaXMuaGFzaE1ldGhvZCA9IGhhc2hNZXRob2Q7XG4gICAgdGhpcy5sZWF2ZXMgPSBsZWFmSGFzaGVzO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuYnVpbGQobGVhZkhhc2hlcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBNZXJrbGUgdHJlZVxuICAgKiBAcGFyYW0gbGVhdmVzIGhleC1zdHJpbmcgYXJyYXlcbiAgICogQHJldHVybnMgZm9ybWF0OiBoZXgtc3RyaW5nOyBNZXJrbGUgdHJlZSByb290XG4gICAqL1xuICBidWlsZChsZWF2ZXMpIHtcbiAgICBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGxlYXZlc1swXTtcbiAgICB9XG4gICAgaWYgKGxlYXZlcy5sZW5ndGggIT09IHRoaXMubGVhdmVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5icmFuY2hlcy5wdXNoKGxlYXZlcyk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0xlYXZlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVhdmVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoaSArIDEgPT09IGxlYXZlcy5sZW5ndGgpIHtcbiAgICAgICAgbmV3TGVhdmVzLnB1c2goTWVya2xlVHJlZS5oYXNoKGxlYXZlc1tpXSwgXCIweDBcIiwgdGhpcy5oYXNoTWV0aG9kKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMZWF2ZXMucHVzaChNZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBsZWF2ZXNbaSArIDFdLCB0aGlzLmhhc2hNZXRob2QpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVpbGQobmV3TGVhdmVzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGhhc2ggZnJvbSBvcmRlcmVkIGEgYW5kIGIsIFBlZGVyc2VuIGhhc2ggZGVmYXVsdFxuICAgKiBAcmV0dXJucyBmb3JtYXQ6IGhleC1zdHJpbmdcbiAgICovXG4gIHN0YXRpYyBoYXNoKGEsIGIsIGhhc2hNZXRob2QgPSBjb21wdXRlUGVkZXJzZW5IYXNoKSB7XG4gICAgY29uc3QgW2FTb3J0ZWQsIGJTb3J0ZWRdID0gW0JpZ0ludChhKSwgQmlnSW50KGIpXS5zb3J0KCh4LCB5KSA9PiB4ID49IHkgPyAxIDogLTEpO1xuICAgIHJldHVybiBoYXNoTWV0aG9kKGFTb3J0ZWQsIGJTb3J0ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gcGF0aCB0byBsZWFmXG4gICAqIEBwYXJhbSBsZWFmIGhleC1zdHJpbmdcbiAgICogQHBhcmFtIGJyYW5jaCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEBwYXJhbSBoYXNoUGF0aCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEByZXR1cm5zIGZvcm1hdDogaGV4LXN0cmluZyBhcnJheVxuICAgKi9cbiAgZ2V0UHJvb2YobGVhZiwgYnJhbmNoID0gdGhpcy5sZWF2ZXMsIGhhc2hQYXRoID0gW10pIHtcbiAgICBjb25zdCBpbmRleCA9IGJyYW5jaC5pbmRleE9mKGxlYWYpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxlYWYgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc2hQYXRoO1xuICAgIH1cbiAgICBjb25zdCBpc0xlZnQgPSBpbmRleCAlIDIgPT09IDA7XG4gICAgY29uc3QgbmVlZGVkQnJhbmNoID0gKGlzTGVmdCA/IGJyYW5jaFtpbmRleCArIDFdIDogYnJhbmNoW2luZGV4IC0gMV0pID8/IFwiMHgwXCI7XG4gICAgY29uc3QgbmV3SGFzaFBhdGggPSBbLi4uaGFzaFBhdGgsIG5lZWRlZEJyYW5jaF07XG4gICAgY29uc3QgY3VycmVudEJyYW5jaExldmVsSW5kZXggPSB0aGlzLmxlYXZlcy5sZW5ndGggPT09IGJyYW5jaC5sZW5ndGggPyAtMSA6IHRoaXMuYnJhbmNoZXMuZmluZEluZGV4KChiKSA9PiBiLmxlbmd0aCA9PT0gYnJhbmNoLmxlbmd0aCk7XG4gICAgY29uc3QgbmV4dEJyYW5jaCA9IHRoaXMuYnJhbmNoZXNbY3VycmVudEJyYW5jaExldmVsSW5kZXggKyAxXSA/PyBbdGhpcy5yb290XTtcbiAgICByZXR1cm4gdGhpcy5nZXRQcm9vZihcbiAgICAgIE1lcmtsZVRyZWUuaGFzaChpc0xlZnQgPyBsZWFmIDogbmVlZGVkQnJhbmNoLCBpc0xlZnQgPyBuZWVkZWRCcmFuY2ggOiBsZWFmLCB0aGlzLmhhc2hNZXRob2QpLFxuICAgICAgbmV4dEJyYW5jaCxcbiAgICAgIG5ld0hhc2hQYXRoXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb29mTWVya2xlUGF0aChyb290LCBsZWFmLCBwYXRoLCBoYXNoTWV0aG9kID0gY29tcHV0ZVBlZGVyc2VuSGFzaCkge1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcm9vdCA9PT0gbGVhZjtcbiAgfVxuICBjb25zdCBbbmV4dCwgLi4ucmVzdF0gPSBwYXRoO1xuICByZXR1cm4gcHJvb2ZNZXJrbGVQYXRoKHJvb3QsIE1lcmtsZVRyZWUuaGFzaChsZWFmLCBuZXh0LCBoYXNoTWV0aG9kKSwgcmVzdCwgaGFzaE1ldGhvZCk7XG59XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbnZhciBwcmVzZXRUeXBlcyA9IHtcbiAgdTI1NjogSlNPTi5wYXJzZSgnW3sgXCJuYW1lXCI6IFwibG93XCIsIFwidHlwZVwiOiBcInUxMjhcIiB9LCB7IFwibmFtZVwiOiBcImhpZ2hcIiwgXCJ0eXBlXCI6IFwidTEyOFwiIH1dJyksXG4gIFRva2VuQW1vdW50OiBKU09OLnBhcnNlKFxuICAgICdbeyBcIm5hbWVcIjogXCJ0b2tlbl9hZGRyZXNzXCIsIFwidHlwZVwiOiBcIkNvbnRyYWN0QWRkcmVzc1wiIH0sIHsgXCJuYW1lXCI6IFwiYW1vdW50XCIsIFwidHlwZVwiOiBcInUyNTZcIiB9XSdcbiAgKSxcbiAgTmZ0SWQ6IEpTT04ucGFyc2UoXG4gICAgJ1t7IFwibmFtZVwiOiBcImNvbGxlY3Rpb25fYWRkcmVzc1wiLCBcInR5cGVcIjogXCJDb250cmFjdEFkZHJlc3NcIiB9LCB7IFwibmFtZVwiOiBcInRva2VuX2lkXCIsIFwidHlwZVwiOiBcInUyNTZcIiB9XSdcbiAgKVxufTtcbnZhciByZXZpc2lvbkNvbmZpZ3VyYXRpb24gPSB7XG4gIFtcIjFcIiAvKiBBY3RpdmUgKi9dOiB7XG4gICAgZG9tYWluOiBcIlN0YXJrbmV0RG9tYWluXCIsXG4gICAgaGFzaE1ldGhvZDogY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMsXG4gICAgaGFzaE1lcmtsZU1ldGhvZDogY29tcHV0ZVBvc2VpZG9uSGFzaCxcbiAgICBlc2NhcGVUeXBlU3RyaW5nOiAocykgPT4gYFwiJHtzfVwiYCxcbiAgICBwcmVzZXRUeXBlc1xuICB9LFxuICBbXCIwXCIgLyogTGVnYWN5ICovXToge1xuICAgIGRvbWFpbjogXCJTdGFya05ldERvbWFpblwiLFxuICAgIGhhc2hNZXRob2Q6IGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzLFxuICAgIGhhc2hNZXJrbGVNZXRob2Q6IGNvbXB1dGVQZWRlcnNlbkhhc2gsXG4gICAgZXNjYXBlVHlwZVN0cmluZzogKHMpID0+IHMsXG4gICAgcHJlc2V0VHlwZXM6IHt9XG4gIH1cbn07XG5mdW5jdGlvbiBieXRlQXJyYXlGcm9tU3RyaW5nMih0YXJnZXRTdHJpbmcpIHtcbiAgY29uc3Qgc2hvcnRTdHJpbmdzID0gc3BsaXRMb25nU3RyaW5nKHRhcmdldFN0cmluZyk7XG4gIGNvbnN0IHJlbWFpbmRlciA9IHNob3J0U3RyaW5nc1tzaG9ydFN0cmluZ3MubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHNob3J0U3RyaW5nc0VuY29kZWQgPSBzaG9ydFN0cmluZ3MubWFwKGVuY29kZVNob3J0U3RyaW5nKTtcbiAgY29uc3QgW3BlbmRpbmdXb3JkLCBwZW5kaW5nV29yZExlbmd0aF0gPSByZW1haW5kZXIgPT09IHZvaWQgMCB8fCByZW1haW5kZXIubGVuZ3RoID09PSAzMSA/IFtcIjB4MDBcIiwgMF0gOiBbc2hvcnRTdHJpbmdzRW5jb2RlZC5wb3AoKSwgcmVtYWluZGVyLmxlbmd0aF07XG4gIHJldHVybiB7XG4gICAgZGF0YTogc2hvcnRTdHJpbmdzRW5jb2RlZC5sZW5ndGggPT09IDAgPyBbXCIweDAwXCJdIDogc2hvcnRTdHJpbmdzRW5jb2RlZCxcbiAgICBwZW5kaW5nX3dvcmQ6IHBlbmRpbmdXb3JkLFxuICAgIHBlbmRpbmdfd29yZF9sZW46IHBlbmRpbmdXb3JkTGVuZ3RoXG4gIH07XG59XG5mdW5jdGlvbiBpZGVudGlmeVJldmlzaW9uKHsgdHlwZXMsIGRvbWFpbiB9KSB7XG4gIGlmIChyZXZpc2lvbkNvbmZpZ3VyYXRpb25bXCIxXCIgLyogQWN0aXZlICovXS5kb21haW4gaW4gdHlwZXMgJiYgZG9tYWluLnJldmlzaW9uID09PSBcIjFcIiAvKiBBY3RpdmUgKi8pXG4gICAgcmV0dXJuIFwiMVwiIC8qIEFjdGl2ZSAqLztcbiAgaWYgKHJldmlzaW9uQ29uZmlndXJhdGlvbltcIjBcIiAvKiBMZWdhY3kgKi9dLmRvbWFpbiBpbiB0eXBlcyAmJiAoZG9tYWluLnJldmlzaW9uID8/IFwiMFwiIC8qIExlZ2FjeSAqLykgPT09IFwiMFwiIC8qIExlZ2FjeSAqLylcbiAgICByZXR1cm4gXCIwXCIgLyogTGVnYWN5ICovO1xuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0SGV4KHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRvSGV4KHZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0b0hleChlbmNvZGVTaG9ydFN0cmluZyh2YWx1ZSkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQmlnTnVtYmVyaXNoOiAke3ZhbHVlfWApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVkRGF0YShkYXRhKSB7XG4gIGNvbnN0IHR5cGVkRGF0YSA9IGRhdGE7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHR5cGVkRGF0YS5tZXNzYWdlICYmIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSAmJiB0eXBlZERhdGEudHlwZXMgJiYgaWRlbnRpZnlSZXZpc2lvbih0eXBlZERhdGEpXG4gICk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGlzSGV4KHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogZ2V0U2VsZWN0b3JGcm9tTmFtZShzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBpc01lcmtsZVRyZWVUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUudHlwZSA9PT0gXCJtZXJrbGV0cmVlXCI7XG59XG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXModHlwZXMsIHR5cGUsIGRlcGVuZGVuY2llcyA9IFtdLCBjb250YWlucyA9IFwiXCIsIHJldmlzaW9uID0gXCIwXCIgLyogTGVnYWN5ICovKSB7XG4gIGlmICh0eXBlW3R5cGUubGVuZ3RoIC0gMV0gPT09IFwiKlwiKSB7XG4gICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgLTEpO1xuICB9IGVsc2UgaWYgKHJldmlzaW9uID09PSBcIjFcIiAvKiBBY3RpdmUgKi8pIHtcbiAgICBpZiAodHlwZSA9PT0gXCJlbnVtXCIpIHtcbiAgICAgIHR5cGUgPSBjb250YWlucztcbiAgICB9IGVsc2UgaWYgKHR5cGUubWF0Y2goL15cXCguKlxcKSQvKSkge1xuICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgfVxuICBpZiAoZGVwZW5kZW5jaWVzLmluY2x1ZGVzKHR5cGUpIHx8ICF0eXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0eXBlLFxuICAgIC4uLnR5cGVzW3R5cGVdLnJlZHVjZShcbiAgICAgIChwcmV2aW91cywgdCkgPT4gW1xuICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgLi4uZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0LnR5cGUsIHByZXZpb3VzLCB0LmNvbnRhaW5zLCByZXZpc2lvbikuZmlsdGVyKFxuICAgICAgICAgIChkZXBlbmRlbmN5KSA9PiAhcHJldmlvdXMuaW5jbHVkZXMoZGVwZW5kZW5jeSlcbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIFtdXG4gICAgKVxuICBdO1xufVxuZnVuY3Rpb24gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCkge1xuICBpZiAoY3R4LnBhcmVudCAmJiBjdHgua2V5KSB7XG4gICAgY29uc3QgcGFyZW50VHlwZSA9IHR5cGVzW2N0eC5wYXJlbnRdO1xuICAgIGNvbnN0IG1lcmtsZVR5cGUgPSBwYXJlbnRUeXBlLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY3R4LmtleSk7XG4gICAgY29uc3QgaXNNZXJrbGVUcmVlID0gaXNNZXJrbGVUcmVlVHlwZShtZXJrbGVUeXBlKTtcbiAgICBpZiAoIWlzTWVya2xlVHJlZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2N0eC5rZXl9IGlzIG5vdCBhIG1lcmtsZSB0cmVlYCk7XG4gICAgfVxuICAgIGlmIChtZXJrbGVUeXBlLmNvbnRhaW5zLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXJrbGUgdHJlZSBjb250YWluIHByb3BlcnR5IG11c3Qgbm90IGJlIGFuIGFycmF5IGJ1dCB3YXMgZ2l2ZW4gJHtjdHgua2V5fWApO1xuICAgIH1cbiAgICByZXR1cm4gbWVya2xlVHlwZS5jb250YWlucztcbiAgfVxuICByZXR1cm4gXCJyYXdcIjtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUodHlwZXMsIHR5cGUsIHJldmlzaW9uID0gXCIwXCIgLyogTGVnYWN5ICovKSB7XG4gIGNvbnN0IFtwcmltYXJ5LCAuLi5kZXBlbmRlbmNpZXNdID0gZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0eXBlLCB2b2lkIDAsIHZvaWQgMCwgcmV2aXNpb24pO1xuICBjb25zdCBuZXdUeXBlcyA9ICFwcmltYXJ5ID8gW10gOiBbcHJpbWFyeSwgLi4uZGVwZW5kZW5jaWVzLnNvcnQoKV07XG4gIGNvbnN0IGVzYyA9IHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0uZXNjYXBlVHlwZVN0cmluZztcbiAgcmV0dXJuIG5ld1R5cGVzLm1hcCgoZGVwZW5kZW5jeSkgPT4ge1xuICAgIGNvbnN0IGRlcGVuZGVuY3lFbGVtZW50cyA9IHR5cGVzW2RlcGVuZGVuY3ldLm1hcCgodCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IHQudHlwZSA9PT0gXCJlbnVtXCIgJiYgcmV2aXNpb24gPT09IFwiMVwiIC8qIEFjdGl2ZSAqLyA/IHQuY29udGFpbnMgOiB0LnR5cGU7XG4gICAgICBjb25zdCB0eXBlU3RyaW5nID0gdGFyZ2V0VHlwZS5tYXRjaCgvXlxcKC4qXFwpJC8pID8gYCgke3RhcmdldFR5cGUuc2xpY2UoMSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoKGUpID0+IGUgPyBlc2MoZSkgOiBlKS5qb2luKFwiLFwiKX0pYCA6IGVzYyh0YXJnZXRUeXBlKTtcbiAgICAgIHJldHVybiBgJHtlc2ModC5uYW1lKX06JHt0eXBlU3RyaW5nfWA7XG4gICAgfSk7XG4gICAgcmV0dXJuIGAke2VzYyhkZXBlbmRlbmN5KX0oJHtkZXBlbmRlbmN5RWxlbWVudHN9KWA7XG4gIH0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBnZXRUeXBlSGFzaCh0eXBlcywgdHlwZSwgcmV2aXNpb24gPSBcIjBcIiAvKiBMZWdhY3kgKi8pIHtcbiAgcmV0dXJuIGdldFNlbGVjdG9yRnJvbU5hbWUoZW5jb2RlVHlwZSh0eXBlcywgdHlwZSwgcmV2aXNpb24pKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVZhbHVlKHR5cGVzLCB0eXBlLCBkYXRhLCBjdHggPSB7fSwgcmV2aXNpb24gPSBcIjBcIiAvKiBMZWdhY3kgKi8pIHtcbiAgaWYgKHR5cGVzW3R5cGVdKSB7XG4gICAgcmV0dXJuIFt0eXBlLCBnZXRTdHJ1Y3RIYXNoKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbildO1xuICB9XG4gIGlmIChyZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzW3R5cGVdKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHR5cGUsXG4gICAgICBnZXRTdHJ1Y3RIYXNoKFxuICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzLFxuICAgICAgICB0eXBlLFxuICAgICAgICBkYXRhLFxuICAgICAgICByZXZpc2lvblxuICAgICAgKVxuICAgIF07XG4gIH1cbiAgaWYgKHR5cGUuZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgY29uc3QgaGFzaGVzID0gZGF0YS5tYXAoXG4gICAgICAoZW50cnkpID0+IGVuY29kZVZhbHVlKHR5cGVzLCB0eXBlLnNsaWNlKDAsIC0xKSwgZW50cnksIHZvaWQgMCwgcmV2aXNpb24pWzFdXG4gICAgKTtcbiAgICByZXR1cm4gW3R5cGUsIHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0uaGFzaE1ldGhvZChoYXNoZXMpXTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiZW51bVwiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFwiMVwiIC8qIEFjdGl2ZSAqLykge1xuICAgICAgICBjb25zdCBbdmFyaWFudEtleSwgdmFyaWFudERhdGFdID0gT2JqZWN0LmVudHJpZXMoZGF0YSlbMF07XG4gICAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSB0eXBlc1tjdHgucGFyZW50XVswXTtcbiAgICAgICAgY29uc3QgZW51bVR5cGUgPSB0eXBlc1twYXJlbnRUeXBlLmNvbnRhaW5zXTtcbiAgICAgICAgY29uc3QgdmFyaWFudFR5cGUgPSBlbnVtVHlwZS5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IHZhcmlhbnRLZXkpO1xuICAgICAgICBjb25zdCB2YXJpYW50SW5kZXggPSBlbnVtVHlwZS5pbmRleE9mKHZhcmlhbnRUeXBlKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFN1YnR5cGVzID0gdmFyaWFudFR5cGUudHlwZS5zbGljZSgxLCAtMSkuc3BsaXQoXCIsXCIpLm1hcCgoc3VidHlwZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoIXN1YnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcbiAgICAgICAgICBjb25zdCBzdWJ0eXBlRGF0YSA9IHZhcmlhbnREYXRhW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gZW5jb2RlVmFsdWUodHlwZXMsIHN1YnR5cGUsIHN1YnR5cGVEYXRhLCB2b2lkIDAsIHJldmlzaW9uKVsxXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoW3ZhcmlhbnRJbmRleCwgLi4uZW5jb2RlZFN1YnR5cGVzXSlcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcIm1lcmtsZXRyZWVcIjoge1xuICAgICAgY29uc3QgbWVya2xlVHJlZVR5cGUgPSBnZXRNZXJrbGVUcmVlVHlwZSh0eXBlcywgY3R4KTtcbiAgICAgIGNvbnN0IHN0cnVjdEhhc2hlcyA9IGRhdGEubWFwKChzdHJ1Y3QpID0+IHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVZhbHVlKHR5cGVzLCBtZXJrbGVUcmVlVHlwZSwgc3RydWN0LCB2b2lkIDAsIHJldmlzaW9uKVsxXTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyByb290IH0gPSBuZXcgTWVya2xlVHJlZShcbiAgICAgICAgc3RydWN0SGFzaGVzLFxuICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXJrbGVNZXRob2RcbiAgICAgICk7XG4gICAgICByZXR1cm4gW1wiZmVsdFwiLCByb290XTtcbiAgICB9XG4gICAgY2FzZSBcInNlbGVjdG9yXCI6IHtcbiAgICAgIHJldHVybiBbXCJmZWx0XCIsIHByZXBhcmVTZWxlY3RvcihkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBcIjFcIiAvKiBBY3RpdmUgKi8pIHtcbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gYnl0ZUFycmF5RnJvbVN0cmluZzIoZGF0YSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW1xuICAgICAgICAgIGJ5dGVBcnJheS5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi5ieXRlQXJyYXkuZGF0YSxcbiAgICAgICAgICBieXRlQXJyYXkucGVuZGluZ193b3JkLFxuICAgICAgICAgIGJ5dGVBcnJheS5wZW5kaW5nX3dvcmRfbGVuXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBbdHlwZSwgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKGVsZW1lbnRzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJmZWx0XCI6XG4gICAgY2FzZSBcImJvb2xcIjpcbiAgICBjYXNlIFwidTEyOFwiOlxuICAgIGNhc2UgXCJpMTI4XCI6XG4gICAgY2FzZSBcIkNvbnRyYWN0QWRkcmVzc1wiOlxuICAgIGNhc2UgXCJDbGFzc0hhc2hcIjpcbiAgICBjYXNlIFwidGltZXN0YW1wXCI6XG4gICAgY2FzZSBcInNob3J0c3RyaW5nXCI6XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBcIjFcIiAvKiBBY3RpdmUgKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0eXBlOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbmNvZGVEYXRhKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbiA9IFwiMFwiIC8qIExlZ2FjeSAqLykge1xuICBjb25zdCB0YXJnZXRUeXBlID0gdHlwZXNbdHlwZV0gPz8gcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5wcmVzZXRUeXBlc1t0eXBlXTtcbiAgY29uc3QgW3JldHVyblR5cGVzLCB2YWx1ZXNdID0gdGFyZ2V0VHlwZS5yZWR1Y2UoXG4gICAgKFt0cywgdnNdLCBmaWVsZCkgPT4ge1xuICAgICAgaWYgKGRhdGFbZmllbGQubmFtZV0gPT09IHZvaWQgMCB8fCBkYXRhW2ZpZWxkLm5hbWVdID09PSBudWxsICYmIGZpZWxkLnR5cGUgIT09IFwiZW51bVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGVuY29kZSBkYXRhOiBtaXNzaW5nIGRhdGEgZm9yICcke2ZpZWxkLm5hbWV9J2ApO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgY29uc3QgY3R4ID0geyBwYXJlbnQ6IHR5cGUsIGtleTogZmllbGQubmFtZSB9O1xuICAgICAgY29uc3QgW3QsIGVuY29kZWRWYWx1ZV0gPSBlbmNvZGVWYWx1ZSh0eXBlcywgZmllbGQudHlwZSwgdmFsdWUsIGN0eCwgcmV2aXNpb24pO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgWy4uLnRzLCB0XSxcbiAgICAgICAgWy4uLnZzLCBlbmNvZGVkVmFsdWVdXG4gICAgICBdO1xuICAgIH0sXG4gICAgW1tcImZlbHRcIl0sIFtnZXRUeXBlSGFzaCh0eXBlcywgdHlwZSwgcmV2aXNpb24pXV1cbiAgKTtcbiAgcmV0dXJuIFtyZXR1cm5UeXBlcywgdmFsdWVzXTtcbn1cbmZ1bmN0aW9uIGdldFN0cnVjdEhhc2godHlwZXMsIHR5cGUsIGRhdGEsIHJldmlzaW9uID0gXCIwXCIgLyogTGVnYWN5ICovKSB7XG4gIHJldHVybiByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoZW5jb2RlRGF0YSh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24pWzFdKTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YSwgYWNjb3VudCkge1xuICBpZiAoIXZhbGlkYXRlVHlwZWREYXRhKHR5cGVkRGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlZCBkYXRhIGRvZXMgbm90IG1hdGNoIEpTT04gc2NoZW1hXCIpO1xuICB9XG4gIGNvbnN0IHJldmlzaW9uID0gaWRlbnRpZnlSZXZpc2lvbih0eXBlZERhdGEpO1xuICBjb25zdCB7IGRvbWFpbiwgaGFzaE1ldGhvZCB9ID0gcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXTtcbiAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICBlbmNvZGVTaG9ydFN0cmluZyhcIlN0YXJrTmV0IE1lc3NhZ2VcIiksXG4gICAgZ2V0U3RydWN0SGFzaCh0eXBlZERhdGEudHlwZXMsIGRvbWFpbiwgdHlwZWREYXRhLmRvbWFpbiwgcmV2aXNpb24pLFxuICAgIGFjY291bnQsXG4gICAgZ2V0U3RydWN0SGFzaCh0eXBlZERhdGEudHlwZXMsIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSwgdHlwZWREYXRhLm1lc3NhZ2UsIHJldmlzaW9uKVxuICBdO1xuICByZXR1cm4gaGFzaE1ldGhvZChtZXNzYWdlKTtcbn1cblxuLy8gc3JjL3NpZ25lci9kZWZhdWx0LnRzXG52YXIgU2lnbmVyID0gY2xhc3Mge1xuICBwaztcbiAgY29uc3RydWN0b3IocGsgPSBzdGFya0N1cnZlLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSkge1xuICAgIHRoaXMucGsgPSBwayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBidWYyaGV4KHBrKSA6IHRvSGV4KHBrKTtcbiAgfVxuICBhc3luYyBnZXRQdWJLZXkoKSB7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuZ2V0U3RhcmtLZXkodGhpcy5wayk7XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UodHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIGFjY291bnRBZGRyZXNzKTtcbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgZGV0YWlscy5jYWlyb1ZlcnNpb24pO1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnblJhdyhtc2dIYXNoKTtcbiAgfVxuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGRldGFpbHMuY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzYWx0OiBkZXQuYWRkcmVzc1NhbHQsXG4gICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIGFzeW5jIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVjbGFyZVRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnblJhdyhtc2dIYXNoKSB7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lci9ldGhTaWduZXIudHNcbmltcG9ydCB7IHNlY3AyNTZrMSBhcyBzZWNwMjU2azEyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5cbi8vIHNyYy91dGlscy9ldGgudHNcbnZhciBldGhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZXRoX2V4cG9ydHMsIHtcbiAgZXRoUmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gZXRoUmFuZG9tUHJpdmF0ZUtleVxufSk7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmZ1bmN0aW9uIGV0aFJhbmRvbVByaXZhdGVLZXkoKSB7XG4gIHJldHVybiBzYW5pdGl6ZUhleChidWYyaGV4KHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpKTtcbn1cblxuLy8gc3JjL3NpZ25lci9ldGhTaWduZXIudHNcbnZhciBFdGhTaWduZXIgPSBjbGFzcyB7XG4gIHBrO1xuICAvLyBoZXggc3RyaW5nIHdpdGhvdXQgMHggYW5kIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICBjb25zdHJ1Y3RvcihwayA9IGV0aFJhbmRvbVByaXZhdGVLZXkoKSkge1xuICAgIHRoaXMucGsgPSBwayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyByZW1vdmVIZXhQcmVmaXgoc2FuaXRpemVIZXgoYnVmMmhleChwaykpKSA6IHJlbW92ZUhleFByZWZpeChzYW5pdGl6ZUhleCh0b0hleChwaykpKTtcbiAgfVxuICBhc3luYyBnZXRQdWJLZXkoKSB7XG4gICAgcmV0dXJuIGFkZEhleFByZWZpeChidWYyaGV4KHNlY3AyNTZrMTIuZ2V0UHVibGljS2V5KHRoaXMucGspKSk7XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UodHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIGFjY291bnRBZGRyZXNzKTtcbiAgICByZXR1cm4gc2VjcDI1NmsxMi5zaWduKHJlbW92ZUhleFByZWZpeChzYW5pdGl6ZUhleChtc2dIYXNoKSksIHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgZGV0YWlscy5jYWlyb1ZlcnNpb24pO1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlY3AyNTZrMTIuc2lnbihyZW1vdmVIZXhQcmVmaXgoc2FuaXRpemVIZXgobXNnSGFzaCkpLCB0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGRldGFpbHMuY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzYWx0OiBkZXQuYWRkcmVzc1NhbHQsXG4gICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VjcDI1NmsxMi5zaWduKHJlbW92ZUhleFByZWZpeChzYW5pdGl6ZUhleChtc2dIYXNoKSksIHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVjbGFyZVRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIHJldHVybiBzZWNwMjU2azEyLnNpZ24ocmVtb3ZlSGV4UHJlZml4KHNhbml0aXplSGV4KG1zZ0hhc2gpKSwgdGhpcy5wayk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9ldmVudHMudHNcbmZ1bmN0aW9uIHBhcnNlVURDRXZlbnQodHhSZWNlaXB0KSB7XG4gIGlmICghdHhSZWNlaXB0LmV2ZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVEQyBlbWl0dGVkIGV2ZW50IGlzIGVtcHR5XCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gdHhSZWNlaXB0LmV2ZW50cy5maW5kKFxuICAgIChpdCkgPT4gY2xlYW5IZXgoaXQuZnJvbV9hZGRyZXNzKSA9PT0gY2xlYW5IZXgoVURDLkFERFJFU1MpXG4gICkgfHwge1xuICAgIGRhdGE6IFtdXG4gIH07XG4gIHJldHVybiB7XG4gICAgdHJhbnNhY3Rpb25faGFzaDogdHhSZWNlaXB0LnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgY29udHJhY3RfYWRkcmVzczogZXZlbnQuZGF0YVswXSxcbiAgICBhZGRyZXNzOiBldmVudC5kYXRhWzBdLFxuICAgIGRlcGxveWVyOiBldmVudC5kYXRhWzFdLFxuICAgIHVuaXF1ZTogZXZlbnQuZGF0YVsyXSxcbiAgICBjbGFzc0hhc2g6IGV2ZW50LmRhdGFbM10sXG4gICAgY2FsbGRhdGFfbGVuOiBldmVudC5kYXRhWzRdLFxuICAgIGNhbGxkYXRhOiBldmVudC5kYXRhLnNsaWNlKDUsIDUgKyBwYXJzZUludChldmVudC5kYXRhWzRdLCAxNikpLFxuICAgIHNhbHQ6IGV2ZW50LmRhdGFbZXZlbnQuZGF0YS5sZW5ndGggLSAxXVxuICB9O1xufVxuXG4vLyBzcmMvYWNjb3VudC9kZWZhdWx0LnRzXG52YXIgQWNjb3VudCA9IGNsYXNzIGV4dGVuZHMgUnBjUHJvdmlkZXIyIHtcbiAgc2lnbmVyO1xuICBhZGRyZXNzO1xuICBjYWlyb1ZlcnNpb247XG4gIHRyYW5zYWN0aW9uVmVyc2lvbjtcbiAgY29uc3RydWN0b3IocHJvdmlkZXJPck9wdGlvbnMsIGFkZHJlc3MsIHBrT3JTaWduZXIsIGNhaXJvVmVyc2lvbiwgdHJhbnNhY3Rpb25WZXJzaW9uID0gXCIweDJcIiAvKiBWMiAqLykge1xuICAgIHN1cGVyKHByb3ZpZGVyT3JPcHRpb25zKTtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5zaWduZXIgPSB0eXBlb2YgcGtPclNpZ25lciA9PT0gXCJzdHJpbmdcIiB8fCBwa09yU2lnbmVyIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG5ldyBTaWduZXIocGtPclNpZ25lcikgOiBwa09yU2lnbmVyO1xuICAgIGlmIChjYWlyb1ZlcnNpb24pIHtcbiAgICAgIHRoaXMuY2Fpcm9WZXJzaW9uID0gY2Fpcm9WZXJzaW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNhY3Rpb25WZXJzaW9uID0gdHJhbnNhY3Rpb25WZXJzaW9uO1xuICB9XG4gIC8vIHByb3ZpZGVkIHZlcnNpb24gb3IgY29udHJhY3QgYmFzZWQgcHJlZmVycmVkIHRyYW5zYWN0aW9uVmVyc2lvblxuICBnZXRQcmVmZXJyZWRWZXJzaW9uKHR5cGUxMiwgdHlwZTMpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvblZlcnNpb24gPT09IFwiMHgzXCIgLyogVjMgKi8pXG4gICAgICByZXR1cm4gdHlwZTM7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb25WZXJzaW9uID09PSBcIjB4MlwiIC8qIFYyICovKVxuICAgICAgcmV0dXJuIHR5cGUxMjtcbiAgICByZXR1cm4gXCIweDNcIiAvKiBWMyAqLztcbiAgfVxuICBhc3luYyBnZXROb25jZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0Tm9uY2VGb3JBZGRyZXNzKHRoaXMuYWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXROb25jZVNhZmUobm9uY2UpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRvQmlnSW50KG5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiAwbjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgQ2Fpcm8gdmVyc2lvbiBmcm9tIHRoZSBuZXR3b3JrIGFuZCBzZXRzIGBjYWlyb1ZlcnNpb25gIGlmIG5vdCBhbHJlYWR5IHNldCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIGNsYXNzSGFzaCBpZiBwcm92aWRlZCBkZXRlY3RzIENhaXJvIHZlcnNpb24gZnJvbSBjbGFzc0hhc2gsIG90aGVyd2lzZSBmcm9tIHRoZSBhY2NvdW50IGFkZHJlc3NcbiAgICovXG4gIGFzeW5jIGdldENhaXJvVmVyc2lvbihjbGFzc0hhc2gpIHtcbiAgICBpZiAoIXRoaXMuY2Fpcm9WZXJzaW9uKSB7XG4gICAgICBjb25zdCB7IGNhaXJvIH0gPSBjbGFzc0hhc2ggPyBhd2FpdCBzdXBlci5nZXRDb250cmFjdFZlcnNpb24odm9pZCAwLCBjbGFzc0hhc2gpIDogYXdhaXQgc3VwZXIuZ2V0Q29udHJhY3RWZXJzaW9uKHRoaXMuYWRkcmVzcyk7XG4gICAgICB0aGlzLmNhaXJvVmVyc2lvbiA9IGNhaXJvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWlyb1ZlcnNpb247XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVGZWUoY2FsbHMsIGVzdGltYXRlRmVlRGV0YWlscyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIGVzdGltYXRlRmVlRGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHsgbm9uY2U6IHByb3ZpZGVkTm9uY2UsIGJsb2NrSWRlbnRpZmllciwgdmVyc2lvbjogcHJvdmlkZWRWZXJzaW9uIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IEFycmF5LmlzQXJyYXkoY2FsbHMpID8gY2FsbHMgOiBbY2FsbHNdO1xuICAgIGNvbnN0IG5vbmNlID0gdG9CaWdJbnQocHJvdmlkZWROb25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCIgLyogRjEgKi8sIFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIiAvKiBGMyAqLyksXG4gICAgICB0b0ZlZVZlcnNpb24ocHJvdmlkZWRWZXJzaW9uKVxuICAgICk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgIHZlcnNpb24sXG4gICAgICBjaGFpbklkLFxuICAgICAgY2Fpcm9WZXJzaW9uOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpXG4gICAgfTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24odHJhbnNhY3Rpb25zLCBzaWduZXJEZXRhaWxzKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0SW52b2tlRXN0aW1hdGVGZWUoXG4gICAgICB7IC4uLmludm9jYXRpb24gfSxcbiAgICAgIHsgLi4udjNEZXRhaWxzKGRldGFpbHMpLCB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgZGV0YWlscy5za2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRGVjbGFyZUZlZShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7IGJsb2NrSWRlbnRpZmllciwgbm9uY2U6IHByb3ZpZGVkTm9uY2UsIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbiB9ID0gZGV0YWlscztcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHByb3ZpZGVkTm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAhaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkgPyBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCIgLyogRjEgKi8gOiB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMlwiIC8qIEYyICovLCBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzXCIgLyogRjMgKi8pLFxuICAgICAgdG9GZWVWZXJzaW9uKHByb3ZpZGVkVmVyc2lvbilcbiAgICApO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZChwYXlsb2FkLCB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICBub25jZSxcbiAgICAgIGNoYWluSWQsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDBcbiAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXJcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RGVjbGFyZUVzdGltYXRlRmVlKFxuICAgICAgZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24sXG4gICAgICB7IC4uLnYzRGV0YWlscyhkZXRhaWxzKSwgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGRldGFpbHMuc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUFjY291bnREZXBsb3lGZWUoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGNvbnRyYWN0QWRkcmVzc1xuICB9LCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7IGJsb2NrSWRlbnRpZmllciwgdmVyc2lvbjogcHJvdmlkZWRWZXJzaW9uIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCIgLyogRjEgKi8sIFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIiAvKiBGMyAqLyksXG4gICAgICB0b0ZlZVZlcnNpb24ocHJvdmlkZWRWZXJzaW9uKVxuICAgICk7XG4gICAgY29uc3Qgbm9uY2UgPSBaRVJPO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEFjY291bnREZXBsb3lQYXlsb2FkKFxuICAgICAgeyBjbGFzc0hhc2gsIGFkZHJlc3NTYWx0LCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBjb250cmFjdEFkZHJlc3MgfSxcbiAgICAgIHtcbiAgICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgICBub25jZSxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDBcbiAgICAgICAgLy8gdW51c2VkIHBhcmFtZXRlcixcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBzdXBlci5nZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUoXG4gICAgICB7IC4uLnBheWxvYWQgfSxcbiAgICAgIHsgLi4udjNEZXRhaWxzKGRldGFpbHMpLCB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgZGV0YWlscy5za2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRGVwbG95RmVlKHBheWxvYWQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IGNhbGxzID0gdGhpcy5idWlsZFVEQ0NvbnRyYWN0UGF5bG9hZChwYXlsb2FkKTtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZUludm9rZUZlZShjYWxscywgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7IG5vbmNlLCBibG9ja0lkZW50aWZpZXIsIHZlcnNpb24gfSA9IGRldGFpbHM7XG4gICAgY29uc3QgYWNjb3VudEludm9jYXRpb25zID0gYXdhaXQgdGhpcy5hY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICB2ZXJzaW9uczogW1xuICAgICAgICBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCIgLyogRjEgKi8sXG4gICAgICAgIC8vIG5vbi1zaWVycmFcbiAgICAgICAgdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJcIiAvKiBGMiAqLywgXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM1wiIC8qIEYzICovKSxcbiAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgIClcbiAgICAgICAgLy8gc2llcnJhXG4gICAgICBdLFxuICAgICAgbm9uY2UsXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RXN0aW1hdGVGZWVCdWxrKGFjY291bnRJbnZvY2F0aW9ucywge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlOiBkZXRhaWxzLnNraXBWYWxpZGF0ZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHsgbm9uY2UsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlLCBza2lwRXhlY3V0ZSwgdmVyc2lvbiB9ID0gZGV0YWlscztcbiAgICBjb25zdCBhY2NvdW50SW52b2NhdGlvbnMgPSBhd2FpdCB0aGlzLmFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkoaW52b2NhdGlvbnMsIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIHZlcnNpb25zOiBbXG4gICAgICAgIFwiMHgxXCIgLyogVjEgKi8sXG4gICAgICAgIC8vIG5vbi1zaWVycmFcbiAgICAgICAgdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKFwiMHgyXCIgLyogVjIgKi8sIFwiMHgzXCIgLyogVjMgKi8pLFxuICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIG5vbmNlLFxuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHN1cGVyLmdldFNpbXVsYXRlVHJhbnNhY3Rpb24oYWNjb3VudEludm9jYXRpb25zLCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGUsXG4gICAgICBza2lwRXhlY3V0ZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGV4ZWN1dGUoY2FsbHMsIGFiaXMgPSB2b2lkIDAsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IEFycmF5LmlzQXJyYXkoY2FsbHMpID8gY2FsbHMgOiBbY2FsbHNdO1xuICAgIGNvbnN0IG5vbmNlID0gdG9CaWdJbnQoZGV0YWlscy5ub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihcIjB4MVwiIC8qIFYxICovLCBcIjB4M1wiIC8qIFYzICovKSxcbiAgICAgIC8vIFRPRE86IGRvZXMgdGhpcyBkZXBlbmQgb24gY2Fpcm8gdmVyc2lvbiA/XG4gICAgICBkZXRhaWxzLnZlcnNpb25cbiAgICApO1xuICAgIGNvbnN0IGVzdGltYXRlID0gYXdhaXQgdGhpcy5nZXRVbml2ZXJzYWxTdWdnZXN0ZWRGZWUoXG4gICAgICB2ZXJzaW9uLFxuICAgICAgeyB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLywgcGF5bG9hZDogY2FsbHMgfSxcbiAgICAgIHtcbiAgICAgICAgLi4uZGV0YWlscyxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGUucmVzb3VyY2VCb3VuZHMsXG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIG1heEZlZTogZXN0aW1hdGUubWF4RmVlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGNoYWluSWQsXG4gICAgICBjYWlyb1ZlcnNpb246IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKClcbiAgICB9O1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIHNpZ25lckRldGFpbHMsIGFiaXMpO1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgcmV0dXJuIHRoaXMuaW52b2tlRnVuY3Rpb24oXG4gICAgICB7IGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLCBjYWxsZGF0YSwgc2lnbmF0dXJlIH0sXG4gICAgICB7XG4gICAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgICBub25jZSxcbiAgICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGaXJzdCBjaGVjayBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkLCBpZiBub3QgZGVjbGFyZSBpdFxuICAgKiBJZiBjb250cmFjdCBhbHJlYWR5IGRlY2xhcmVkIHJldHVybmVkIHRyYW5zYWN0aW9uX2hhc2ggaXMgJycuXG4gICAqIE1ldGhvZCB3aWxsIHBhc3MgZXZlbiBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbnNEZXRhaWwgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZGVjbGFyZUlmTm90KHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmUocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IFwiXCIsXG4gICAgICBjbGFzc19oYXNoOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGVjbGFyZShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RQYXlsb2FkID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IHsgbm9uY2UsIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbiB9ID0gZGV0YWlscztcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAhaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkgPyBcIjB4MVwiIC8qIFYxICovIDogdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKFwiMHgyXCIgLyogVjIgKi8sIFwiMHgzXCIgLyogVjMgKi8pLFxuICAgICAgcHJvdmlkZWRWZXJzaW9uXG4gICAgKTtcbiAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKFxuICAgICAgdmVyc2lvbixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLyxcbiAgICAgICAgcGF5bG9hZDogZGVjbGFyZUNvbnRyYWN0UGF5bG9hZFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLi4uZGV0YWlscyxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZGVjbGFyZURldGFpbHMgPSB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGUucmVzb3VyY2VCb3VuZHMsXG4gICAgICBtYXhGZWU6IGVzdGltYXRlLm1heEZlZSxcbiAgICAgIG5vbmNlOiB0b0JpZ0ludChub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGNoYWluSWQ6IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpLFxuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKFxuICAgICAgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCxcbiAgICAgIGRlY2xhcmVEZXRhaWxzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5kZWNsYXJlQ29udHJhY3QoZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24sIGRlY2xhcmVEZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZXBsb3kocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgcGFyYW1zID0gW10uY29uY2F0KHBheWxvYWQpLm1hcCgoaXQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICBzYWx0LFxuICAgICAgICB1bmlxdWUgPSB0cnVlLFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW11cbiAgICAgIH0gPSBpdDtcbiAgICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgICBjb25zdCBkZXBsb3lTYWx0ID0gc2FsdCA/PyByYW5kb21BZGRyZXNzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxsOiB7XG4gICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgICBlbnRyeXBvaW50OiBVREMuRU5UUllQT0lOVCxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgICAgZGVwbG95U2FsdCxcbiAgICAgICAgICAgIHRvQ2Fpcm9Cb29sKHVuaXF1ZSksXG4gICAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgICAgLi4uY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBhZGRyZXNzOiBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChcbiAgICAgICAgICB1bmlxdWUgPyBzdGFya0N1cnZlLnBlZGVyc2VuKHRoaXMuYWRkcmVzcywgZGVwbG95U2FsdCkgOiBkZXBsb3lTYWx0LFxuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEsXG4gICAgICAgICAgdW5pcXVlID8gVURDLkFERFJFU1MgOiAwXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2FsbHMgPSBwYXJhbXMubWFwKChpdCkgPT4gaXQuY2FsbCk7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gcGFyYW1zLm1hcCgoaXQpID0+IGl0LmFkZHJlc3MpO1xuICAgIGNvbnN0IGludm9rZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlKGNhbGxzLCB2b2lkIDAsIGRldGFpbHMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pbnZva2VSZXNwb25zZSxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGFkZHJlc3Nlc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZGVwbG95Q29udHJhY3QocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgZGVwbG95VHggPSBhd2FpdCB0aGlzLmRlcGxveShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICBjb25zdCB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbihkZXBsb3lUeC50cmFuc2FjdGlvbl9oYXNoKTtcbiAgICByZXR1cm4gcGFyc2VVRENFdmVudCh0eFJlY2VpcHQpO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVBbmREZXBsb3kocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgeyBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzYWx0LCB1bmlxdWUgfSA9IHBheWxvYWQ7XG4gICAgbGV0IGRlY2xhcmUgPSBhd2FpdCB0aGlzLmRlY2xhcmVJZk5vdChwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICBpZiAoZGVjbGFyZS50cmFuc2FjdGlvbl9oYXNoICE9PSBcIlwiKSB7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKGRlY2xhcmUudHJhbnNhY3Rpb25faGFzaCk7XG4gICAgICBkZWNsYXJlID0geyAuLi5kZWNsYXJlLCAuLi50eCB9O1xuICAgIH1cbiAgICBjb25zdCBkZXBsb3kgPSBhd2FpdCB0aGlzLmRlcGxveUNvbnRyYWN0KFxuICAgICAgeyBjbGFzc0hhc2g6IGRlY2xhcmUuY2xhc3NfaGFzaCwgc2FsdCwgdW5pcXVlLCBjb25zdHJ1Y3RvckNhbGxkYXRhIH0sXG4gICAgICBkZXRhaWxzXG4gICAgKTtcbiAgICByZXR1cm4geyBkZWNsYXJlOiB7IC4uLmRlY2xhcmUgfSwgZGVwbG95IH07XG4gIH1cbiAgZGVwbG95U2VsZiA9IHRoaXMuZGVwbG95QWNjb3VudDtcbiAgYXN5bmMgZGVwbG95QWNjb3VudCh7XG4gICAgY2xhc3NIYXNoLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXSxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29udHJhY3RBZGRyZXNzOiBwcm92aWRlZENvbnRyYWN0QWRkcmVzc1xuICB9LCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oXCIweDFcIiAvKiBWMSAqLywgXCIweDNcIiAvKiBWMyAqLyksXG4gICAgICBkZXRhaWxzLnZlcnNpb25cbiAgICApO1xuICAgIGNvbnN0IG5vbmNlID0gWkVSTztcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gcHJvdmlkZWRDb250cmFjdEFkZHJlc3MgPz8gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goYWRkcmVzc1NhbHQsIGNsYXNzSGFzaCwgY29tcGlsZWRDYWxsZGF0YSwgMCk7XG4gICAgY29uc3QgZXN0aW1hdGUgPSBhd2FpdCB0aGlzLmdldFVuaXZlcnNhbFN1Z2dlc3RlZEZlZShcbiAgICAgIHZlcnNpb24sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGV0YWlsc1xuICAgICk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbih7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjaGFpbklkLFxuICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbm9uY2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kZXBsb3lBY2NvdW50Q29udHJhY3QoXG4gICAgICB7IGNsYXNzSGFzaCwgYWRkcmVzc1NhbHQsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNpZ25hdHVyZSB9LFxuICAgICAge1xuICAgICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICAgIG5vbmNlLFxuICAgICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGUucmVzb3VyY2VCb3VuZHMsXG4gICAgICAgIG1heEZlZTogZXN0aW1hdGUubWF4RmVlLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduZXIuc2lnbk1lc3NhZ2UodHlwZWREYXRhLCB0aGlzLmFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIGhhc2hNZXNzYWdlKHR5cGVkRGF0YSkge1xuICAgIHJldHVybiBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgYXN5bmMgdmVyaWZ5TWVzc2FnZUhhc2goaGFzaCwgc2lnbmF0dXJlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNhbGxDb250cmFjdCh7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICBlbnRyeXBvaW50OiBcImlzVmFsaWRTaWduYXR1cmVcIixcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoe1xuICAgICAgICAgIGhhc2g6IHRvQmlnSW50KGhhc2gpLnRvU3RyaW5nKCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBmb3JtYXRTaWduYXR1cmUoc2lnbmF0dXJlKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoQmlnSW50KHJlc3BbMF0pID09PSAwbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChbXCJhcmdlbnQvaW52YWxpZC1zaWduYXR1cmVcIiwgXCJpcyBpbnZhbGlkLCB3aXRoIHJlc3BlY3QgdG8gdGhlIHB1YmxpYyBrZXlcIl0uc29tZShcbiAgICAgICAgKGVyck1lc3NhZ2UpID0+IGVyci5tZXNzYWdlLmluY2x1ZGVzKGVyck1lc3NhZ2UpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKGBTaWduYXR1cmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgaXMgcmVqZWN0ZWQgYnkgdGhlIG5ldHdvcms6ICR7ZXJyfWApO1xuICAgIH1cbiAgfVxuICBhc3luYyB2ZXJpZnlNZXNzYWdlKHR5cGVkRGF0YSwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuaGFzaE1lc3NhZ2UodHlwZWREYXRhKTtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlNZXNzYWdlSGFzaChoYXNoLCBzaWduYXR1cmUpO1xuICB9XG4gIC8qXG4gICAqIFN1cHBvcnQgbWV0aG9kc1xuICAgKi9cbiAgYXN5bmMgZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKHZlcnNpb24sIHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IG1heEZlZSA9IDA7XG4gICAgbGV0IHJlc291cmNlQm91bmRzID0gZXN0aW1hdGVGZWVUb0JvdW5kcyhaRVJPKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gXCIweDNcIiAvKiBWMyAqLykge1xuICAgICAgcmVzb3VyY2VCb3VuZHMgPSBkZXRhaWxzLnJlc291cmNlQm91bmRzID8/IChhd2FpdCB0aGlzLmdldFN1Z2dlc3RlZEZlZSh7IHR5cGUsIHBheWxvYWQgfSwgZGV0YWlscykpLnJlc291cmNlQm91bmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhGZWUgPSBkZXRhaWxzLm1heEZlZSA/PyAoYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRGZWUoeyB0eXBlLCBwYXlsb2FkIH0sIGRldGFpbHMpKS5zdWdnZXN0ZWRNYXhGZWU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtYXhGZWUsXG4gICAgICByZXNvdXJjZUJvdW5kc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZ2V0U3VnZ2VzdGVkRmVlKHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IGZlZUVzdGltYXRlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlSW52b2tlRmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlRGVjbGFyZUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlQWNjb3VudERlcGxveUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVQTE9ZXCIgLyogREVQTE9ZICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVEZXBsb3lGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSB7XG4gICAgICAgICAgZ2FzX2NvbnN1bWVkOiAwbixcbiAgICAgICAgICBnYXNfcHJpY2U6IDBuLFxuICAgICAgICAgIG92ZXJhbGxfZmVlOiBaRVJPLFxuICAgICAgICAgIHVuaXQ6IFwiRlJJXCIsXG4gICAgICAgICAgc3VnZ2VzdGVkTWF4RmVlOiBaRVJPLFxuICAgICAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZUZlZVRvQm91bmRzKFpFUk8pXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmVlRXN0aW1hdGU7XG4gIH1cbiAgYXN5bmMgYnVpbGRJbnZvY2F0aW9uKGNhbGwsIGRldGFpbHMpIHtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YShjYWxsLCBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduVHJhbnNhY3Rpb24oY2FsbCwgZGV0YWlscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgY2FsbGRhdGEsXG4gICAgICBzaWduYXR1cmVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGJ1aWxkRGVjbGFyZVBheWxvYWQocGF5bG9hZCwgZGV0YWlscykge1xuICAgIGNvbnN0IHsgY2xhc3NIYXNoLCBjb250cmFjdCwgY29tcGlsZWRDbGFzc0hhc2ggfSA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICBjb25zdCBjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCA9IHBhcnNlQ29udHJhY3QoY29udHJhY3QpO1xuICAgIGlmICh0eXBlb2YgY29tcGlsZWRDbGFzc0hhc2ggPT09IFwidW5kZWZpbmVkXCIgJiYgKGRldGFpbHMudmVyc2lvbiA9PT0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM1wiIC8qIEYzICovIHx8IGRldGFpbHMudmVyc2lvbiA9PT0gXCIweDNcIiAvKiBWMyAqLykpIHtcbiAgICAgIHRocm93IEVycm9yKFwiVjMgVHJhbnNhY3Rpb24gd29yayB3aXRoIENhaXJvMSBDb250cmFjdHMgYW5kIHJlcXVpcmUgY29tcGlsZWRDbGFzc0hhc2hcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oe1xuICAgICAgLi4uZGV0YWlscyxcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgLy8gVE9ETzogVFMgTmVrdXppIGRhIHYyIG5lbW9yYSBpbWF0IGEgdjMgbW9yYSBpIGRhIGplIHRocm92YW5vIGFrbyBuaWplIGRlZmluaXJhblxuICAgICAgc2VuZGVyQWRkcmVzczogZGV0YWlscy53YWxsZXRBZGRyZXNzXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbmRlckFkZHJlc3M6IGRldGFpbHMud2FsbGV0QWRkcmVzcyxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGNvbnRyYWN0OiBjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoXG4gICAgfTtcbiAgfVxuICBhc3luYyBidWlsZEFjY291bnREZXBsb3lQYXlsb2FkKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXSxcbiAgICBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzXG4gIH0sIGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBwcm92aWRlZENvbnRyYWN0QWRkcmVzcyA/PyBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChhZGRyZXNzU2FsdCwgY2xhc3NIYXNoLCBjb21waWxlZENhbGxkYXRhLCAwKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICAgIC4uLmRldGFpbHMsXG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGFcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuICBidWlsZFVEQ0NvbnRyYWN0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgY29uc3QgY2FsbHMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIHNhbHQgPSBcIjBcIixcbiAgICAgICAgdW5pcXVlID0gdHJ1ZSxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdXG4gICAgICB9ID0gaXQ7XG4gICAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIHNhbHQsXG4gICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBjYWxscztcbiAgfVxuICBhc3luYyBhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgeyBub25jZSwgYmxvY2tJZGVudGlmaWVyIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IHNhZmVOb25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VTYWZlKG5vbmNlKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgdmVyc2lvbnMgPSBkZXRhaWxzLnZlcnNpb25zLm1hcCgoaXQpID0+IHRvVHJhbnNhY3Rpb25WZXJzaW9uKGl0KSk7XG4gICAgY29uc3QgdHgwUGF5bG9hZCA9IFwicGF5bG9hZFwiIGluIGludm9jYXRpb25zWzBdID8gaW52b2NhdGlvbnNbMF0ucGF5bG9hZCA6IGludm9jYXRpb25zWzBdO1xuICAgIGNvbnN0IGNhaXJvVmVyc2lvbiA9IGludm9jYXRpb25zWzBdLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyA/IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKHR4MFBheWxvYWQuY2xhc3NIYXNoKSA6IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgW10uY29uY2F0KGludm9jYXRpb25zKS5tYXAoYXN5bmMgKHRyYW5zYWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB0eFBheWxvYWQgPSBcInBheWxvYWRcIiBpbiB0cmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnBheWxvYWQgOiB0cmFuc2FjdGlvbjtcbiAgICAgICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0JpZ0ludChOdW1iZXIoc2FmZU5vbmNlKSArIGluZGV4KSxcbiAgICAgICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICBjYWlyb1ZlcnNpb24sXG4gICAgICAgICAgdmVyc2lvbjogXCJcIlxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21tb24gPSB7XG4gICAgICAgICAgdHlwZTogdHJhbnNhY3Rpb24udHlwZSxcbiAgICAgICAgICBub25jZTogdG9CaWdJbnQoTnVtYmVyKHNhZmVOb25jZSkgKyBpbmRleCksXG4gICAgICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgICAgIHZlcnNpb246IFwiXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvblggPSByZWR1Y2VWMih2ZXJzaW9uc1sxXSk7XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29tbW9uLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24oXG4gICAgICAgICAgICBbXS5jb25jYXQodHhQYXlsb2FkKSxcbiAgICAgICAgICAgIHNpZ25lckRldGFpbHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJERVBMT1lcIiAvKiBERVBMT1kgKi8pIHtcbiAgICAgICAgICBjb25zdCB2ZXJzaW9uWCA9IHJlZHVjZVYyKHZlcnNpb25zWzFdKTtcbiAgICAgICAgICBzaWduZXJEZXRhaWxzLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb21tb24udmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbnN0IGNhbGxzID0gdGhpcy5idWlsZFVEQ0NvbnRyYWN0UGF5bG9hZCh0eFBheWxvYWQpO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkSW52b2NhdGlvbihjYWxscywgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqL1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8pIHtcbiAgICAgICAgICBjb25zdCB2ZXJzaW9uWCA9ICFpc1NpZXJyYSh0eFBheWxvYWQuY29udHJhY3QpID8gdmVyc2lvbnNbMF0gOiB2ZXJzaW9uc1sxXTtcbiAgICAgICAgICBzaWduZXJEZXRhaWxzLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb21tb24udmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkRGVjbGFyZVBheWxvYWQodHhQYXlsb2FkLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLykge1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25YID0gcmVkdWNlVjIodmVyc2lvbnNbMV0pO1xuICAgICAgICAgIHNpZ25lckRldGFpbHMudmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbW1vbi52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZCh0eFBheWxvYWQsIHNpZ25lckRldGFpbHMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcihgYWNjb3VudEludm9jYXRpb25zRmFjdG9yeTogdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0cmFuc2FjdGlvbn1gKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcyA9IHRoaXMuYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBzdXBlci5nZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbn07XG5cbi8vIHNyYy9hY2NvdW50L2ludGVyZmFjZS50c1xudmFyIEFjY291bnRJbnRlcmZhY2UgPSBjbGFzcyBleHRlbmRzIFByb3ZpZGVySW50ZXJmYWNlIHtcbn07XG5cbi8vIHNyYy91dGlscy9ldmVudHMvaW5kZXgudHNcbnZhciBldmVudHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZXZlbnRzX2V4cG9ydHMsIHtcbiAgZ2V0QWJpRXZlbnRzOiAoKSA9PiBnZXRBYmlFdmVudHMsXG4gIHBhcnNlRXZlbnRzOiAoKSA9PiBwYXJzZUV2ZW50c1xufSk7XG5mdW5jdGlvbiBnZXRBYmlFdmVudHMoYWJpKSB7XG4gIHJldHVybiBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJldmVudFwiICYmIChhYmlFbnRyeS5zaXplIHx8IGFiaUVudHJ5LmtpbmQgIT09IFwiZW51bVwiKSkucmVkdWNlKChhY2MsIGFiaUVudHJ5KSA9PiB7XG4gICAgY29uc3QgZW50cnlOYW1lID0gYWJpRW50cnkubmFtZS5zbGljZShhYmlFbnRyeS5uYW1lLmxhc3RJbmRleE9mKFwiOlwiKSArIDEpO1xuICAgIGNvbnN0IGFiaUVudHJ5TW9kID0geyAuLi5hYmlFbnRyeSB9O1xuICAgIGFiaUVudHJ5TW9kLm5hbWUgPSBlbnRyeU5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIFthZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoZW50cnlOYW1lKSkudG9TdHJpbmcoMTYpKV06IGFiaUVudHJ5TW9kXG4gICAgfTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gcGFyc2VFdmVudHMocHJvdmlkZXJSZWNlaXZlZEV2ZW50cywgYWJpRXZlbnRzLCBhYmlTdHJ1Y3RzLCBhYmlFbnVtcykge1xuICBjb25zdCByZXQgPSBwcm92aWRlclJlY2VpdmVkRXZlbnRzLmZsYXQoKS5yZWR1Y2UoKGFjYywgcmVjRXZlbnQpID0+IHtcbiAgICBjb25zdCBhYmlFdmVudCA9IGFiaUV2ZW50c1tyZWNFdmVudC5rZXlzWzBdXTtcbiAgICBpZiAoIWFiaUV2ZW50KSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRFdmVudCA9IHt9O1xuICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdID0ge307XG4gICAgcmVjRXZlbnQua2V5cy5zaGlmdCgpO1xuICAgIGNvbnN0IGtleXNJdGVyID0gcmVjRXZlbnQua2V5c1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgZGF0YUl0ZXIgPSByZWNFdmVudC5kYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBhYmlFdmVudEtleXMgPSBhYmlFdmVudC5tZW1iZXJzPy5maWx0ZXIoKGl0KSA9PiBpdC5raW5kID09PSBcImtleVwiKSB8fCBhYmlFdmVudC5rZXlzO1xuICAgIGNvbnN0IGFiaUV2ZW50RGF0YSA9IGFiaUV2ZW50Lm1lbWJlcnM/LmZpbHRlcigoaXQpID0+IGl0LmtpbmQgPT09IFwiZGF0YVwiKSB8fCBhYmlFdmVudC5kYXRhO1xuICAgIGFiaUV2ZW50S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdW2tleS5uYW1lXSA9IHJlc3BvbnNlUGFyc2VyKFxuICAgICAgICBrZXlzSXRlcixcbiAgICAgICAga2V5LFxuICAgICAgICBhYmlTdHJ1Y3RzLFxuICAgICAgICBhYmlFbnVtcyxcbiAgICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgYWJpRXZlbnREYXRhLmZvckVhY2goKGRhdGEpID0+IHtcbiAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdW2RhdGEubmFtZV0gPSByZXNwb25zZVBhcnNlcihcbiAgICAgICAgZGF0YUl0ZXIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGFiaVN0cnVjdHMsXG4gICAgICAgIGFiaUVudW1zLFxuICAgICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBhY2MucHVzaChwYXJzZWRFdmVudCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBzcmMvY29udHJhY3QvZGVmYXVsdC50c1xudmFyIHNwbGl0QXJnc0FuZE9wdGlvbnMgPSAoYXJncykgPT4ge1xuICBjb25zdCBvcHRpb25zID0gW1xuICAgIFwiYmxvY2tJZGVudGlmaWVyXCIsXG4gICAgXCJwYXJzZVJlcXVlc3RcIixcbiAgICBcInBhcnNlUmVzcG9uc2VcIixcbiAgICBcImZvcm1hdFJlc3BvbnNlXCIsXG4gICAgXCJtYXhGZWVcIixcbiAgICBcIm5vbmNlXCIsXG4gICAgXCJzaWduYXR1cmVcIixcbiAgICBcImFkZHJlc3NTYWx0XCJcbiAgXTtcbiAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBsYXN0QXJnID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuc29tZSgoeCkgPT4geCBpbiBsYXN0QXJnKSkge1xuICAgIHJldHVybiB7IGFyZ3MsIG9wdGlvbnM6IGFyZ3MucG9wKCkgfTtcbiAgfVxuICByZXR1cm4geyBhcmdzIH07XG59O1xuZnVuY3Rpb24gYnVpbGRDYWxsKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0QXJnc0FuZE9wdGlvbnMoYXJncyk7XG4gICAgcmV0dXJuIGNvbnRyYWN0LmNhbGwoZnVuY3Rpb25BYmkubmFtZSwgcGFyYW1zLmFyZ3MsIHtcbiAgICAgIHBhcnNlUmVxdWVzdDogdHJ1ZSxcbiAgICAgIHBhcnNlUmVzcG9uc2U6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICByZXR1cm4gY29udHJhY3QuaW52b2tlKGZ1bmN0aW9uQWJpLm5hbWUsIHBhcmFtcy5hcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGREZWZhdWx0KGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICBpZiAoZnVuY3Rpb25BYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBmdW5jdGlvbkFiaS5zdGF0ZV9tdXRhYmlsaXR5ID09PSBcInZpZXdcIikge1xuICAgIHJldHVybiBidWlsZENhbGwoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbiAgfVxuICByZXR1cm4gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9wdWxhdGUoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNvbnRyYWN0LnBvcHVsYXRlKGZ1bmN0aW9uQWJpLm5hbWUsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFc3RpbWF0ZShjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY29udHJhY3QuZXN0aW1hdGUoZnVuY3Rpb25BYmkubmFtZSwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDYWxsZGF0YShhcmdzLCBjYWxsYmFjaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBcIl9fY29tcGlsZWRfX1wiIGluIGFyZ3MpXG4gICAgcmV0dXJuIGFyZ3M7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBhcmdzWzBdKVxuICAgIHJldHVybiBhcmdzWzBdO1xuICByZXR1cm4gY2FsbGJhY2soKTtcbn1cbnZhciBDb250cmFjdCA9IGNsYXNzIHtcbiAgYWJpO1xuICBhZGRyZXNzO1xuICBwcm92aWRlck9yQWNjb3VudDtcbiAgZGVwbG95VHJhbnNhY3Rpb25IYXNoO1xuICBzdHJ1Y3RzO1xuICBldmVudHM7XG4gIGZ1bmN0aW9ucztcbiAgY2FsbFN0YXRpYztcbiAgcG9wdWxhdGVUcmFuc2FjdGlvbjtcbiAgZXN0aW1hdGVGZWU7XG4gIGNhbGxEYXRhO1xuICAvKipcbiAgICogQ29udHJhY3QgY2xhc3MgdG8gaGFuZGxlIGNvbnRyYWN0IG1ldGhvZHNcbiAgICpcbiAgICogQHBhcmFtIGFiaSAtIEFiaSBvZiB0aGUgY29udHJhY3Qgb2JqZWN0XG4gICAqIEBwYXJhbSBhZGRyZXNzIChvcHRpb25hbCkgLSBhZGRyZXNzIHRvIGNvbm5lY3QgdG9cbiAgICogQHBhcmFtIHByb3ZpZGVyT3JBY2NvdW50IChvcHRpb25hbCkgLSBQcm92aWRlciBvciBBY2NvdW50IHRvIGF0dGFjaCB0b1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWJpLCBhZGRyZXNzLCBwcm92aWRlck9yQWNjb3VudCA9IGRlZmF1bHRQcm92aWRlcikge1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3MgJiYgYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdmlkZXJPckFjY291bnQgPSBwcm92aWRlck9yQWNjb3VudDtcbiAgICB0aGlzLmNhbGxEYXRhID0gbmV3IENhbGxEYXRhKGFiaSk7XG4gICAgdGhpcy5zdHJ1Y3RzID0gQ2FsbERhdGEuZ2V0QWJpU3RydWN0KGFiaSk7XG4gICAgdGhpcy5ldmVudHMgPSBnZXRBYmlFdmVudHMoYWJpKTtcbiAgICBjb25zdCBwYXJzZXIgPSBjcmVhdGVBYmlQYXJzZXIoYWJpKTtcbiAgICB0aGlzLmFiaSA9IHBhcnNlci5nZXRMZWdhY3lGb3JtYXQoKTtcbiAgICBjb25zdCBvcHRpb25zID0geyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGZ1bmN0aW9uczogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgY2FsbFN0YXRpYzogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbjogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgZXN0aW1hdGVGZWU6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfVxuICAgIH0pO1xuICAgIHRoaXMuYWJpLmZvckVhY2goKGFiaUVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChhYmlFbGVtZW50LnR5cGUgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYWJpRWxlbWVudC5uYW1lO1xuICAgICAgaWYgKCF0aGlzW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkRGVmYXVsdCh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5mdW5jdGlvbnNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5mdW5jdGlvbnMsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkRGVmYXVsdCh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jYWxsU3RhdGljW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuY2FsbFN0YXRpYywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRDYWxsKHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZFBvcHVsYXRlKHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmVzdGltYXRlRmVlW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZXN0aW1hdGVGZWUsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkRXN0aW1hdGUodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXR0YWNoKGFkZHJlc3MpIHtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICB9XG4gIGNvbm5lY3QocHJvdmlkZXJPckFjY291bnQpIHtcbiAgICB0aGlzLnByb3ZpZGVyT3JBY2NvdW50ID0gcHJvdmlkZXJPckFjY291bnQ7XG4gIH1cbiAgYXN5bmMgZGVwbG95ZWQoKSB7XG4gICAgaWYgKHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICBhd2FpdCB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LndhaXRGb3JUcmFuc2FjdGlvbih0aGlzLmRlcGxveVRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICB0aGlzLmRlcGxveVRyYW5zYWN0aW9uSGFzaCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXN5bmMgY2FsbChtZXRob2QsIGFyZ3MgPSBbXSwge1xuICAgIHBhcnNlUmVxdWVzdCA9IHRydWUsXG4gICAgcGFyc2VSZXNwb25zZSA9IHRydWUsXG4gICAgZm9ybWF0UmVzcG9uc2UgPSB2b2lkIDAsXG4gICAgYmxvY2tJZGVudGlmaWVyID0gdm9pZCAwXG4gIH0gPSB7fSkge1xuICAgIGFzc2VydCh0aGlzLmFkZHJlc3MgIT09IG51bGwsIFwiY29udHJhY3QgaXMgbm90IGNvbm5lY3RlZCB0byBhbiBhZGRyZXNzXCIpO1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEoYXJncywgKCkgPT4ge1xuICAgICAgaWYgKHBhcnNlUmVxdWVzdCkge1xuICAgICAgICB0aGlzLmNhbGxEYXRhLnZhbGlkYXRlKFwiQ0FMTFwiIC8qIENBTEwgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkNhbGwgc2tpcHBlZCBwYXJzaW5nIGJ1dCBwcm92aWRlZCByYXdBcmdzLCBwb3NzaWJsZSBtYWxmdW5jdGlvbiByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuY2FsbENvbnRyYWN0KFxuICAgICAge1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGEsXG4gICAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgICAgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgICkudGhlbigoaXQpID0+IHtcbiAgICAgIGlmICghcGFyc2VSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gaXQ7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuZm9ybWF0KG1ldGhvZCwgaXQsIGZvcm1hdFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLnBhcnNlKG1ldGhvZCwgaXQpO1xuICAgIH0pO1xuICB9XG4gIGludm9rZShtZXRob2QsIGFyZ3MgPSBbXSwgeyBwYXJzZVJlcXVlc3QgPSB0cnVlLCBtYXhGZWUsIG5vbmNlLCBzaWduYXR1cmUgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkludm9rZSBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgIH07XG4gICAgaWYgKFwiZXhlY3V0ZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmV4ZWN1dGUoaW52b2NhdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgIG1heEZlZSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW5vbmNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb25jZSBpcyByZXF1aXJlZCB3aGVuIGludm9raW5nIGEgZnVuY3Rpb24gd2l0aG91dCBhbiBhY2NvdW50YCk7XG4gICAgY29uc29sZS53YXJuKGBJbnZva2luZyAke21ldGhvZH0gd2l0aG91dCBhbiBhY2NvdW50LiBUaGlzIHdpbGwgbm90IHdvcmsgb24gYSBwdWJsaWMgbm9kZS5gKTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5pbnZva2VGdW5jdGlvbihcbiAgICAgIHtcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBub25jZVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGUobWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBpZiAoIWdldENhbGxkYXRhKGFyZ3MsICgpID0+IGZhbHNlKSkge1xuICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIklOVk9LRVwiIC8qIElOVk9LRSAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IHRoaXMucG9wdWxhdGUobWV0aG9kLCBhcmdzKTtcbiAgICBpZiAoXCJlc3RpbWF0ZUludm9rZUZlZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmVzdGltYXRlSW52b2tlRmVlKGludm9jYXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0IG11c3QgYmUgY29ubmVjdGVkIHRvIHRoZSBhY2NvdW50IGNvbnRyYWN0IHRvIGVzdGltYXRlXCIpO1xuICB9XG4gIHBvcHVsYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgZW50cnlwb2ludDogbWV0aG9kLFxuICAgICAgY2FsbGRhdGFcbiAgICB9O1xuICB9XG4gIHBhcnNlRXZlbnRzKHJlY2VpcHQpIHtcbiAgICByZXR1cm4gcGFyc2VFdmVudHMoXG4gICAgICByZWNlaXB0LmV2ZW50cz8uZmlsdGVyKFxuICAgICAgICAoZXZlbnQpID0+IGNsZWFuSGV4KGV2ZW50LmZyb21fYWRkcmVzcykgPT09IGNsZWFuSGV4KHRoaXMuYWRkcmVzcyksXG4gICAgICAgIFtdXG4gICAgICApIHx8IFtdLFxuICAgICAgdGhpcy5ldmVudHMsXG4gICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICBDYWxsRGF0YS5nZXRBYmlFbnVtKHRoaXMuYWJpKVxuICAgICk7XG4gIH1cbiAgaXNDYWlybzEoKSB7XG4gICAgcmV0dXJuIGNhaXJvX2V4cG9ydHMuaXNDYWlybzFBYmkodGhpcy5hYmkpO1xuICB9XG4gIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuZ2V0Q29udHJhY3RWZXJzaW9uKHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgdHlwZWR2MSh0QWJpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdHlwZWR2Mih0QWJpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8vIHNyYy9jb250cmFjdC9pbnRlcmZhY2UudHNcbnZhciBDb250cmFjdEludGVyZmFjZSA9IGNsYXNzIHtcbiAgZnVuY3Rpb25zO1xuICBjYWxsU3RhdGljO1xuICBwb3B1bGF0ZVRyYW5zYWN0aW9uO1xuICBlc3RpbWF0ZUZlZTtcbn07XG5cbi8vIHNyYy9jb250cmFjdC9jb250cmFjdEZhY3RvcnkudHNcbnZhciBDb250cmFjdEZhY3RvcnkgPSBjbGFzcyB7XG4gIGNvbXBpbGVkQ29udHJhY3Q7XG4gIGFjY291bnQ7XG4gIGFiaTtcbiAgY2xhc3NIYXNoO1xuICBjYXNtO1xuICBjb21waWxlZENsYXNzSGFzaDtcbiAgQ2FsbERhdGE7XG4gIC8qKlxuICAgKiBAcGFyYW0gcGFyYW1zIENGUGFyYW1zXG4gICAqICAtIGNvbXBpbGVkQ29udHJhY3Q6IENvbXBpbGVkQ29udHJhY3Q7XG4gICAqICAtIGFjY291bnQ6IEFjY291bnRJbnRlcmZhY2U7XG4gICAqICAtIGNhc20/OiBDYWlyb0Fzc2VtYmx5O1xuICAgKiAgLSBjbGFzc0hhc2g/OiBzdHJpbmc7XG4gICAqICAtIGNvbXBpbGVkQ2xhc3NIYXNoPzogc3RyaW5nO1xuICAgKiAgLSBhYmk/OiBBYmk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICB0aGlzLmNvbXBpbGVkQ29udHJhY3QgPSBwYXJhbXMuY29tcGlsZWRDb250cmFjdDtcbiAgICB0aGlzLmFjY291bnQgPSBwYXJhbXMuYWNjb3VudDtcbiAgICB0aGlzLmNhc20gPSBwYXJhbXMuY2FzbTtcbiAgICB0aGlzLmFiaSA9IHBhcmFtcy5hYmkgPz8gcGFyYW1zLmNvbXBpbGVkQ29udHJhY3QuYWJpO1xuICAgIHRoaXMuY2xhc3NIYXNoID0gcGFyYW1zLmNsYXNzSGFzaDtcbiAgICB0aGlzLmNvbXBpbGVkQ2xhc3NIYXNoID0gcGFyYW1zLmNvbXBpbGVkQ2xhc3NIYXNoO1xuICAgIHRoaXMuQ2FsbERhdGEgPSBuZXcgQ2FsbERhdGEodGhpcy5hYmkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXBsb3lzIGNvbnRyYWN0IGFuZCByZXR1cm5zIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ29udHJhY3RcbiAgICpcbiAgICogSWYgY29udHJhY3QgaXMgbm90IGRlY2xhcmVkIGl0IHdpbGwgZmlyc3QgZGVjbGFyZSBpdCwgYW5kIHRoZW4gZGVwbG95XG4gICAqL1xuICBhc3luYyBkZXBsb3koLi4uYXJncykge1xuICAgIGNvbnN0IHsgYXJnczogcGFyYW0sIG9wdGlvbnMgPSB7IHBhcnNlUmVxdWVzdDogdHJ1ZSB9IH0gPSBzcGxpdEFyZ3NBbmRPcHRpb25zKGFyZ3MpO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBnZXRDYWxsZGF0YShwYXJhbSwgKCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuQ2FsbERhdGEudmFsaWRhdGUoXCJERVBMT1lcIiAvKiBERVBMT1kgKi8sIFwiY29uc3RydWN0b3JcIiwgcGFyYW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5DYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiQ2FsbCBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgZGVwbG95OiB7IGNvbnRyYWN0X2FkZHJlc3MsIHRyYW5zYWN0aW9uX2hhc2ggfVxuICAgIH0gPSBhd2FpdCB0aGlzLmFjY291bnQuZGVjbGFyZUFuZERlcGxveSh7XG4gICAgICBjb250cmFjdDogdGhpcy5jb21waWxlZENvbnRyYWN0LFxuICAgICAgY2FzbTogdGhpcy5jYXNtLFxuICAgICAgY2xhc3NIYXNoOiB0aGlzLmNsYXNzSGFzaCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoOiB0aGlzLmNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgIHNhbHQ6IG9wdGlvbnMuYWRkcmVzc1NhbHRcbiAgICB9KTtcbiAgICBhc3NlcnQoQm9vbGVhbihjb250cmFjdF9hZGRyZXNzKSwgXCJEZXBsb3ltZW50IG9mIHRoZSBjb250cmFjdCBmYWlsZWRcIik7XG4gICAgY29uc3QgY29udHJhY3RJbnN0YW5jZSA9IG5ldyBDb250cmFjdChcbiAgICAgIHRoaXMuY29tcGlsZWRDb250cmFjdC5hYmksXG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgdGhpcy5hY2NvdW50XG4gICAgKTtcbiAgICBjb250cmFjdEluc3RhbmNlLmRlcGxveVRyYW5zYWN0aW9uSGFzaCA9IHRyYW5zYWN0aW9uX2hhc2g7XG4gICAgcmV0dXJuIGNvbnRyYWN0SW5zdGFuY2U7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIHRvIG5ldyBBY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSBhY2NvdW50IC0gbmV3IEFjY291bnQgdG8gYXR0YWNoIHRvXG4gICAqL1xuICBjb25uZWN0KGFjY291bnQpIHtcbiAgICB0aGlzLmFjY291bnQgPSBhY2NvdW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBjdXJyZW50IGFiaSBhbmQgYWNjb3VudCB0byB0aGUgbmV3IGFkZHJlc3NcbiAgICovXG4gIGF0dGFjaChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFjdCh0aGlzLmFiaSwgYWRkcmVzcywgdGhpcy5hY2NvdW50KTtcbiAgfVxuICAvLyBldGhlcnMuanMnIGdldERlcGxveVRyYW5zYWN0aW9uIGNhbid0IGJlIHN1cHBvcnRlZCBhcyBpdCByZXF1aXJlcyB0aGUgYWNjb3VudCBvciBzaWduZXIgdG8gcmV0dXJuIGEgc2lnbmVkIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG5vdCBwb3NzaWJsZSB3aXRoIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uXG59O1xuXG4vLyBzcmMvdXRpbHMvdWludDI1Ni50c1xudmFyIHVpbnQyNTZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodWludDI1Nl9leHBvcnRzLCB7XG4gIFVJTlRfMTI4X01BWDogKCkgPT4gVUlOVF8xMjhfTUFYLFxuICBVSU5UXzI1Nl9NQVg6ICgpID0+IFVJTlRfMjU2X01BWCxcbiAgYm5Ub1VpbnQyNTY6ICgpID0+IGJuVG9VaW50MjU2LFxuICBpc1VpbnQyNTY6ICgpID0+IGlzVWludDI1NixcbiAgdWludDI1NlRvQk46ICgpID0+IHVpbnQyNTZUb0JOXG59KTtcbmZ1bmN0aW9uIHVpbnQyNTZUb0JOKHVpbnQyNTYyKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KHVpbnQyNTYyKS50b0JpZ0ludCgpO1xufVxuZnVuY3Rpb24gaXNVaW50MjU2KGJuKSB7XG4gIHJldHVybiBDYWlyb1VpbnQyNTYuaXMoYm4pO1xufVxuZnVuY3Rpb24gYm5Ub1VpbnQyNTYoYm4pIHtcbiAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYoYm4pLnRvVWludDI1NkhleFN0cmluZygpO1xufVxuXG4vLyBzcmMvdXRpbHMvYWRkcmVzcy50c1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCI7XG5mdW5jdGlvbiBhZGRBZGRyZXNzUGFkZGluZyhhZGRyZXNzKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgocmVtb3ZlSGV4UHJlZml4KHRvSGV4KGFkZHJlc3MpKS5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpIHtcbiAgYXNzZXJ0SW5SYW5nZShhZGRyZXNzLCBaRVJPLCBBRERSX0JPVU5EIC0gMW4sIFwiU3RhcmtuZXQgQWRkcmVzc1wiKTtcbiAgY29uc3QgcmVzdWx0ID0gYWRkQWRkcmVzc1BhZGRpbmcoYWRkcmVzcyk7XG4gIGlmICghcmVzdWx0Lm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs2NH0kLykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEFkZHJlc3MgRm9ybWF0XCIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICBjb25zdCBjaGFycyA9IHJlbW92ZUhleFByZWZpeCh2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyhhZGRyZXNzKSkudG9Mb3dlckNhc2UoKS5zcGxpdChcIlwiKTtcbiAgY29uc3QgaGV4ID0gcmVtb3ZlSGV4UHJlZml4KGtlY2Nha0JuKGFkZHJlc3MpKTtcbiAgY29uc3QgaGFzaGVkID0gaGV4VG9CeXRlczIoaGV4LnBhZFN0YXJ0KDY0LCBcIjBcIikpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKGhhc2hlZFtpID4+IDFdID4+IDQgPj0gOCkge1xuICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMTUpID49IDgpIHtcbiAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWRkSGV4UHJlZml4KGNoYXJzLmpvaW4oXCJcIikpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICByZXR1cm4gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpID09PSBhZGRyZXNzO1xufVxuXG4vLyBzcmMvdXRpbHMvdXJsLnRzXG5pbXBvcnQgdXJsam9pbiBmcm9tIFwidXJsLWpvaW5cIjtcbnZhciBwcm90b2NvbEFuZERvbWFpblJFID0gL14oPzpcXHcrOik/XFwvXFwvKFxcUyspJC87XG52YXIgbG9jYWxob3N0RG9tYWluUkUgPSAvXmxvY2FsaG9zdFs6P1xcZF0qKD86W146P1xcZF1cXFMqKT8kLztcbnZhciBub25Mb2NhbGhvc3REb21haW5SRSA9IC9eW15cXHMuXStcXC5cXFN7Mix9JC87XG5mdW5jdGlvbiBpc1VybChzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSBzLm1hdGNoKHByb3RvY29sQW5kRG9tYWluUkUpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGV2ZXJ5dGhpbmdBZnRlclByb3RvY29sID0gbWF0Y2hbMV07XG4gIGlmICghZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxvY2FsaG9zdERvbWFpblJFLnRlc3QoZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wpIHx8IG5vbkxvY2FsaG9zdERvbWFpblJFLnRlc3QoZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYnVpbGRVcmwoYmFzZVVybCwgZGVmYXVsdFBhdGgsIHVybE9yUGF0aCkge1xuICByZXR1cm4gaXNVcmwodXJsT3JQYXRoKSA/IHVybE9yUGF0aCA6IHVybGpvaW4oYmFzZVVybCwgdXJsT3JQYXRoID8/IGRlZmF1bHRQYXRoKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG52YXIgbnVtYmVyID0gbnVtX2V4cG9ydHM7XG5leHBvcnQge1xuICBBY2NvdW50LFxuICBBY2NvdW50SW50ZXJmYWNlLFxuICBCbG9ja1N0YXR1cyxcbiAgQmxvY2tUYWcsXG4gIENhaXJvQ3VzdG9tRW51bSxcbiAgQ2Fpcm9PcHRpb24sXG4gIENhaXJvT3B0aW9uVmFyaWFudCxcbiAgQ2Fpcm9SZXN1bHQsXG4gIENhaXJvUmVzdWx0VmFyaWFudCxcbiAgQ2FsbERhdGEsXG4gIENvbnRyYWN0LFxuICBDb250cmFjdEZhY3RvcnksXG4gIENvbnRyYWN0SW50ZXJmYWNlLFxuICBDdXN0b21FcnJvcixcbiAgRW50cnlQb2ludFR5cGUsXG4gIEV0aFNpZ25lcixcbiAgR2F0ZXdheUVycm9yLFxuICBIdHRwRXJyb3IsXG4gIExpYnJhcnlFcnJvcixcbiAgTGl0ZXJhbCxcbiAgUnBjUHJvdmlkZXIyIGFzIFByb3ZpZGVyLFxuICBQcm92aWRlckludGVyZmFjZSxcbiAgYXBpX2V4cG9ydHMgYXMgUlBDLFxuICBScGNDaGFubmVsLFxuICBScGNQcm92aWRlcjIgYXMgUnBjUHJvdmlkZXIsXG4gIFNJTVVMQVRJT05fRkxBRyxcbiAgU2lnbmVyLFxuICBTaWduZXJJbnRlcmZhY2UsXG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBUcmFuc2FjdGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25UeXBlLFxuICBUeXBlZERhdGFSZXZpc2lvbixcbiAgVWludCxcbiAgVmFsaWRhdGVUeXBlLFxuICBhZGRBZGRyZXNzUGFkZGluZyxcbiAgYnVpbGRVcmwsXG4gIGJ5dGVBcnJheV9leHBvcnRzIGFzIGJ5dGVBcnJheSxcbiAgY2Fpcm9fZXhwb3J0cyBhcyBjYWlybyxcbiAgY29uc3RhbnRzX2V4cG9ydHMgYXMgY29uc3RhbnRzLFxuICBjb250cmFjdENsYXNzUmVzcG9uc2VUb0xlZ2FjeUNvbXBpbGVkQ29udHJhY3QsXG4gIGRlZmF1bHRQcm92aWRlcixcbiAgZWNfZXhwb3J0cyBhcyBlYyxcbiAgZW5jb2RlX2V4cG9ydHMgYXMgZW5jb2RlLFxuICBldGhfZXhwb3J0cyBhcyBldGgsXG4gIGV2ZW50c19leHBvcnRzIGFzIGV2ZW50cyxcbiAgZXh0cmFjdENvbnRyYWN0SGFzaGVzLFxuICBmaXhQcm90byxcbiAgZml4U3RhY2ssXG4gIGdldENhbGxkYXRhLFxuICBnZXRDaGVja3N1bUFkZHJlc3MsXG4gIGhhc2hfZXhwb3J0cyBhcyBoYXNoLFxuICBpc1NpZXJyYSxcbiAgaXNVcmwsXG4gIGpzb25fZXhwb3J0cyBhcyBqc29uLFxuICBtZXJrbGVfZXhwb3J0cyBhcyBtZXJrbGUsXG4gIG51bV9leHBvcnRzIGFzIG51bSxcbiAgbnVtYmVyLFxuICBwYXJzZVVEQ0V2ZW50LFxuICBwcm92aWRlcl9leHBvcnRzIGFzIHByb3ZpZGVyLFxuICBzZWxlY3Rvcl9leHBvcnRzIGFzIHNlbGVjdG9yLFxuICBzaG9ydFN0cmluZ19leHBvcnRzIGFzIHNob3J0U3RyaW5nLFxuICBzcGxpdEFyZ3NBbmRPcHRpb25zLFxuICBzdGFya19leHBvcnRzIGFzIHN0YXJrLFxuICBzdGFya25ldElkX2V4cG9ydHMgYXMgc3RhcmtuZXRJZCxcbiAgdHJhbnNhY3Rpb25fZXhwb3J0cyBhcyB0cmFuc2FjdGlvbixcbiAgdHlwZWREYXRhX2V4cG9ydHMgYXMgdHlwZWREYXRhLFxuICB0eXBlc19leHBvcnRzIGFzIHR5cGVzLFxuICB1aW50MjU2X2V4cG9ydHMgYXMgdWludDI1NixcbiAgdjJfZXhwb3J0cyBhcyB2Mmhhc2gsXG4gIHYzX2V4cG9ydHMgYXMgdjNoYXNoLFxuICB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyxcbiAgdmFsaWRhdGVDaGVja3N1bUFkZHJlc3Ncbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJnZXQiLCJfX3B1YmxpY0ZpZWxkIiwiY29uc3RhbnRzX2V4cG9ydHMiLCJBRERSX0JPVU5EIiwiQVBJX1ZFUlNJT04iLCJCYXNlVXJsIiwiSVNfQlJPV1NFUiIsIk1BU0tfMjUwIiwiTUFYX1NUT1JBR0VfSVRFTV9TSVpFIiwiTmV0d29ya05hbWUiLCJSUENfREVGQVVMVF9WRVJTSU9OIiwiUlBDX05PREVTIiwiU3RhcmtuZXRDaGFpbklkIiwiVEVYVF9UT19GRUxUX01BWF9MRU4iLCJUUkFOU0FDVElPTl9WRVJTSU9OIiwiRVRyYW5zYWN0aW9uVmVyc2lvbiIsIlRyYW5zYWN0aW9uSGFzaFByZWZpeCIsIlVEQyIsIlpFUk8iLCJhcGlfZXhwb3J0cyIsIkVCbG9ja1RhZyIsIkVEQU1vZGUiLCJFRGF0YUF2YWlsYWJpbGl0eU1vZGUiLCJFU2ltdWxhdGlvbkZsYWciLCJFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMiLCJFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyIsIkVUcmFuc2FjdGlvblN0YXR1cyIsIkVUcmFuc2FjdGlvblR5cGUiLCJFVHJhbnNhY3Rpb25WZXJzaW9uMiIsIkVUcmFuc2FjdGlvblZlcnNpb24zIiwiRXJyb3JzIiwiZXJyb3JzX2V4cG9ydHMiLCJKUlBDIiwianNvbnJwY19leHBvcnRzIiwiU1BFQyIsImNvbXBvbmVudHNfZXhwb3J0cyIsIkVUcmFuc2FjdGlvblR5cGUyIiwiRVNpbXVsYXRpb25GbGFnMiIsIkVUcmFuc2FjdGlvblN0YXR1czIiLCJFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIiLCJFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyIiwiRUJsb2NrVGFnMiIsIkVEYXRhQXZhaWxhYmlsaXR5TW9kZTIiLCJFREFNb2RlMyIsIkVUcmFuc2FjdGlvblZlcnNpb240IiwiRVRyYW5zYWN0aW9uVmVyc2lvbjIzIiwiRVRyYW5zYWN0aW9uVmVyc2lvbjMzIiwiZW5jb2RlX2V4cG9ydHMiLCJhZGRIZXhQcmVmaXgiLCJhcnJheUJ1ZmZlclRvU3RyaW5nIiwiYXRvYlVuaXZlcnNhbCIsImJ0b2FVbml2ZXJzYWwiLCJidWYyaGV4IiwiY2FsY0J5dGVMZW5ndGgiLCJwYWRMZWZ0IiwicGFzY2FsVG9TbmFrZSIsInJlbW92ZUhleFByZWZpeCIsInNhbml0aXplQnl0ZXMiLCJzYW5pdGl6ZUhleCIsInN0cmluZ1RvQXJyYXlCdWZmZXIiLCJ1dGY4VG9BcnJheSIsImJhc2U2NCIsIlNUUklOR19aRVJPIiwiYXJyYXkiLCJVaW50OEFycmF5IiwicmVkdWNlIiwiZGF0YSIsImJ5dGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImEiLCJkZWNvZGUiLCJiIiwiYnVmZmVyIiwiciIsIngiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiaGV4IiwicmVwbGFjZSIsInBhZFN0cmluZyIsImxlbmd0aCIsImxlZnQiLCJwYWRkaW5nIiwiZGlmZiIsInJlc3VsdCIsInBhZCIsInJlcGVhdCIsImJ5dGVTaXplIiwicmVtYWluZGVyIiwidGV4dCIsInRlc3QiLCJzcGxpdCIsImpvaW4iLCJ0b1VwcGVyQ2FzZSIsIkJhc2VVcmwyIiwiTmV0d29ya05hbWUyIiwiU3RhcmtuZXRDaGFpbklkNSIsIlRyYW5zYWN0aW9uSGFzaFByZWZpeDIiLCJBRERSRVNTIiwiRU5UUllQT0lOVCIsIlNOX0dPRVJMSSIsIlNOX01BSU4iLCJTTl9TRVBPTElBIiwiZml4U3RhY2siLCJmbiIsImNvbnN0cnVjdG9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJFcnJvciIsImZpeFByb3RvIiwicHJvdG90eXBlIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJDdXN0b21FcnJvciIsIm1lc3NhZ2UiLCJMaWJyYXJ5RXJyb3IiLCJHYXRld2F5RXJyb3IiLCJlcnJvckNvZGUiLCJIdHRwRXJyb3IiLCJ0eXBlc19leHBvcnRzIiwiQmxvY2tTdGF0dXMiLCJCbG9ja1RhZyIsIkVudHJ5UG9pbnRUeXBlIiwiTGl0ZXJhbCIsIlJQQyIsIlNJTVVMQVRJT05fRkxBRyIsIlRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIiwiVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyIsIlRyYW5zYWN0aW9uU3RhdHVzIiwiVHJhbnNhY3Rpb25UeXBlIiwiVHlwZWREYXRhUmV2aXNpb24iLCJVaW50IiwiVmFsaWRhdGVUeXBlIiwiU0lNVUxBVElPTl9GTEFHMiIsIlZhbGlkYXRlVHlwZTIiLCJVaW50MiIsIkxpdGVyYWwyIiwiRW50cnlQb2ludFR5cGUyIiwiVHJhbnNhY3Rpb25UeXBlMiIsIlRyYW5zYWN0aW9uU3RhdHVzMiIsIlRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyIiwiVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyIiwiQmxvY2tTdGF0dXMyIiwiQmxvY2tUYWcyIiwiVHlwZWREYXRhUmV2aXNpb24yIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibnVtX2V4cG9ydHMiLCJhZGRQZXJjZW50IiwiYXNzZXJ0SW5SYW5nZSIsImJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXkiLCJiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheSIsImNsZWFuSGV4IiwiZ2V0RGVjaW1hbFN0cmluZyIsImdldEhleFN0cmluZyIsImdldEhleFN0cmluZ0FycmF5IiwiaGV4VG9CeXRlcyIsImhleFRvRGVjaW1hbFN0cmluZyIsImlzQmlnSW50IiwiaXNIZXgiLCJpc1N0cmluZ1dob2xlTnVtYmVyIiwidG9CaWdJbnQiLCJ0b0NhaXJvQm9vbCIsInRvSGV4IiwidG9IZXhTdHJpbmciLCJ0b1N0b3JhZ2VLZXkiLCJoZXhUb0J5dGVzTm9ibGUiLCJCaWdJbnQiLCJudW1iZXIyIiwicmVzIiwidG9Mb3dlckNhc2UiLCJpbnB1dCIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiaW5wdXROYW1lIiwibWVzc2FnZVN1ZmZpeCIsImlucHV0QmlnSW50IiwibG93ZXJCb3VuZEJpZ0ludCIsInVwcGVyQm91bmRCaWdJbnQiLCJyYXdDYWxsZGF0YSIsIm1hcCIsImVsIiwiYWRhcHRlZFZhbHVlIiwicGVyY2VudCIsImJpZ0ludE51bSIsInNlbGVjdG9yX2V4cG9ydHMiLCJnZXRTZWxlY3RvciIsImdldFNlbGVjdG9yRnJvbU5hbWUiLCJrZWNjYWtCbiIsInN0YXJrbmV0S2VjY2FrIiwia2VjY2FrIiwiaGV4V2l0aG91dFByZWZpeCIsImV2ZW5IZXgiLCJrZWNjYWtIZXgiLCJoYXNoIiwiZnVuY05hbWUiLCJzaG9ydFN0cmluZ19leHBvcnRzIiwiZGVjb2RlU2hvcnRTdHJpbmciLCJlbmNvZGVTaG9ydFN0cmluZyIsImlzQVNDSUkiLCJpc0RlY2ltYWxTdHJpbmciLCJpc0xvbmdUZXh0IiwiaXNTaG9ydFN0cmluZyIsImlzU2hvcnRUZXh0IiwiaXNUZXh0Iiwic3BsaXRMb25nU3RyaW5nIiwidmFsIiwibG9uZ1N0ciIsInJlZ2V4IiwiUmVnRXhwIiwibWF0Y2giLCJjaGFyIiwiY2hhckNvZGVBdCIsInBhcnNlSW50IiwiY29uY2F0IiwiYnl0ZUFycmF5X2V4cG9ydHMiLCJieXRlQXJyYXlGcm9tU3RyaW5nIiwic3RyaW5nRnJvbUJ5dGVBcnJheSIsIm15Qnl0ZUFycmF5IiwicGVuZGluZ193b3JkIiwiY3VtdWxlZFN0cmluZyIsImVuY29kZWRTdHJpbmciLCJhZGQiLCJteVN0cmluZyIsInBlbmRpbmdfd29yZF9sZW4iLCJteVNob3J0U3RyaW5ncyIsInJlbWFpbnMiLCJteVNob3J0U3RyaW5nc0VuY29kZWQiLCJzaG9ydFN0ciIsInBlbmRpbmdFbmNvZGVkV29yZCIsInBvcCIsImNhaXJvX2V4cG9ydHMiLCJmZWx0IiwiZ2V0QWJpQ29udHJhY3RWZXJzaW9uIiwiZ2V0QXJyYXlUeXBlIiwiaXNDYWlybzFBYmkiLCJpc0NhaXJvMVR5cGUiLCJpc0xlbiIsImlzVHlwZUFycmF5IiwiaXNUeXBlQm9vbCIsImlzVHlwZUJ5dGVBcnJheSIsImlzVHlwZUJ5dGVzMzEiLCJpc1R5cGVDb250cmFjdEFkZHJlc3MiLCJpc1R5cGVFbnVtIiwiaXNUeXBlRXRoQWRkcmVzcyIsImlzVHlwZUZlbHQiLCJpc1R5cGVMaXRlcmFsIiwiaXNUeXBlTmFtZWRUdXBsZSIsImlzVHlwZU9wdGlvbiIsImlzVHlwZVJlc3VsdCIsImlzVHlwZVN0cnVjdCIsImlzVHlwZVR1cGxlIiwiaXNUeXBlVWludCIsImlzVHlwZVVpbnQyNTYiLCJ0dXBsZSIsInVpbnQyNTYiLCJDYWlyb0ZlbHQiLCJpdCIsIk51bWJlciIsImlzSW50ZWdlciIsImVuY29kZWQiLCJVSU5UXzEyOF9NQVgiLCJVSU5UXzI1Nl9NQVgiLCJVSU5UXzI1Nl9NSU4iLCJVSU5UXzI1Nl9MT1dfTUFYIiwiVUlOVF8yNTZfSElHSF9NQVgiLCJVSU5UXzI1Nl9MT1dfTUlOIiwiVUlOVF8yNTZfSElHSF9NSU4iLCJfQ2Fpcm9VaW50MjU2IiwiYXJyIiwicHJvcHMiLCJ2YWxpZGF0ZVByb3BzIiwibG93IiwiaGlnaCIsImJpZ0ludCIsInZhbGlkYXRlIiwiYmlnTnVtYmVyaXNoIiwiYmlnSW50TG93IiwiYmlnSW50SGlnaCIsImlzIiwiZXJyb3IiLCJpc0FiaVR5cGUiLCJhYmlUeXBlIiwiYWJpU2VsZWN0b3IiLCJ0b1VpbnQyNTZIZXhTdHJpbmciLCJ0b1VpbnQyNTZEZWNpbWFsU3RyaW5nIiwidG9BcGlSZXF1ZXN0IiwiQ2Fpcm9VaW50MjU2IiwidHlwZSIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsInN0cnVjdHMiLCJlbnVtcyIsInZhbHVlcyIsInN1YnN0cmluZyIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImFiaSIsImNhaXJvIiwiZmluZCIsImNvbXBpbGVyIiwidGVzdEZ1bmN0aW9uIiwiaW5wdXRzIiwib3V0cHV0cyIsImlvIiwiYXJncyIsIkNhaXJvQ3VzdG9tRW51bSIsImVudW1Db250ZW50IiwidmFyaWFudHNMaXN0IiwibmJBY3RpdmVWYXJpYW50cyIsImZpbHRlciIsImNvbnRlbnQiLCJ2YXJpYW50IiwidW53cmFwIiwidmFyaWFudHMiLCJlbnRyaWVzIiwiYWN0aXZlVmFyaWFudCIsIml0ZW0iLCJDYWlyb09wdGlvblZhcmlhbnQiLCJDYWlyb09wdGlvblZhcmlhbnQyIiwiQ2Fpcm9PcHRpb24iLCJzb21lQ29udGVudCIsIlNvbWUiLCJOb25lIiwiaXNTb21lIiwiaXNOb25lIiwiQ2Fpcm9SZXN1bHRWYXJpYW50IiwiQ2Fpcm9SZXN1bHRWYXJpYW50MiIsIkNhaXJvUmVzdWx0IiwicmVzdWx0Q29udGVudCIsIk9rIiwiRXJyIiwiaXNPayIsImlzRXJyIiwiZ3VhcmQiLCJpc0JOIiwidW5rbm93biIsImZvcm1hdHRlciIsInNhbWVUeXBlIiwiYWNjIiwiZWxUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyYXlTdHIiLCJfIiwiYXJyYXlPYmoiLCJBYmlQYXJzZXIxIiwibWV0aG9kSW5wdXRzTGVuZ3RoIiwiYWJpTWV0aG9kIiwiZ2V0TWV0aG9kIiwiZ2V0TGVnYWN5Rm9ybWF0IiwiQWJpUGFyc2VyMiIsImludGYiLCJpdGVtcyIsImZsYXRNYXAiLCJlIiwiY3JlYXRlQWJpUGFyc2VyIiwidmVyc2lvbiIsImdldEFiaVZlcnNpb24iLCJpc05vQ29uc3RydWN0b3JWYWxpZCIsIm1ldGhvZCIsImFyZ3NDYWxsZGF0YSIsInBhcnNlTmFtZWRUdXBsZSIsIm5hbWVkVHVwbGUiLCJwYXJzZVN1YlR1cGxlIiwicyIsInN1YlR1cGxlIiwiaSIsImNvdW50ZXIiLCJsQnJhY2tldCIsInB1c2giLCJleHRyYWN0Q2Fpcm8wVHVwbGUiLCJjbGVhblR5cGUiLCJzbGljZSIsInJlY29tcG9zZWQiLCJzaGlmdCIsImV4dHJhY3RDYWlybzFUdXBsZSIsImV4dHJhY3RUdXBsZU1lbWJlclR5cGVzIiwiZXJyb3JVMjU2Iiwib3JkZXJQcm9wc0J5QWJpIiwidW5vcmRlcmVkT2JqZWN0IiwiYWJpT2ZPYmplY3QiLCJvcmRlcklucHV0IiwidW5vcmRlcmVkSXRlbSIsIm9yZGVyQXJyYXkiLCJhYmlPYmoiLCJvcmRlckVudW0iLCJvcmRlclR1cGxlIiwidTI1NiIsImFiaU9mU3RydWN0IiwibWVtYmVycyIsIm9yZGVyU3RydWN0IiwidW5vcmRlcmVkT2JqZWN0MiIsImFiaU9iamVjdCIsIm9yZGVyZWRPYmplY3QyIiwib3JkZXJlZE9iamVjdCIsImFiaVBhcmFtIiwic2V0UHJvcGVydHkiLCJteUFycmF5IiwidHlwZUluQXJyYXkiLCJteUVsZW0iLCJ0eXBlTGlzdCIsImFiaVR5cGVDYWlyb1giLCJpbmRleCIsIm15T2JqS2V5cyIsImtleXMiLCJ1bm9yZGVyZWRSZXN1bHQiLCJyZXN1bHRPa1R5cGUiLCJyZXN1bHRFcnJUeXBlIiwidW5vcmRlcmVkT3B0aW9uIiwicmVzdWx0U29tZVR5cGUiLCJ1bm9yZGVyZWRDdXN0b21FbnVtIiwibmV3RW50cmllcyIsInZhcmlhbnRUeXBlIiwiZnJvbUVudHJpZXMiLCJmaW5hbE9yZGVyZWRPYmplY3QiLCJwYXJzZUJhc2VUeXBlcyIsInBhcnNlVHVwbGUiLCJlbGVtZW50IiwidHlwZVN0ciIsIm1lbWJlclR5cGVzIiwiZWxlbWVudHMiLCJkeCIsInBhcnNlQnl0ZUFycmF5IiwiYm4iLCJwYXJzZUNhbGxkYXRhVmFsdWUiLCJhcnJheVR5cGUiLCJzdWJFbGVtZW50IiwidHVwbGVkIiwicGFyc2VkRGF0YSIsIm15T3B0aW9uIiwibGlzdFR5cGVWYXJpYW50MiIsInR5cGVWYXJpYW50U29tZSIsInBhcnNlZFBhcmFtZXRlcjIiLCJteVJlc3VsdCIsImxpc3RUeXBlVmFyaWFudDMiLCJ0eXBlVmFyaWFudE9rIiwicGFyc2VkUGFyYW1ldGVyMyIsInR5cGVWYXJpYW50RXJyIiwibXlFbnVtIiwibGlzdFR5cGVWYXJpYW50IiwidHlwZUFjdGl2ZVZhcmlhbnQiLCJudW1BY3RpdmVWYXJpYW50IiwiZmluZEluZGV4IiwicGFyc2VkUGFyYW1ldGVyIiwicGFyc2VDYWxsZGF0YUZpZWxkIiwiYXJnc0l0ZXJhdG9yIiwibmV4dCIsInBhcnNlQmFzZVR5cGVzMiIsInRlbXAiLCJCb29sZWFuIiwicGFyc2VSZXNwb25zZVZhbHVlIiwicmVzcG9uc2VJdGVyYXRvciIsInBhcnNlZEJ5dGVzMzFBcnIiLCJieXRlczMxQXJyTGVuIiwicGFyc2VkRGF0YUFyciIsImxlbiIsInZhcmlhbnROdW0iLCJyYXdFbnVtIiwibnVtIiwiY3VzdG9tRW51bSIsImlkeCIsInJlc3BvbnNlUGFyc2VyIiwib3V0cHV0IiwicGFyc2VkUmVzdWx0IiwiYXJyTGVuIiwidmFsaWRhdGVGZWx0IiwicGFyYW1ldGVyIiwicGFyYW0iLCJ2YWxpZGF0ZUJ5dGVzMzEiLCJ2YWxpZGF0ZUJ5dGVBcnJheSIsInZhbGlkYXRlVWludCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJ2YWxpZGF0ZUJvb2wiLCJ2YWxpZGF0ZVN0cnVjdCIsImZvckVhY2giLCJ2YWxpZGF0ZUVudW0iLCJtZXRob2RzS2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRQcm90b3R5cGVPZiIsInZhbGlkYXRlVHVwbGUiLCJ2YWxpZGF0ZUFycmF5IiwiYmFzZVR5cGUiLCJ2YWxpZGF0ZUZpZWxkcyIsIkNhbGxEYXRhIiwiZ2V0QWJpU3RydWN0IiwiZ2V0QWJpRW51bSIsInBhcnNlciIsImludm9jYWJsZUZ1bmN0aW9uTmFtZXMiLCJpc1ZpZXciLCJzdGF0ZU11dGFiaWxpdHkiLCJzdGF0ZV9tdXRhYmlsaXR5IiwiaW5wdXRzTGVuZ3RoIiwiY29tcGlsZSIsImFiaUZ1bmN0aW9uIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjYWxsQXJyYXkiLCJyYXdBcmdzIiwiY3JlYXRlVHJlZSIsImdldEVudHJpZXMiLCJvIiwicHJlZml4Iiwib2UiLCJrIiwidiIsImtrIiwidmFyaWFudE5iIiwibGlzdFZhcmlhbnRzIiwiYWN0aXZlVmFyaWFudE5iIiwiY2FsbFRyZWVBcnJheSIsImNhbGxUcmVlIiwiY2FsbE9iaiIsInBhcnNlIiwicmVzcG9uc2UiLCJmbGF0IiwicGFyc2VkIiwicHJvcE5hbWUiLCJmb3JtYXQiLCJhYmlFbnRyeSIsImZ1bGxFbnVtTGlzdCIsInRvQ2FsbGRhdGEiLCJyYXciLCJjYWxsZGF0YSIsImRlY29kZVBhcmFtZXRlcnMiLCJ0eXBlQ2Fpcm8iLCJ0eXBlQ2Fpcm9BcnJheSIsImRlY29kZWRBcnJheSIsInR5cGVQYXJhbSIsImhhc2hfZXhwb3J0cyIsImNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoIiwiY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaCIsImNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzIiwiY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaCIsImNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzIiwiY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoIiwiY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMiIsImNvbXB1dGVDb21waWxlZENsYXNzSGFzaCIsImNvbXB1dGVDb250cmFjdENsYXNzSGFzaCIsImNvbXB1dGVIYXNoT25FbGVtZW50cyIsImNvbXB1dGVIYXNoT25FbGVtZW50czIiLCJjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2giLCJjb21wdXRlUGVkZXJzZW5IYXNoIiwiY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHMiLCJjb21wdXRlUG9zZWlkb25IYXNoIiwiY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMiLCJjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2giLCJmb3JtYXRTcGFjZXMiLCJwb3NlaWRvbiIsInYyX2V4cG9ydHMiLCJjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2giLCJjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24iLCJlY19leHBvcnRzIiwic3RhcmtDdXJ2ZSIsIndlaWVyc3RyYXNzIiwieSIsInBlZGVyc2VuIiwidHhIYXNoUHJlZml4IiwiY29udHJhY3RBZGRyZXNzIiwiZW50cnlQb2ludFNlbGVjdG9yIiwibWF4RmVlIiwiY2hhaW5JZCIsImFkZGl0aW9uYWxEYXRhIiwiY2FsbGRhdGFIYXNoIiwiZGF0YVRvSGFzaCIsImNsYXNzSGFzaCIsInNlbmRlckFkZHJlc3MiLCJub25jZSIsImNvbXBpbGVkQ2xhc3NIYXNoIiwiY29uc3RydWN0b3JDYWxsZGF0YSIsInNhbHQiLCJ2M19leHBvcnRzIiwiY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDIiLCJjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMiIsImNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjIiLCJoYXNoREFNb2RlIiwiaGFzaEZlZUZpZWxkIiwicG9zZWlkb25IYXNoTWFueSIsIkFUb0JJIiwiREFUQV9BVkFJTEFCSUxJVFlfTU9ERV9CSVRTIiwiTUFYX0FNT1VOVF9CSVRTIiwiTUFYX1BSSUNFX1BFUl9VTklUX0JJVFMiLCJSRVNPVVJDRV9WQUxVRV9PRkZTRVQiLCJMMV9HQVNfTkFNRSIsIkwyX0dBU19OQU1FIiwibm9uY2VEQU1vZGUiLCJmZWVEQU1vZGUiLCJ0aXAiLCJib3VuZHMiLCJMMUJvdW5kIiwibDFfZ2FzIiwibWF4X2Ftb3VudCIsIm1heF9wcmljZV9wZXJfdW5pdCIsIkwyQm91bmQiLCJsMl9nYXMiLCJwYXltYXN0ZXJEYXRhIiwibm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSIsImZlZURhdGFBdmFpbGFiaWxpdHlNb2RlIiwicmVzb3VyY2VCb3VuZHMiLCJmZWVGaWVsZEhhc2giLCJkQU1vZGVIYXNoIiwiY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhIiwiYWNjb3VudERlcGxveW1lbnREYXRhIiwiY29tcGlsZWRDYWxsZGF0YSIsImlzVjNJbnZva2VUeCIsImlzVjNEZWNsYXJlVHgiLCJpc1YzRGVwbG95QWNjb3VudFR4IiwicG9zZWlkb25IYXNoTWFueTIiLCJqc29uX2V4cG9ydHMiLCJwYXJzZTIiLCJwYXJzZUFsd2F5c0FzQmlnIiwic3RyaW5naWZ5Iiwic3RyaW5naWZ5MiIsInN0cmluZ2lmeUFsd2F5c0FzQmlnIiwianNvbiIsInBhcnNlSW50QXNOdW1iZXJPckJpZ0ludCIsInBhcnNlRmxvYXQiLCJpc1NhZmVJbnRlZ2VyIiwicGFyc2VOdW1iZXJBbmRCaWdJbnQiLCJyZXBsYWNlciIsInNwYWNlIiwibnVtYmVyU3RyaW5naWZpZXJzIiwicG9zZWlkb25IYXNoIiwiZGVwbG95ZXJBZGRyZXNzIiwiY29uc3RydWN0b3JDYWxsZGF0YUhhc2giLCJDT05UUkFDVF9BRERSRVNTX1BSRUZJWCIsIm51bGxTa2lwUmVwbGFjZXIiLCJqc29uMiIsImluc2lkZVF1b3RlcyIsIm5ld1N0cmluZyIsImNvbXB1dGVIaW50ZWRDbGFzc0hhc2giLCJjb21waWxlZENvbnRyYWN0IiwicHJvZ3JhbSIsImNvbnRyYWN0Q2xhc3MiLCJzZXJpYWxpemVkSnNvbiIsImNvbnRyYWN0IiwiYXBpVmVyc2lvbiIsImV4dGVybmFsRW50cnlQb2ludHNIYXNoIiwiZW50cnlfcG9pbnRzX2J5X3R5cGUiLCJFWFRFUk5BTCIsInNlbGVjdG9yIiwib2Zmc2V0IiwibDFIYW5kbGVyRW50cnlQb2ludHNIYXNoIiwiTDFfSEFORExFUiIsImNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2giLCJDT05TVFJVQ1RPUiIsImJ1aWx0aW5zSGFzaCIsImJ1aWx0aW5zIiwiaGludGVkQ2xhc3NIYXNoIiwiZGF0YUhhc2giLCJoYXNoQnVpbHRpbnMiLCJoYXNoRW50cnlQb2ludCIsImJhc2UiLCJjYXNtIiwiQ09NUElMRURfQ0xBU1NfVkVSU0lPTiIsImNvbXBpbGVkQ2xhc3NWZXJzaW9uIiwibDFIYW5kbGVycyIsImJ5dGVjb2RlIiwiaGFzaEVudHJ5UG9pbnRTaWVycmEiLCJmdW5jdGlvbl9pZHgiLCJoYXNoQWJpIiwic2llcnJhIiwiaW5kZW50U3RyaW5nIiwiQ09OVFJBQ1RfQ0xBU1NfVkVSU0lPTiIsImFiaUhhc2giLCJzaWVycmFQcm9ncmFtIiwic2llcnJhX3Byb2dyYW0iLCJzdGFya19leHBvcnRzIiwiY29tcHJlc3NQcm9ncmFtIiwiZGVjb21wcmVzc1Byb2dyYW0iLCJlc3RpbWF0ZUZlZVRvQm91bmRzIiwiZXN0aW1hdGVkRmVlVG9NYXhGZWUiLCJmb3JtYXRTaWduYXR1cmUiLCJpbnREQU0iLCJtYWtlQWRkcmVzcyIsInJhbmRvbUFkZHJlc3MiLCJyZWR1Y2VWMiIsInNpZ25hdHVyZVRvRGVjaW1hbEFycmF5Iiwic2lnbmF0dXJlVG9IZXhBcnJheSIsInRvRmVlVmVyc2lvbiIsInRvVHJhbnNhY3Rpb25WZXJzaW9uIiwidjNEZXRhaWxzIiwiZ2V0U3RhcmtLZXkiLCJ1dGlscyIsImd6aXAiLCJ1bmd6aXAiLCJqc29uUHJvZ3JhbSIsInN0cmluZ2lmaWVkIiwiY29tcHJlc3NlZFByb2dyYW0iLCJiYXNlNjQyIiwiZGVjb21wcmVzc2VkIiwicmFuZG9tS2V5UGFpciIsInJhbmRvbVByaXZhdGVLZXkiLCJzaWciLCJlc3RpbWF0ZWRGZWUiLCJvdmVyaGVhZCIsImVzdGltYXRlIiwiYW1vdW50T3ZlcmhlYWQiLCJwcmljZU92ZXJoZWFkIiwiZ2FzX2NvbnN1bWVkIiwiZ2FzX3ByaWNlIiwibWF4VW5pdHMiLCJtYXhVbml0UHJpY2UiLCJkYW0iLCJkZWZhdWx0VmVyc2lvbiIsInByb3ZpZGVkVmVyc2lvbiIsInByb3ZpZGVkVmVyc2lvbjB4cyIsImRlZmF1bHRWZXJzaW9uMHhzIiwiZGV0YWlscyIsImlzU2llcnJhIiwiZXh0cmFjdENvbnRyYWN0SGFzaGVzIiwicGF5bG9hZCIsImNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdCIsImNjciIsImlzb21vcnBoaWNGZXRjaCIsImZldGNoUG9ueWZpbGxfZGVmYXVsdCIsIndpbmRvdyIsImZldGNoIiwiZ2xvYmFsIiwicHJvdmlkZXJfZXhwb3J0cyIsIkJsb2NrIiwiY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyIsImZvcm1hdEhhc2giLCJnZXREZWZhdWx0Tm9kZVVybCIsImlzUGVuZGluZ0Jsb2NrIiwiaXNQZW5kaW5nU3RhdGVVcGRhdGUiLCJpc1BlbmRpbmdUcmFuc2FjdGlvbiIsImlzVjNUeCIsImlzVmVyc2lvbiIsInBhcnNlQ29udHJhY3QiLCJ0eElkZW50aWZpZXIiLCJ2YWxpZEJsb2NrVGFncyIsIndhaXQiLCJkZWxheSIsIlByb21pc2UiLCJzZXRUaW1lb3V0Iiwic2llcnJhX3Byb2dyYW1fZGVidWdfaW5mbyIsInBhcnNlZENvbnRyYWN0IiwibmV0d29ya05hbWUiLCJtdXRlIiwiY29uc29sZSIsIndhcm4iLCJub2RlcyIsInJhbmRJZHgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJoYXNoVmFsdWUiLCJ0eEhhc2giLCJ0eElkIiwiSlNPTiIsImhhc2hTdHJpbmciLCJzZXRJZGVudGlmaWVyIiwiX19pZGVudGlmaWVyIiwibnVtYmVyIiwidGFnIiwiX2lkZW50aWZpZXIiLCJ2YWx1ZU9mIiwicXVlcnlJZGVudGlmaWVyIiwiaWRlbnRpZmllciIsImJsb2NrX251bWJlciIsImJsb2NrX2hhc2giLCJtYWpvclMiLCJtaW5vclMiLCJtYWpvclIiLCJtaW5vclIiLCJzdGF0dXMiLCJ0cmFuc2FjdGlvbl9leHBvcnRzIiwiZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEiLCJmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSIsImZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMSIsImdldEV4ZWN1dGVDYWxsZGF0YSIsImdldFZlcnNpb25zQnlUeXBlIiwidHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5cyIsInRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXNfY2Fpcm8xIiwiY2FsbHMiLCJjYWxsIiwidG8iLCJlbnRyeXBvaW50IiwiZGF0YV9vZmZzZXQiLCJkYXRhX2xlbiIsImNvbXBpbGVkQ2FsbHMiLCJvcmRlckNhbGxzIiwiY2Fpcm9WZXJzaW9uIiwidmVyc2lvblR5cGUiLCJ2MSIsInYyIiwidjMiLCJkZWZhdWx0T3B0aW9ucyIsImhlYWRlcnMiLCJibG9ja0lkZW50aWZpZXIiLCJyZXRyaWVzIiwiUnBjQ2hhbm5lbCIsIm9wdGlvbnNPclByb3ZpZGVyIiwibm9kZVVybCIsIndhaXRNb2RlIiwiZGVmYXVsdCIsInJlcXVlc3RJZCIsInBhcmFtcyIsImlkIiwicnBjUmVxdWVzdEJvZHkiLCJqc29ucnBjIiwiYm9keSIsImVycm9ySGFuZGxlciIsInJwY0Vycm9yIiwib3RoZXJFcnJvciIsImNvZGUiLCJmZXRjaEVuZHBvaW50IiwicmF3UmVzdWx0IiwiZ2V0Q2hhaW5JZCIsImdldFNwZWNWZXJzaW9uIiwic3BlY2tWZXJzaW9uIiwiZ2V0Tm9uY2VGb3JBZGRyZXNzIiwiY29udHJhY3RfYWRkcmVzcyIsImJsb2NrX2lkIiwiZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCIsImdldEJsb2NrTnVtYmVyIiwiZ2V0QmxvY2tXaXRoVHhIYXNoZXMiLCJnZXRCbG9ja1dpdGhUeHMiLCJnZXRCbG9ja1N0YXRlVXBkYXRlIiwiZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMiLCJnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQiLCJnZXRUcmFuc2FjdGlvbkJ5SGFzaCIsInRyYW5zYWN0aW9uX2hhc2giLCJnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4IiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwiZ2V0VHJhbnNhY3Rpb25UcmFjZSIsImdldFRyYW5zYWN0aW9uU3RhdHVzIiwidHJhbnNhY3Rpb25IYXNoIiwic2ltdWxhdGVUcmFuc2FjdGlvbiIsImludm9jYXRpb25zIiwic2tpcFZhbGlkYXRlIiwic2tpcEZlZUNoYXJnZSIsInNpbXVsYXRpb25GbGFncyIsIlNLSVBfVkFMSURBVEUiLCJTS0lQX0ZFRV9DSEFSR0UiLCJ0cmFuc2FjdGlvbnMiLCJidWlsZFRyYW5zYWN0aW9uIiwic2ltdWxhdGlvbl9mbGFncyIsIndhaXRGb3JUcmFuc2FjdGlvbiIsIm9wdGlvbnMiLCJvbmNoYWluIiwiaXNFcnJvclN0YXRlIiwicmV0cnlJbnRlcnZhbCIsImVycm9yU3RhdGVzIiwiUkVKRUNURUQiLCJzdWNjZXNzU3RhdGVzIiwiU1VDQ0VFREVEIiwiQUNDRVBURURfT05fTDIiLCJBQ0NFUFRFRF9PTl9MMSIsInR4U3RhdHVzIiwiZXhlY3V0aW9uU3RhdHVzIiwiZXhlY3V0aW9uX3N0YXR1cyIsImZpbmFsaXR5U3RhdHVzIiwiZmluYWxpdHlfc3RhdHVzIiwidHhSZWNlaXB0IiwiZ2V0U3RvcmFnZUF0IiwicGFyc2VkS2V5IiwiZ2V0Q2xhc3NIYXNoQXQiLCJnZXRDbGFzcyIsImNsYXNzX2hhc2giLCJnZXRDbGFzc0F0IiwiZ2V0RXN0aW1hdGVGZWUiLCJmbGFncyIsInJlcXVlc3QiLCJpbnZva2UiLCJmdW5jdGlvbkludm9jYXRpb24iLCJwcm9taXNlIiwiaW52b2tlX3RyYW5zYWN0aW9uIiwic2VuZGVyX2FkZHJlc3MiLCJJTlZPS0UiLCJtYXhfZmVlIiwic2lnbmF0dXJlIiwicmVzb3VyY2VfYm91bmRzIiwicGF5bWFzdGVyX2RhdGEiLCJhY2NvdW50X2RlcGxveW1lbnRfZGF0YSIsIm5vbmNlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGUiLCJmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZSIsImRlY2xhcmUiLCJkZWNsYXJlX3RyYW5zYWN0aW9uIiwiREVDTEFSRSIsImNvbnRyYWN0X2NsYXNzIiwiY29udHJhY3RfY2xhc3NfdmVyc2lvbiIsImNvbXBpbGVkX2NsYXNzX2hhc2giLCJkZXBsb3lBY2NvdW50IiwiYWRkcmVzc1NhbHQiLCJkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbiIsImNvbnN0cnVjdG9yX2NhbGxkYXRhIiwiY29udHJhY3RfYWRkcmVzc19zYWx0IiwiREVQTE9ZX0FDQ09VTlQiLCJjYWxsQ29udHJhY3QiLCJlbnRyeV9wb2ludF9zZWxlY3RvciIsImVzdGltYXRlTWVzc2FnZUZlZSIsImZyb21fYWRkcmVzcyIsInRvX2FkZHJlc3MiLCJmb3JtYXR0ZWRNZXNzYWdlIiwiZ2V0U3luY2luZ1N0YXRzIiwiZ2V0RXZlbnRzIiwiZXZlbnRGaWx0ZXIiLCJpbnZvY2F0aW9uIiwiZGVmYXVsdFZlcnNpb25zIiwicmVzdERldGFpbHMiLCJSUENSZXNwb25zZVBhcnNlciIsInBhcnNlR2V0QmxvY2tSZXNwb25zZSIsInBhcnNlVHJhbnNhY3Rpb25SZWNlaXB0IiwiYWN0dWFsX2ZlZSIsImFtb3VudCIsInVuaXQiLCJwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UiLCJvdmVyYWxsX2ZlZSIsInN1Z2dlc3RlZE1heEZlZSIsInBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UiLCJwYXJzZVNpbXVsYXRlVHJhbnNhY3Rpb25SZXNwb25zZSIsImZlZV9lc3RpbWF0aW9uIiwicGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UiLCJScGNQcm92aWRlciIsImdldFN0YXRlVXBkYXRlIiwiY2hhbm5lbCIsImdldEJsb2NrIiwidGhlbiIsImdldFBlbmRpbmdUcmFuc2FjdGlvbnMiLCJnZXRUcmFuc2FjdGlvbiIsImdldFNpbXVsYXRlVHJhbnNhY3Rpb24iLCJnZXRDbGFzc0J5SGFzaCIsImdldENvbnRyYWN0VmVyc2lvbiIsImFiaVRlc3QiLCJpbnZvY2F0aW9uRGV0YWlscyIsImdldEludm9rZUVzdGltYXRlRmVlIiwiZ2V0RGVjbGFyZUVzdGltYXRlRmVlIiwiZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlIiwiZ2V0RXN0aW1hdGVGZWVCdWxrIiwiaW52b2tlRnVuY3Rpb24iLCJkZWNsYXJlQ29udHJhY3QiLCJ0cmFuc2FjdGlvbiIsImRlcGxveUFjY291bnRDb250cmFjdCIsIk1peGluIiwic3RhcmtuZXRJZF9leHBvcnRzIiwiU3RhcmtuZXRJZENvbnRyYWN0IiwiZ2V0U3RhcmtuZXRJZENvbnRyYWN0IiwidXNlRGVjb2RlZCIsInVzZUVuY29kZWQiLCJiYXNpY0FscGhhYmV0IiwiYmFzaWNTaXplUGx1c09uZSIsImJpZ0FscGhhYmV0IiwiYmFzaWNBbHBoYWJldFNpemUiLCJiaWdBbHBoYWJldFNpemUiLCJiaWdBbHBoYWJldFNpemVQbHVzT25lIiwiZXh0cmFjdFN0YXJzIiwiZW5kc1dpdGgiLCJkZWNvZGVkIiwic3ViZG9tYWluIiwibmV4dFN1YmRvbWFpbiIsImNvZGUyIiwibXVsdGlwbGllciIsImJuSW5kZXgiLCJuZXdpZCIsIlN0YXJrbmV0SWRDb250cmFjdDIiLCJTdGFya25ldElkIiwiZ2V0U3RhcmtOYW1lIiwiYWRkcmVzcyIsImdldEFkZHJlc3NGcm9tU3RhcmtOYW1lIiwicHJvdmlkZXIiLCJoZXhEb21haW4iLCJkZWNpbWFsRG9tYWluIiwic3RyaW5nRG9tYWluIiwiYWRkcmVzc0RhdGEiLCJkb21haW4iLCJScGNQcm92aWRlcjIiLCJQcm92aWRlckludGVyZmFjZSIsImRlZmF1bHRQcm92aWRlciIsIlNpZ25lckludGVyZmFjZSIsInR5cGVkRGF0YV9leHBvcnRzIiwiYnl0ZUFycmF5RnJvbVN0cmluZzIiLCJlbmNvZGVEYXRhIiwiZW5jb2RlVHlwZSIsImVuY29kZVZhbHVlIiwiZ2V0RGVwZW5kZW5jaWVzIiwiZ2V0TWVzc2FnZUhhc2giLCJnZXRTdHJ1Y3RIYXNoIiwiZ2V0VHlwZUhhc2giLCJpc01lcmtsZVRyZWVUeXBlIiwicHJlcGFyZVNlbGVjdG9yIiwibWVya2xlX2V4cG9ydHMiLCJNZXJrbGVUcmVlIiwicHJvb2ZNZXJrbGVQYXRoIiwibGVhZkhhc2hlcyIsImhhc2hNZXRob2QiLCJicmFuY2hlcyIsImxlYXZlcyIsInJvb3QiLCJidWlsZCIsIm5ld0xlYXZlcyIsImFTb3J0ZWQiLCJiU29ydGVkIiwic29ydCIsImdldFByb29mIiwibGVhZiIsImJyYW5jaCIsImhhc2hQYXRoIiwiaXNMZWZ0IiwibmVlZGVkQnJhbmNoIiwibmV3SGFzaFBhdGgiLCJjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCIsIm5leHRCcmFuY2giLCJwYXRoIiwicmVzdCIsInByZXNldFR5cGVzIiwiVG9rZW5BbW91bnQiLCJOZnRJZCIsInJldmlzaW9uQ29uZmlndXJhdGlvbiIsImhhc2hNZXJrbGVNZXRob2QiLCJlc2NhcGVUeXBlU3RyaW5nIiwidGFyZ2V0U3RyaW5nIiwic2hvcnRTdHJpbmdzIiwic2hvcnRTdHJpbmdzRW5jb2RlZCIsInBlbmRpbmdXb3JkIiwicGVuZGluZ1dvcmRMZW5ndGgiLCJpZGVudGlmeVJldmlzaW9uIiwidHlwZXMiLCJyZXZpc2lvbiIsImdldEhleCIsInZhbGlkYXRlVHlwZWREYXRhIiwidHlwZWREYXRhIiwicHJpbWFyeVR5cGUiLCJkZXBlbmRlbmNpZXMiLCJjb250YWlucyIsInByZXZpb3VzIiwidCIsImRlcGVuZGVuY3kiLCJnZXRNZXJrbGVUcmVlVHlwZSIsImN0eCIsInBhcmVudCIsInBhcmVudFR5cGUiLCJtZXJrbGVUeXBlIiwiaXNNZXJrbGVUcmVlIiwicHJpbWFyeSIsIm5ld1R5cGVzIiwiZXNjIiwiZGVwZW5kZW5jeUVsZW1lbnRzIiwidGFyZ2V0VHlwZSIsInR5cGVTdHJpbmciLCJoYXNoZXMiLCJlbnRyeSIsInZhcmlhbnRLZXkiLCJ2YXJpYW50RGF0YSIsImVudW1UeXBlIiwidmFyaWFudEluZGV4IiwiZW5jb2RlZFN1YnR5cGVzIiwic3VidHlwZSIsInN1YnR5cGVEYXRhIiwibWVya2xlVHJlZVR5cGUiLCJzdHJ1Y3RIYXNoZXMiLCJzdHJ1Y3QiLCJieXRlQXJyYXkiLCJyZXR1cm5UeXBlcyIsInRzIiwidnMiLCJmaWVsZCIsImVuY29kZWRWYWx1ZSIsImFjY291bnQiLCJTaWduZXIiLCJwayIsImdldFB1YktleSIsInNpZ25NZXNzYWdlIiwiYWNjb3VudEFkZHJlc3MiLCJtc2dIYXNoIiwic2lnblJhdyIsInNpZ25UcmFuc2FjdGlvbiIsImRldCIsIndhbGxldEFkZHJlc3MiLCJzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uIiwic2lnbkRlY2xhcmVUcmFuc2FjdGlvbiIsInNpZ24iLCJzZWNwMjU2azEiLCJzZWNwMjU2azEyIiwiZXRoX2V4cG9ydHMiLCJldGhSYW5kb21Qcml2YXRlS2V5IiwiRXRoU2lnbmVyIiwiZ2V0UHVibGljS2V5IiwicGFyc2VVRENFdmVudCIsImV2ZW50cyIsImV2ZW50IiwiZGVwbG95ZXIiLCJ1bmlxdWUiLCJjYWxsZGF0YV9sZW4iLCJBY2NvdW50IiwicHJvdmlkZXJPck9wdGlvbnMiLCJwa09yU2lnbmVyIiwidHJhbnNhY3Rpb25WZXJzaW9uIiwiZGVwbG95U2VsZiIsInNpZ25lciIsImdldFByZWZlcnJlZFZlcnNpb24iLCJ0eXBlMTIiLCJ0eXBlMyIsImdldE5vbmNlIiwiZ2V0Tm9uY2VTYWZlIiwiZ2V0Q2Fpcm9WZXJzaW9uIiwiZXN0aW1hdGVGZWUiLCJlc3RpbWF0ZUZlZURldGFpbHMiLCJlc3RpbWF0ZUludm9rZUZlZSIsInByb3ZpZGVkTm9uY2UiLCJzaWduZXJEZXRhaWxzIiwiYnVpbGRJbnZvY2F0aW9uIiwiZXN0aW1hdGVEZWNsYXJlRmVlIiwiZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24iLCJidWlsZERlY2xhcmVQYXlsb2FkIiwiZXN0aW1hdGVBY2NvdW50RGVwbG95RmVlIiwiYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZCIsImVzdGltYXRlRGVwbG95RmVlIiwiYnVpbGRVRENDb250cmFjdFBheWxvYWQiLCJlc3RpbWF0ZUZlZUJ1bGsiLCJhY2NvdW50SW52b2NhdGlvbnMiLCJhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5IiwidmVyc2lvbnMiLCJza2lwRXhlY3V0ZSIsImV4ZWN1dGUiLCJhYmlzIiwiZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlIiwiZGVjbGFyZUlmTm90IiwidHJhbnNhY3Rpb25zRGV0YWlsIiwiZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCIsImRlY2xhcmVEZXRhaWxzIiwiZGVwbG95IiwiY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhIiwiZGVwbG95U2FsdCIsImFkZHJlc3NlcyIsImludm9rZVJlc3BvbnNlIiwiZGVwbG95Q29udHJhY3QiLCJkZXBsb3lUeCIsImRlY2xhcmVBbmREZXBsb3kiLCJ0eCIsInByb3ZpZGVkQ29udHJhY3RBZGRyZXNzIiwiaGFzaE1lc3NhZ2UiLCJ2ZXJpZnlNZXNzYWdlSGFzaCIsInJlc3AiLCJlcnIiLCJzb21lIiwiZXJyTWVzc2FnZSIsInZlcmlmeU1lc3NhZ2UiLCJnZXRTdWdnZXN0ZWRGZWUiLCJmZWVFc3RpbWF0ZSIsImNvbXByZXNzZWRDb21waWxlZENvbnRyYWN0Iiwic2FmZU5vbmNlIiwidHgwUGF5bG9hZCIsInR4UGF5bG9hZCIsImNvbW1vbiIsInZlcnNpb25YIiwiQWNjb3VudEludGVyZmFjZSIsImV2ZW50c19leHBvcnRzIiwiZ2V0QWJpRXZlbnRzIiwicGFyc2VFdmVudHMiLCJzaXplIiwia2luZCIsImVudHJ5TmFtZSIsImFiaUVudHJ5TW9kIiwicHJvdmlkZXJSZWNlaXZlZEV2ZW50cyIsImFiaUV2ZW50cyIsImFiaVN0cnVjdHMiLCJhYmlFbnVtcyIsInJldCIsInJlY0V2ZW50IiwiYWJpRXZlbnQiLCJwYXJzZWRFdmVudCIsImtleXNJdGVyIiwiZGF0YUl0ZXIiLCJhYmlFdmVudEtleXMiLCJhYmlFdmVudERhdGEiLCJzcGxpdEFyZ3NBbmRPcHRpb25zIiwibGFzdEFyZyIsImJ1aWxkQ2FsbCIsImZ1bmN0aW9uQWJpIiwicGFyc2VSZXF1ZXN0IiwicGFyc2VSZXNwb25zZSIsImJ1aWxkSW52b2tlIiwiYnVpbGREZWZhdWx0IiwiYnVpbGRQb3B1bGF0ZSIsInBvcHVsYXRlIiwiYnVpbGRFc3RpbWF0ZSIsImdldENhbGxkYXRhIiwiY2FsbGJhY2siLCJDb250cmFjdCIsInByb3ZpZGVyT3JBY2NvdW50IiwiY2FsbERhdGEiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZnVuY3Rpb25zIiwiY2FsbFN0YXRpYyIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJhYmlFbGVtZW50IiwiYXR0YWNoIiwiY29ubmVjdCIsImRlcGxveWVkIiwiZGVwbG95VHJhbnNhY3Rpb25IYXNoIiwiZm9ybWF0UmVzcG9uc2UiLCJyZWNlaXB0IiwiaXNDYWlybzEiLCJnZXRWZXJzaW9uIiwidHlwZWR2MSIsInRBYmkiLCJ0eXBlZHYyIiwiQ29udHJhY3RJbnRlcmZhY2UiLCJDb250cmFjdEZhY3RvcnkiLCJjb250cmFjdEluc3RhbmNlIiwidWludDI1Nl9leHBvcnRzIiwiYm5Ub1VpbnQyNTYiLCJpc1VpbnQyNTYiLCJ1aW50MjU2VG9CTiIsInVpbnQyNTYyIiwiaGV4VG9CeXRlczIiLCJhZGRBZGRyZXNzUGFkZGluZyIsInZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzIiwiZ2V0Q2hlY2tzdW1BZGRyZXNzIiwiY2hhcnMiLCJoYXNoZWQiLCJ2YWxpZGF0ZUNoZWNrc3VtQWRkcmVzcyIsInVybGpvaW4iLCJwcm90b2NvbEFuZERvbWFpblJFIiwibG9jYWxob3N0RG9tYWluUkUiLCJub25Mb2NhbGhvc3REb21haW5SRSIsImlzVXJsIiwiZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wiLCJidWlsZFVybCIsImJhc2VVcmwiLCJkZWZhdWx0UGF0aCIsInVybE9yUGF0aCIsIlByb3ZpZGVyIiwiY29uc3RhbnRzIiwiZWMiLCJldGgiLCJtZXJrbGUiLCJzaG9ydFN0cmluZyIsInN0YXJrIiwic3RhcmtuZXRJZCIsInYyaGFzaCIsInYzaGFzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/dist/index.mjs\n");

/***/ })

};
;